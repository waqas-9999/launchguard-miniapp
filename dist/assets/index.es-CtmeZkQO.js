const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/secp256k1-BMv5ED--.js","assets/index-CrAQh-3d.js","assets/index-DRKR6vtq.css","assets/core-CZ-n-4YL.js"])))=>i.map(i=>d[i]);
import{be as Su,bf as xu,bg as Ou,bh as Au,bi as Cu,bj as Ru,bk as Nu,bl as Tu,bm as Bu,bn as Du,bo as Qt,bp as Xt,bq as Xe,br as T,bs as wo,_ as eh,bt as ju,bu as Ni,bv as th,bw as ku,bx as qu,by as sr,bz as Uu,bA as Ne,bB as Ve,bC as Mn,bD as Fn}from"./index-CrAQh-3d.js";var bo=function(i,e,t){if(t||arguments.length===2)for(var s=0,r=e.length,n;s<r;s++)(n||!(s in e))&&(n||(n=Array.prototype.slice.call(e,0,s)),n[s]=e[s]);return i.concat(n||Array.prototype.slice.call(e))},Lu=function(){function i(e,t,s){this.name=e,this.version=t,this.os=s,this.type="browser"}return i}(),Mu=function(){function i(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return i}(),Fu=function(){function i(e,t,s,r){this.name=e,this.version=t,this.os=s,this.bot=r,this.type="bot-device"}return i}(),zu=function(){function i(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return i}(),Hu=function(){function i(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return i}(),Ku=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,Vu=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,vo=3,Wu=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",Ku]],Eo=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function Gu(i){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new Hu:typeof navigator<"u"?Yu(navigator.userAgent):Qu()}function Ju(i){return i!==""&&Wu.reduce(function(e,t){var s=t[0],r=t[1];if(e)return e;var n=r.exec(i);return!!n&&[s,n]},!1)}function Yu(i){var e=Ju(i);if(!e)return null;var t=e[0],s=e[1];if(t==="searchbot")return new zu;var r=s[1]&&s[1].split(".").join("_").split("_").slice(0,3);r?r.length<vo&&(r=bo(bo([],r,!0),Xu(vo-r.length),!0)):r=[];var n=r.join("."),o=Zu(i),a=Vu.exec(i);return a&&a[1]?new Fu(t,n,o,a[1]):new Lu(t,n,o)}function Zu(i){for(var e=0,t=Eo.length;e<t;e++){var s=Eo[e],r=s[0],n=s[1],o=n.exec(i);if(o)return r}return null}function Qu(){var i=typeof process<"u"&&process.version;return i?new Mu(process.version.slice(1)):null}function Xu(i){for(var e=[],t=0;t<i;t++)e.push("0");return e}function ih(i=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(i):new Uint8Array(i)}function rs(i,e){e||(e=i.reduce((r,n)=>r+n.length,0));const t=ih(e);let s=0;for(const r of i)t.set(r,s),s+=r.length;return t}const Io={...Du,...Bu,...Tu,...Nu,...Ru,...Cu,...Au,...Ou,...xu,...Su};function sh(i,e,t,s){return{name:i,prefix:e,encoder:{name:i,prefix:e,encode:t},decoder:{decode:s}}}const $o=sh("utf8","u",i=>"u"+new TextDecoder("utf8").decode(i),i=>new TextEncoder().encode(i.substring(1))),Er=sh("ascii","a",i=>{let e="a";for(let t=0;t<i.length;t++)e+=String.fromCharCode(i[t]);return e},i=>{i=i.substring(1);const e=ih(i.length);for(let t=0;t<i.length;t++)e[t]=i.charCodeAt(t);return e}),rh={utf8:$o,"utf-8":$o,hex:Io.base16,latin1:Er,ascii:Er,binary:Er,...Io};function Qe(i,e="utf8"){const t=rh[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(i,"utf8"):t.decoder.decode(`${t.prefix}${i}`)}function qe(i,e="utf8"){const t=rh[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(i.buffer,i.byteOffset,i.byteLength).toString("utf8"):t.encoder.encode(i).substring(1)}const ed={waku:{publish:"waku_publish",batchPublish:"waku_batchPublish",subscribe:"waku_subscribe",batchSubscribe:"waku_batchSubscribe",subscription:"waku_subscription",unsubscribe:"waku_unsubscribe",batchUnsubscribe:"waku_batchUnsubscribe",batchFetchMessages:"waku_batchFetchMessages"},irn:{publish:"irn_publish",batchPublish:"irn_batchPublish",subscribe:"irn_subscribe",batchSubscribe:"irn_batchSubscribe",subscription:"irn_subscription",unsubscribe:"irn_unsubscribe",batchUnsubscribe:"irn_batchUnsubscribe",batchFetchMessages:"irn_batchFetchMessages"},iridium:{publish:"iridium_publish",batchPublish:"iridium_batchPublish",subscribe:"iridium_subscribe",batchSubscribe:"iridium_batchSubscribe",subscription:"iridium_subscription",unsubscribe:"iridium_unsubscribe",batchUnsubscribe:"iridium_batchUnsubscribe",batchFetchMessages:"iridium_batchFetchMessages"}},td=/"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,id=/"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,sd=/^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;function rd(i,e){if(i==="__proto__"||i==="constructor"&&e&&typeof e=="object"&&"prototype"in e){return}return e}function _s(i,e={}){if(typeof i!="string")return i;if(i[0]==='"'&&i[i.length-1]==='"'&&i.indexOf("\\")===-1)return i.slice(1,-1);const t=i.trim();if(t.length<=9)switch(t.toLowerCase()){case"true":return!0;case"false":return!1;case"undefined":return;case"null":return null;case"nan":return Number.NaN;case"infinity":return Number.POSITIVE_INFINITY;case"-infinity":return Number.NEGATIVE_INFINITY}if(!sd.test(i)){if(e.strict)throw new SyntaxError("[destr] Invalid JSON");return i}try{if(td.test(i)||id.test(i)){if(e.strict)throw new Error("[destr] Possible prototype pollution");return JSON.parse(i,rd)}return JSON.parse(i)}catch(s){if(e.strict)throw s;return i}}function nd(i){return!i||typeof i.then!="function"?Promise.resolve(i):i}function ge(i,...e){try{return nd(i(...e))}catch(t){return Promise.reject(t)}}function od(i){const e=typeof i;return i===null||e!=="object"&&e!=="function"}function ad(i){const e=Object.getPrototypeOf(i);return!e||e.isPrototypeOf(Object)}function Ls(i){if(od(i))return String(i);if(ad(i)||Array.isArray(i))return JSON.stringify(i);if(typeof i.toJSON=="function")return Ls(i.toJSON());throw new Error("[unstorage] Cannot stringify value!")}const rn="base64:";function cd(i){return typeof i=="string"?i:rn+ud(i)}function hd(i){return typeof i!="string"||!i.startsWith(rn)?i:ld(i.slice(rn.length))}function ld(i){return globalThis.Buffer?Buffer.from(i,"base64"):Uint8Array.from(globalThis.atob(i),e=>e.codePointAt(0))}function ud(i){return globalThis.Buffer?Buffer.from(i).toString("base64"):globalThis.btoa(String.fromCodePoint(...i))}function De(i){return i&&i.split("?")[0]?.replace(/[/\\]/g,":").replace(/:+/g,":").replace(/^:|:$/g,"")||""}function dd(...i){return De(i.join(":"))}function Ps(i){return i=De(i),i?i+":":""}function pd(i,e){if(e===void 0)return!0;let t=0,s=i.indexOf(":");for(;s>-1;)t++,s=i.indexOf(":",s+1);return t<=e}function fd(i,e){return e?i.startsWith(e)&&i[i.length-1]!=="$":i[i.length-1]!=="$"}const gd="memory",yd=()=>{const i=new Map;return{name:gd,getInstance:()=>i,hasItem(e){return i.has(e)},getItem(e){return i.get(e)??null},getItemRaw(e){return i.get(e)??null},setItem(e,t){i.set(e,t)},setItemRaw(e,t){i.set(e,t)},removeItem(e){i.delete(e)},getKeys(){return[...i.keys()]},clear(){i.clear()},dispose(){i.clear()}}};function md(i={}){const e={mounts:{"":i.driver||yd()},mountpoints:[""],watching:!1,watchListeners:[],unwatch:{}},t=h=>{for(const l of e.mountpoints)if(h.startsWith(l))return{base:l,relativeKey:h.slice(l.length),driver:e.mounts[l]};return{base:"",relativeKey:h,driver:e.mounts[""]}},s=(h,l)=>e.mountpoints.filter(u=>u.startsWith(h)||l&&h.startsWith(u)).map(u=>({relativeBase:h.length>u.length?h.slice(u.length):void 0,mountpoint:u,driver:e.mounts[u]})),r=(h,l)=>{if(e.watching){l=De(l);for(const u of e.watchListeners)u(h,l)}},n=async()=>{if(!e.watching){e.watching=!0;for(const h in e.mounts)e.unwatch[h]=await _o(e.mounts[h],r,h)}},o=async()=>{if(e.watching){for(const h in e.unwatch)await e.unwatch[h]();e.unwatch={},e.watching=!1}},a=(h,l,u)=>{const d=new Map,f=p=>{let g=d.get(p.base);return g||(g={driver:p.driver,base:p.base,items:[]},d.set(p.base,g)),g};for(const p of h){const g=typeof p=="string",y=De(g?p:p.key),b=g?void 0:p.value,m=g||!p.options?l:{...l,...p.options},w=t(y);f(w).items.push({key:y,value:b,relativeKey:w.relativeKey,options:m})}return Promise.all([...d.values()].map(p=>u(p))).then(p=>p.flat())},c={hasItem(h,l={}){h=De(h);const{relativeKey:u,driver:d}=t(h);return ge(d.hasItem,u,l)},getItem(h,l={}){h=De(h);const{relativeKey:u,driver:d}=t(h);return ge(d.getItem,u,l).then(f=>_s(f))},getItems(h,l={}){return a(h,l,u=>u.driver.getItems?ge(u.driver.getItems,u.items.map(d=>({key:d.relativeKey,options:d.options})),l).then(d=>d.map(f=>({key:dd(u.base,f.key),value:_s(f.value)}))):Promise.all(u.items.map(d=>ge(u.driver.getItem,d.relativeKey,d.options).then(f=>({key:d.key,value:_s(f)})))))},getItemRaw(h,l={}){h=De(h);const{relativeKey:u,driver:d}=t(h);return d.getItemRaw?ge(d.getItemRaw,u,l):ge(d.getItem,u,l).then(f=>hd(f))},async setItem(h,l,u={}){if(l===void 0)return c.removeItem(h);h=De(h);const{relativeKey:d,driver:f}=t(h);f.setItem&&(await ge(f.setItem,d,Ls(l),u),f.watch||r("update",h))},async setItems(h,l){await a(h,l,async u=>{if(u.driver.setItems)return ge(u.driver.setItems,u.items.map(d=>({key:d.relativeKey,value:Ls(d.value),options:d.options})),l);u.driver.setItem&&await Promise.all(u.items.map(d=>ge(u.driver.setItem,d.relativeKey,Ls(d.value),d.options)))})},async setItemRaw(h,l,u={}){if(l===void 0)return c.removeItem(h,u);h=De(h);const{relativeKey:d,driver:f}=t(h);if(f.setItemRaw)await ge(f.setItemRaw,d,l,u);else if(f.setItem)await ge(f.setItem,d,cd(l),u);else return;f.watch||r("update",h)},async removeItem(h,l={}){typeof l=="boolean"&&(l={removeMeta:l}),h=De(h);const{relativeKey:u,driver:d}=t(h);d.removeItem&&(await ge(d.removeItem,u,l),(l.removeMeta||l.removeMata)&&await ge(d.removeItem,u+"$",l),d.watch||r("remove",h))},async getMeta(h,l={}){typeof l=="boolean"&&(l={nativeOnly:l}),h=De(h);const{relativeKey:u,driver:d}=t(h),f=Object.create(null);if(d.getMeta&&Object.assign(f,await ge(d.getMeta,u,l)),!l.nativeOnly){const p=await ge(d.getItem,u+"$",l).then(g=>_s(g));p&&typeof p=="object"&&(typeof p.atime=="string"&&(p.atime=new Date(p.atime)),typeof p.mtime=="string"&&(p.mtime=new Date(p.mtime)),Object.assign(f,p))}return f},setMeta(h,l,u={}){return this.setItem(h+"$",l,u)},removeMeta(h,l={}){return this.removeItem(h+"$",l)},async getKeys(h,l={}){h=Ps(h);const u=s(h,!0);let d=[];const f=[];let p=!0;for(const y of u){y.driver.flags?.maxDepth||(p=!1);const b=await ge(y.driver.getKeys,y.relativeBase,l);for(const m of b){const w=y.mountpoint+De(m);d.some($=>w.startsWith($))||f.push(w)}d=[y.mountpoint,...d.filter(m=>!m.startsWith(y.mountpoint))]}const g=l.maxDepth!==void 0&&!p;return f.filter(y=>(!g||pd(y,l.maxDepth))&&fd(y,h))},async clear(h,l={}){h=Ps(h),await Promise.all(s(h,!1).map(async u=>{if(u.driver.clear)return ge(u.driver.clear,u.relativeBase,l);if(u.driver.removeItem){const d=await u.driver.getKeys(u.relativeBase||"",l);return Promise.all(d.map(f=>u.driver.removeItem(f,l)))}}))},async dispose(){await Promise.all(Object.values(e.mounts).map(h=>Po(h)))},async watch(h){return await n(),e.watchListeners.push(h),async()=>{e.watchListeners=e.watchListeners.filter(l=>l!==h),e.watchListeners.length===0&&await o()}},async unwatch(){e.watchListeners=[],await o()},mount(h,l){if(h=Ps(h),h&&e.mounts[h])throw new Error(`already mounted at ${h}`);return h&&(e.mountpoints.push(h),e.mountpoints.sort((u,d)=>d.length-u.length)),e.mounts[h]=l,e.watching&&Promise.resolve(_o(l,r,h)).then(u=>{e.unwatch[h]=u}).catch(console.error),c},async unmount(h,l=!0){h=Ps(h),!(!h||!e.mounts[h])&&(e.watching&&h in e.unwatch&&(e.unwatch[h]?.(),delete e.unwatch[h]),l&&await Po(e.mounts[h]),e.mountpoints=e.mountpoints.filter(u=>u!==h),delete e.mounts[h])},getMount(h=""){h=De(h)+":";const l=t(h);return{driver:l.driver,base:l.base}},getMounts(h="",l={}){return h=De(h),s(h,l.parents).map(d=>({driver:d.driver,base:d.mountpoint}))},keys:(h,l={})=>c.getKeys(h,l),get:(h,l={})=>c.getItem(h,l),set:(h,l,u={})=>c.setItem(h,l,u),has:(h,l={})=>c.hasItem(h,l),del:(h,l={})=>c.removeItem(h,l),remove:(h,l={})=>c.removeItem(h,l)};return c}function _o(i,e,t){return i.watch?i.watch((s,r)=>e(s,t+r)):()=>{}}async function Po(i){typeof i.dispose=="function"&&await ge(i.dispose)}function ri(i){return new Promise((e,t)=>{i.oncomplete=i.onsuccess=()=>e(i.result),i.onabort=i.onerror=()=>t(i.error)})}function nh(i,e){let t;const s=()=>{if(t)return t;const r=indexedDB.open(i);return r.onupgradeneeded=()=>r.result.createObjectStore(e),t=ri(r),t.then(n=>{n.onclose=()=>t=void 0},()=>{}),t};return(r,n)=>s().then(o=>n(o.transaction(e,r).objectStore(e)))}let Ir;function gs(){return Ir||(Ir=nh("keyval-store","keyval")),Ir}function So(i,e=gs()){return e("readonly",t=>ri(t.get(i)))}function wd(i,e,t=gs()){return t("readwrite",s=>(s.put(e,i),ri(s.transaction)))}function bd(i,e=gs()){return e("readwrite",t=>(t.delete(i),ri(t.transaction)))}function vd(i=gs()){return i("readwrite",e=>(e.clear(),ri(e.transaction)))}function Ed(i,e){return i.openCursor().onsuccess=function(){this.result&&(e(this.result),this.result.continue())},ri(i.transaction)}function Id(i=gs()){return i("readonly",e=>{if(e.getAllKeys)return ri(e.getAllKeys());const t=[];return Ed(e,s=>t.push(s.key)).then(()=>t)})}const $d="idb-keyval";var _d=(i={})=>{const e=i.base&&i.base.length>0?`${i.base}:`:"",t=r=>e+r;let s;return i.dbName&&i.storeName&&(s=nh(i.dbName,i.storeName)),{name:$d,options:i,async hasItem(r){return!(typeof await So(t(r),s)>"u")},async getItem(r){return await So(t(r),s)??null},setItem(r,n){return wd(t(r),n,s)},removeItem(r){return bd(t(r),s)},getKeys(){return Id(s)},clear(){return vd(s)}}};const Pd="WALLET_CONNECT_V2_INDEXED_DB",Sd="keyvaluestorage";let xd=class{constructor(){this.indexedDb=md({driver:_d({dbName:Pd,storeName:Sd})})}async getKeys(){return this.indexedDb.getKeys()}async getEntries(){return(await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e=>[e.key,e.value])}async getItem(e){const t=await this.indexedDb.getItem(e);if(t!==null)return t}async setItem(e,t){await this.indexedDb.setItem(e,Xt(t))}async removeItem(e){await this.indexedDb.removeItem(e)}};var $r=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},Ms={exports:{}};(function(){let i;function e(){}i=e,i.prototype.getItem=function(t){return this.hasOwnProperty(t)?String(this[t]):null},i.prototype.setItem=function(t,s){this[t]=String(s)},i.prototype.removeItem=function(t){delete this[t]},i.prototype.clear=function(){const t=this;Object.keys(t).forEach(function(s){t[s]=void 0,delete t[s]})},i.prototype.key=function(t){return t=t||0,Object.keys(this)[t]},i.prototype.__defineGetter__("length",function(){return Object.keys(this).length}),typeof $r<"u"&&$r.localStorage?Ms.exports=$r.localStorage:typeof window<"u"&&window.localStorage?Ms.exports=window.localStorage:Ms.exports=new e})();function Od(i){var e;return[i[0],Qt((e=i[1])!=null?e:"")]}let Ad=class{constructor(){this.localStorage=Ms.exports}async getKeys(){return Object.keys(this.localStorage)}async getEntries(){return Object.entries(this.localStorage).map(Od)}async getItem(e){const t=this.localStorage.getItem(e);if(t!==null)return Qt(t)}async setItem(e,t){this.localStorage.setItem(e,Xt(t))}async removeItem(e){this.localStorage.removeItem(e)}};const Cd="wc_storage_version",xo=1,Rd=async(i,e,t)=>{const s=Cd,r=await e.getItem(s);if(r&&r>=xo){t(e);return}const n=await i.getKeys();if(!n.length){t(e);return}const o=[];for(;n.length;){const a=n.shift();if(!a)continue;const c=a.toLowerCase();if(c.includes("wc@")||c.includes("walletconnect")||c.includes("wc_")||c.includes("wallet_connect")){const h=await i.getItem(a);await e.setItem(a,h),o.push(a)}}await e.setItem(s,xo),t(e),Nd(i,o)},Nd=async(i,e)=>{e.length&&e.forEach(async t=>{await i.removeItem(t)})};let Td=class{constructor(){this.initialized=!1,this.setInitialized=t=>{this.storage=t,this.initialized=!0};const e=new Ad;this.storage=e;try{const t=new xd;Rd(e,t,this.setInitialized)}catch{this.initialized=!0}}async getKeys(){return await this.initialize(),this.storage.getKeys()}async getEntries(){return await this.initialize(),this.storage.getEntries()}async getItem(e){return await this.initialize(),this.storage.getItem(e)}async setItem(e,t){return await this.initialize(),this.storage.setItem(e,t)}async removeItem(e){return await this.initialize(),this.storage.removeItem(e)}async initialize(){this.initialized||await new Promise(e=>{const t=setInterval(()=>{this.initialized&&(clearInterval(t),e())},20)})}};class ni{}let Bd=class extends ni{constructor(e){super()}};const Oo=T.FIVE_SECONDS,oi={pulse:"heartbeat_pulse"};let Dd=class oh extends Bd{constructor(e){super(e),this.events=new Xe.EventEmitter,this.interval=Oo,this.interval=e?.interval||Oo}static async init(e){const t=new oh(e);return await t.init(),t}async init(){await this.initialize()}stop(){clearInterval(this.intervalRef)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async initialize(){this.intervalRef=setInterval(()=>this.pulse(),T.toMiliseconds(this.interval))}pulse(){this.events.emit(oi.pulse)}};const jd="PARSE_ERROR",kd="INVALID_REQUEST",qd="METHOD_NOT_FOUND",Ud="INVALID_PARAMS",ah="INTERNAL_ERROR",zn="SERVER_ERROR",Ld=[-32700,-32600,-32601,-32602,-32603],ns={[jd]:{code:-32700,message:"Parse error"},[kd]:{code:-32600,message:"Invalid Request"},[qd]:{code:-32601,message:"Method not found"},[Ud]:{code:-32602,message:"Invalid params"},[ah]:{code:-32603,message:"Internal error"},[zn]:{code:-32e3,message:"Server error"}},ch=zn;function Md(i){return Ld.includes(i)}function Ao(i){return Object.keys(ns).includes(i)?ns[i]:ns[ch]}function Fd(i){const e=Object.values(ns).find(t=>t.code===i);return e||ns[ch]}function hh(i,e,t){return i.message.includes("getaddrinfo ENOTFOUND")||i.message.includes("connect ECONNREFUSED")?new Error(`Unavailable ${t} RPC url at ${e}`):i}function gt(i=3){const e=Date.now()*Math.pow(10,i),t=Math.floor(Math.random()*Math.pow(10,i));return e+t}function Jt(i=6){return BigInt(gt(i))}function jt(i,e,t){return{id:t||gt(),jsonrpc:"2.0",method:i,params:e}}function rr(i,e){return{id:i,jsonrpc:"2.0",result:e}}function nr(i,e,t){return{id:i,jsonrpc:"2.0",error:zd(e)}}function zd(i,e){return typeof i>"u"?Ao(ah):(typeof i=="string"&&(i=Object.assign(Object.assign({},Ao(zn)),{message:i})),Md(i.code)&&(i=Fd(i.code)),i)}class Hd{}class Kd extends Hd{constructor(){super()}}class Vd extends Kd{constructor(e){super()}}const Wd="^https?:",Gd="^wss?:";function Jd(i){const e=i.match(new RegExp(/^\w+:/,"gi"));if(!(!e||!e.length))return e[0]}function lh(i,e){const t=Jd(i);return typeof t>"u"?!1:new RegExp(e).test(t)}function Co(i){return lh(i,Wd)}function Ro(i){return lh(i,Gd)}function Yd(i){return new RegExp("wss?://localhost(:d{2,5})?").test(i)}function uh(i){return typeof i=="object"&&"id"in i&&"jsonrpc"in i&&i.jsonrpc==="2.0"}function Hn(i){return uh(i)&&"method"in i}function or(i){return uh(i)&&(yt(i)||Ze(i))}function yt(i){return"result"in i}function Ze(i){return"error"in i}class et extends Vd{constructor(e){super(e),this.events=new Xe.EventEmitter,this.hasRegisteredEventListeners=!1,this.connection=this.setConnection(e),this.connection.connected&&this.registerEventListeners()}async connect(e=this.connection){await this.open(e)}async disconnect(){await this.close()}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async request(e,t){return this.requestStrict(jt(e.method,e.params||[],e.id||Jt().toString()),t)}async requestStrict(e,t){return new Promise(async(s,r)=>{if(!this.connection.connected)try{await this.open()}catch(n){r(n)}this.events.on(`${e.id}`,n=>{Ze(n)?r(n.error):s(n.result)});try{await this.connection.send(e,t)}catch(n){r(n)}})}setConnection(e=this.connection){return e}onPayload(e){this.events.emit("payload",e),or(e)?this.events.emit(`${e.id}`,e):this.events.emit("message",{type:e.method,data:e.params})}onClose(e){e&&e.code===3e3&&this.events.emit("error",new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason?`(${e.reason})`:""}`)),this.events.emit("disconnect")}async open(e=this.connection){this.connection===e&&this.connection.connected||(this.connection.connected&&this.close(),typeof e=="string"&&(await this.connection.open(e),e=this.connection),this.connection=this.setConnection(e),await this.connection.open(),this.registerEventListeners(),this.events.emit("connect"))}async close(){await this.connection.close()}registerEventListeners(){this.hasRegisteredEventListeners||(this.connection.on("payload",e=>this.onPayload(e)),this.connection.on("close",e=>this.onClose(e)),this.connection.on("error",e=>this.events.emit("error",e)),this.connection.on("register_error",e=>this.onClose()),this.hasRegisteredEventListeners=!0)}}var _r,No;function Zd(){return No||(No=1,_r=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")}),_r}var Qd=Object.defineProperty,Xd=Object.defineProperties,ep=Object.getOwnPropertyDescriptors,To=Object.getOwnPropertySymbols,tp=Object.prototype.hasOwnProperty,ip=Object.prototype.propertyIsEnumerable,Bo=(i,e,t)=>e in i?Qd(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Do=(i,e)=>{for(var t in e||(e={}))tp.call(e,t)&&Bo(i,t,e[t]);if(To)for(var t of To(e))ip.call(e,t)&&Bo(i,t,e[t]);return i},jo=(i,e)=>Xd(i,ep(e));const sp={Accept:"application/json","Content-Type":"application/json"},rp="POST",ko={headers:sp,method:rp},qo=10;let ht=class{constructor(e,t=!1){if(this.url=e,this.disableProviderPing=t,this.events=new Xe.EventEmitter,this.isAvailable=!1,this.registering=!1,!Co(e))throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);this.url=e,this.disableProviderPing=t}get connected(){return this.isAvailable}get connecting(){return this.registering}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async open(e=this.url){await this.register(e)}async close(){if(!this.isAvailable)throw new Error("Connection already closed");this.onClose()}async send(e){this.isAvailable||await this.register();try{const t=Xt(e),s=await(await wo(this.url,jo(Do({},ko),{body:t}))).json();this.onPayload({data:s})}catch(t){this.onError(e.id,t)}}async register(e=this.url){if(!Co(e))throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);if(this.registering){const t=this.events.getMaxListeners();return(this.events.listenerCount("register_error")>=t||this.events.listenerCount("open")>=t)&&this.events.setMaxListeners(t+1),new Promise((s,r)=>{this.events.once("register_error",n=>{this.resetMaxListeners(),r(n)}),this.events.once("open",()=>{if(this.resetMaxListeners(),typeof this.isAvailable>"u")return r(new Error("HTTP connection is missing or invalid"));s()})})}this.url=e,this.registering=!0;try{if(!this.disableProviderPing){const t=Xt({id:1,jsonrpc:"2.0",method:"test",params:[]});await wo(e,jo(Do({},ko),{body:t}))}this.onOpen()}catch(t){const s=this.parseError(t);throw this.events.emit("register_error",s),this.onClose(),s}}onOpen(){this.isAvailable=!0,this.registering=!1,this.events.emit("open")}onClose(){this.isAvailable=!1,this.registering=!1,this.events.emit("close")}onPayload(e){if(typeof e.data>"u")return;const t=typeof e.data=="string"?Qt(e.data):e.data;this.events.emit("payload",t)}onError(e,t){const s=this.parseError(t),r=s.message||s.toString(),n=nr(e,r);this.events.emit("payload",n)}parseError(e,t=this.url){return hh(e,t,"HTTP")}resetMaxListeners(){this.events.getMaxListeners()>qo&&this.events.setMaxListeners(qo)}};function hs(i,{strict:e=!0}={}){return!i||typeof i!="string"?!1:e?/^0x[0-9a-fA-F]*$/.test(i):i.startsWith("0x")}function Uo(i){return hs(i,{strict:!1})?Math.ceil((i.length-2)/2):i.length}const dh="2.23.2";let Pr={getDocsUrl:({docsBaseUrl:i,docsPath:e="",docsSlug:t})=>e?`${i??"https://viem.sh"}${e}${t?`#${t}`:""}`:void 0,version:`viem@${dh}`};class ei extends Error{constructor(e,t={}){const s=t.cause instanceof ei?t.cause.details:t.cause?.message?t.cause.message:t.details,r=t.cause instanceof ei&&t.cause.docsPath||t.docsPath,n=Pr.getDocsUrl?.({...t,docsPath:r}),o=[e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...n?[`Docs: ${n}`]:[],...s?[`Details: ${s}`]:[],...Pr.version?[`Version: ${Pr.version}`]:[]].join(`
`);super(o,t.cause?{cause:t.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=s,this.docsPath=r,this.metaMessages=t.metaMessages,this.name=t.name??this.name,this.shortMessage=e,this.version=dh}walk(e){return ph(this,e)}}function ph(i,e){return e?.(i)?i:i&&typeof i=="object"&&"cause"in i&&i.cause!==void 0?ph(i.cause,e):e?null:i}class fh extends ei{constructor({size:e,targetSize:t,type:s}){super(`${s.charAt(0).toUpperCase()}${s.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,{name:"SizeExceedsPaddingSizeError"})}}function Li(i,{dir:e,size:t=32}={}){return typeof i=="string"?np(i,{dir:e,size:t}):op(i,{dir:e,size:t})}function np(i,{dir:e,size:t=32}={}){if(t===null)return i;const s=i.replace("0x","");if(s.length>t*2)throw new fh({size:Math.ceil(s.length/2),targetSize:t,type:"hex"});return`0x${s[e==="right"?"padEnd":"padStart"](t*2,"0")}`}function op(i,{dir:e,size:t=32}={}){if(t===null)return i;if(i.length>t)throw new fh({size:i.length,targetSize:t,type:"bytes"});const s=new Uint8Array(t);for(let r=0;r<t;r++){const n=e==="right";s[n?r:t-r-1]=i[n?r:i.length-r-1]}return s}class ap extends ei{constructor({max:e,min:t,signed:s,size:r,value:n}){super(`Number "${n}" is not in safe ${r?`${r*8}-bit ${s?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`,{name:"IntegerOutOfRangeError"})}}class cp extends ei{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`,{name:"SizeOverflowError"})}}function Mi(i,{size:e}){if(Uo(i)>e)throw new cp({givenSize:Uo(i),maxSize:e})}function nn(i,e={}){const{signed:t}=e;e.size&&Mi(i,{size:e.size});const s=BigInt(i);if(!t)return s;const r=(i.length-2)/2,n=(1n<<BigInt(r)*8n-1n)-1n;return s<=n?s:s-BigInt(`0x${"f".padStart(r*2,"f")}`)-1n}function hp(i,e={}){return Number(nn(i,e))}const lp=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function on(i,e={}){return typeof i=="number"||typeof i=="bigint"?yh(i,e):typeof i=="string"?pp(i,e):typeof i=="boolean"?up(i,e):gh(i,e)}function up(i,e={}){const t=`0x${Number(i)}`;return typeof e.size=="number"?(Mi(t,{size:e.size}),Li(t,{size:e.size})):t}function gh(i,e={}){let t="";for(let r=0;r<i.length;r++)t+=lp[i[r]];const s=`0x${t}`;return typeof e.size=="number"?(Mi(s,{size:e.size}),Li(s,{dir:"right",size:e.size})):s}function yh(i,e={}){const{signed:t,size:s}=e,r=BigInt(i);let n;s?t?n=(1n<<BigInt(s)*8n-1n)-1n:n=2n**(BigInt(s)*8n)-1n:typeof i=="number"&&(n=BigInt(Number.MAX_SAFE_INTEGER));const o=typeof n=="bigint"&&t?-n-1n:0;if(n&&r>n||r<o){const c=typeof i=="bigint"?"n":"";throw new ap({max:n?`${n}${c}`:void 0,min:`${o}${c}`,signed:t,size:s,value:`${i}${c}`})}const a=`0x${(t&&r<0?(1n<<BigInt(s*8))+BigInt(r):r).toString(16)}`;return s?Li(a,{size:s}):a}const dp=new TextEncoder;function pp(i,e={}){const t=dp.encode(i);return gh(t,e)}const fp=new TextEncoder;function gp(i,e={}){return typeof i=="number"||typeof i=="bigint"?mp(i,e):typeof i=="boolean"?yp(i,e):hs(i)?mh(i,e):wh(i,e)}function yp(i,e={}){const t=new Uint8Array(1);return t[0]=Number(i),typeof e.size=="number"?(Mi(t,{size:e.size}),Li(t,{size:e.size})):t}const Et={zero:48,nine:57,A:65,F:70,a:97,f:102};function Lo(i){if(i>=Et.zero&&i<=Et.nine)return i-Et.zero;if(i>=Et.A&&i<=Et.F)return i-(Et.A-10);if(i>=Et.a&&i<=Et.f)return i-(Et.a-10)}function mh(i,e={}){let t=i;e.size&&(Mi(t,{size:e.size}),t=Li(t,{dir:"right",size:e.size}));let s=t.slice(2);s.length%2&&(s=`0${s}`);const r=s.length/2,n=new Uint8Array(r);for(let o=0,a=0;o<r;o++){const c=Lo(s.charCodeAt(a++)),h=Lo(s.charCodeAt(a++));if(c===void 0||h===void 0)throw new ei(`Invalid byte sequence ("${s[a-2]}${s[a-1]}" in "${s}").`);n[o]=c*16+h}return n}function mp(i,e){const t=yh(i,e);return mh(t)}function wh(i,e={}){const t=fp.encode(i);return typeof e.size=="number"?(Mi(t,{size:e.size}),Li(t,{dir:"right",size:e.size})):t}function Ws(i){if(!Number.isSafeInteger(i)||i<0)throw new Error("positive integer expected, got "+i)}function wp(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function ar(i,...e){if(!wp(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function l_(i){if(typeof i!="function"||typeof i.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Ws(i.outputLen),Ws(i.blockLen)}function Mo(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function bp(i,e){ar(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const Ss=BigInt(2**32-1),Fo=BigInt(32);function vp(i,e=!1){return e?{h:Number(i&Ss),l:Number(i>>Fo&Ss)}:{h:Number(i>>Fo&Ss)|0,l:Number(i&Ss)|0}}function Ep(i,e=!1){let t=new Uint32Array(i.length),s=new Uint32Array(i.length);for(let r=0;r<i.length;r++){const{h:n,l:o}=vp(i[r],e);[t[r],s[r]]=[n,o]}return[t,s]}const Ip=(i,e,t)=>i<<t|e>>>32-t,$p=(i,e,t)=>e<<t|i>>>32-t,_p=(i,e,t)=>e<<t-32|i>>>64-t,Pp=(i,e,t)=>i<<t-32|e>>>64-t,li=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Sp(i){return new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4))}function u_(i){return new DataView(i.buffer,i.byteOffset,i.byteLength)}function d_(i,e){return i<<32-e|i>>>e}const zo=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function xp(i){return i<<24&4278190080|i<<8&16711680|i>>>8&65280|i>>>24&255}function Ho(i){for(let e=0;e<i.length;e++)i[e]=xp(i[e])}function Op(i){if(typeof i!="string")throw new Error("utf8ToBytes expected string, got "+typeof i);return new Uint8Array(new TextEncoder().encode(i))}function bh(i){return typeof i=="string"&&(i=Op(i)),ar(i),i}function p_(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];ar(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const n=i[s];t.set(n,r),r+=n.length}return t}class Ap{clone(){return this._cloneInto()}}function Cp(i){const e=s=>i().update(bh(s)).digest(),t=i();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>i(),e}function f_(i=32){if(li&&typeof li.getRandomValues=="function")return li.getRandomValues(new Uint8Array(i));if(li&&typeof li.randomBytes=="function")return li.randomBytes(i);throw new Error("crypto.getRandomValues must be defined")}const vh=[],Eh=[],Ih=[],Rp=BigInt(0),Wi=BigInt(1),Np=BigInt(2),Tp=BigInt(7),Bp=BigInt(256),Dp=BigInt(113);for(let i=0,e=Wi,t=1,s=0;i<24;i++){[t,s]=[s,(2*t+3*s)%5],vh.push(2*(5*s+t)),Eh.push((i+1)*(i+2)/2%64);let r=Rp;for(let n=0;n<7;n++)e=(e<<Wi^(e>>Tp)*Dp)%Bp,e&Np&&(r^=Wi<<(Wi<<BigInt(n))-Wi);Ih.push(r)}const[jp,kp]=Ep(Ih,!0),Ko=(i,e,t)=>t>32?_p(i,e,t):Ip(i,e,t),Vo=(i,e,t)=>t>32?Pp(i,e,t):$p(i,e,t);function qp(i,e=24){const t=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let o=0;o<10;o++)t[o]=i[o]^i[o+10]^i[o+20]^i[o+30]^i[o+40];for(let o=0;o<10;o+=2){const a=(o+8)%10,c=(o+2)%10,h=t[c],l=t[c+1],u=Ko(h,l,1)^t[a],d=Vo(h,l,1)^t[a+1];for(let f=0;f<50;f+=10)i[o+f]^=u,i[o+f+1]^=d}let r=i[2],n=i[3];for(let o=0;o<24;o++){const a=Eh[o],c=Ko(r,n,a),h=Vo(r,n,a),l=vh[o];r=i[l],n=i[l+1],i[l]=c,i[l+1]=h}for(let o=0;o<50;o+=10){for(let a=0;a<10;a++)t[a]=i[o+a];for(let a=0;a<10;a++)i[o+a]^=~t[(a+2)%10]&t[(a+4)%10]}i[0]^=jp[s],i[1]^=kp[s]}t.fill(0)}class Kn extends Ap{constructor(e,t,s,r=!1,n=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=s,this.enableXOF=r,this.rounds=n,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Ws(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Sp(this.state)}keccak(){zo||Ho(this.state32),qp(this.state32,this.rounds),zo||Ho(this.state32),this.posOut=0,this.pos=0}update(e){Mo(this);const{blockLen:t,state:s}=this;e=bh(e);const r=e.length;for(let n=0;n<r;){const o=Math.min(t-this.pos,r-n);for(let a=0;a<o;a++)s[this.pos++]^=e[n++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:s,blockLen:r}=this;e[s]^=t,t&128&&s===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){Mo(this,!1),ar(e),this.finish();const t=this.state,{blockLen:s}=this;for(let r=0,n=e.length;r<n;){this.posOut>=s&&this.keccak();const o=Math.min(s-this.posOut,n-r);e.set(t.subarray(this.posOut,this.posOut+o),r),this.posOut+=o,r+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Ws(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(bp(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:s,outputLen:r,rounds:n,enableXOF:o}=this;return e||(e=new Kn(t,s,r,o,n)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=n,e.suffix=s,e.outputLen=r,e.enableXOF=o,e.destroyed=this.destroyed,e}}const Up=(i,e,t)=>Cp(()=>new Kn(e,i,t)),Lp=Up(1,136,256/8);function $h(i,e){const t=e||"hex",s=Lp(hs(i,{strict:!1})?gp(i):i);return t==="bytes"?s:on(s)}class Mp extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const t=super.get(e);return super.has(e)&&t!==void 0&&(this.delete(e),super.set(e,t)),t}set(e,t){if(super.set(e,t),this.maxSize&&this.size>this.maxSize){const s=this.keys().next().value;s&&this.delete(s)}return this}}const Sr=new Mp(8192);function Fp(i,e){if(Sr.has(`${i}.${e}`))return Sr.get(`${i}.${e}`);const t=i.substring(2).toLowerCase(),s=$h(wh(t),"bytes"),r=t.split("");for(let o=0;o<40;o+=2)s[o>>1]>>4>=8&&r[o]&&(r[o]=r[o].toUpperCase()),(s[o>>1]&15)>=8&&r[o+1]&&(r[o+1]=r[o+1].toUpperCase());const n=`0x${r.join("")}`;return Sr.set(`${i}.${e}`,n),n}function zp(i){const e=$h(`0x${i.substring(4)}`).substring(26);return Fp(`0x${e}`)}async function Hp({hash:i,signature:e}){const t=hs(i)?i:on(i),{secp256k1:s}=await eh(async()=>{const{secp256k1:o}=await import("./secp256k1-BMv5ED--.js");return{secp256k1:o}},__vite__mapDeps([0,1,2]));return`0x${(()=>{if(typeof e=="object"&&"r"in e&&"s"in e){const{r:h,s:l,v:u,yParity:d}=e,f=Number(d??u),p=Wo(f);return new s.Signature(nn(h),nn(l)).addRecoveryBit(p)}const o=hs(e)?e:on(e),a=hp(`0x${o.slice(130)}`),c=Wo(a);return s.Signature.fromCompact(o.substring(2,130)).addRecoveryBit(c)})().recoverPublicKey(t.substring(2)).toHex(!1)}`}function Wo(i){if(i===0||i===1)return i;if(i===27)return 0;if(i===28)return 1;throw new Error("Invalid yParityOrV value")}async function Kp({hash:i,signature:e}){return zp(await Hp({hash:i,signature:e}))}function Vp(i){if(i.length>=255)throw new TypeError("Alphabet too long");const e=new Uint8Array(256);for(let h=0;h<e.length;h++)e[h]=255;for(let h=0;h<i.length;h++){const l=i.charAt(h),u=l.charCodeAt(0);if(e[u]!==255)throw new TypeError(l+" is ambiguous");e[u]=h}const t=i.length,s=i.charAt(0),r=Math.log(t)/Math.log(256),n=Math.log(256)/Math.log(t);function o(h){if(h instanceof Uint8Array||(ArrayBuffer.isView(h)?h=new Uint8Array(h.buffer,h.byteOffset,h.byteLength):Array.isArray(h)&&(h=Uint8Array.from(h))),!(h instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(h.length===0)return"";let l=0,u=0,d=0;const f=h.length;for(;d!==f&&h[d]===0;)d++,l++;const p=(f-d)*n+1>>>0,g=new Uint8Array(p);for(;d!==f;){let m=h[d],w=0;for(let $=p-1;(m!==0||w<u)&&$!==-1;$--,w++)m+=256*g[$]>>>0,g[$]=m%t>>>0,m=m/t>>>0;if(m!==0)throw new Error("Non-zero carry");u=w,d++}let y=p-u;for(;y!==p&&g[y]===0;)y++;let b=s.repeat(l);for(;y<p;++y)b+=i.charAt(g[y]);return b}function a(h){if(typeof h!="string")throw new TypeError("Expected String");if(h.length===0)return new Uint8Array;let l=0,u=0,d=0;for(;h[l]===s;)u++,l++;const f=(h.length-l)*r+1>>>0,p=new Uint8Array(f);for(;l<h.length;){const m=h.charCodeAt(l);if(m>255)return;let w=e[m];if(w===255)return;let $=0;for(let A=f-1;(w!==0||$<d)&&A!==-1;A--,$++)w+=t*p[A]>>>0,p[A]=w%256>>>0,w=w/256>>>0;if(w!==0)throw new Error("Non-zero carry");d=$,l++}let g=f-d;for(;g!==f&&p[g]===0;)g++;const y=new Uint8Array(u+(f-g));let b=u;for(;g!==f;)y[b++]=p[g++];return y}function c(h){const l=a(h);if(l)return l;throw new Error("Non-base"+t+" character")}return{encode:o,decodeUnsafe:a,decode:c}}var Wp="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";const Gp=Vp(Wp);function Jp(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function _h(i,...e){if(!Jp(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function Go(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function Yp(i,e){_h(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const ui=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xr=i=>new DataView(i.buffer,i.byteOffset,i.byteLength);function Zp(i){if(typeof i!="string")throw new Error("utf8ToBytes expected string, got "+typeof i);return new Uint8Array(new TextEncoder().encode(i))}function Ph(i){return typeof i=="string"&&(i=Zp(i)),_h(i),i}let Qp=class{clone(){return this._cloneInto()}};function Xp(i){const e=s=>i().update(Ph(s)).digest(),t=i();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>i(),e}function Sh(i=32){if(ui&&typeof ui.getRandomValues=="function")return ui.getRandomValues(new Uint8Array(i));if(ui&&typeof ui.randomBytes=="function")return ui.randomBytes(i);throw new Error("crypto.getRandomValues must be defined")}function ef(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(t>>r&n),a=Number(t&n),c=s?4:0,h=s?0:4;i.setUint32(e+c,o,s),i.setUint32(e+h,a,s)}let tf=class extends Qp{constructor(e,t,s,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=xr(this.buffer)}update(e){Go(this);const{view:t,buffer:s,blockLen:r}=this;e=Ph(e);const n=e.length;for(let o=0;o<n;){const a=Math.min(r-this.pos,n-o);if(a===r){const c=xr(e);for(;r<=n-o;o+=r)this.process(c,o);continue}s.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Go(this),Yp(e,this),this.finished=!0;const{buffer:t,view:s,blockLen:r,isLE:n}=this;let{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>r-o&&(this.process(s,0),o=0);for(let u=o;u<r;u++)t[u]=0;ef(s,r-8,BigInt(this.length*8),n),this.process(s,0);const a=xr(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=c/4,l=this.get();if(h>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<h;u++)a.setUint32(4*u,l[u],n)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:s,length:r,finished:n,destroyed:o,pos:a}=this;return e.length=r,e.pos=a,e.finished=n,e.destroyed=o,r%t&&e.buffer.set(s),e}};const xs=BigInt(2**32-1),an=BigInt(32);function xh(i,e=!1){return e?{h:Number(i&xs),l:Number(i>>an&xs)}:{h:Number(i>>an&xs)|0,l:Number(i&xs)|0}}function sf(i,e=!1){let t=new Uint32Array(i.length),s=new Uint32Array(i.length);for(let r=0;r<i.length;r++){const{h:n,l:o}=xh(i[r],e);[t[r],s[r]]=[n,o]}return[t,s]}const rf=(i,e)=>BigInt(i>>>0)<<an|BigInt(e>>>0),nf=(i,e,t)=>i>>>t,of=(i,e,t)=>i<<32-t|e>>>t,af=(i,e,t)=>i>>>t|e<<32-t,cf=(i,e,t)=>i<<32-t|e>>>t,hf=(i,e,t)=>i<<64-t|e>>>t-32,lf=(i,e,t)=>i>>>t-32|e<<64-t,uf=(i,e)=>e,df=(i,e)=>i,pf=(i,e,t)=>i<<t|e>>>32-t,ff=(i,e,t)=>e<<t|i>>>32-t,gf=(i,e,t)=>e<<t-32|i>>>64-t,yf=(i,e,t)=>i<<t-32|e>>>64-t;function mf(i,e,t,s){const r=(e>>>0)+(s>>>0);return{h:i+t+(r/2**32|0)|0,l:r|0}}const wf=(i,e,t)=>(i>>>0)+(e>>>0)+(t>>>0),bf=(i,e,t,s)=>e+t+s+(i/2**32|0)|0,vf=(i,e,t,s)=>(i>>>0)+(e>>>0)+(t>>>0)+(s>>>0),Ef=(i,e,t,s,r)=>e+t+s+r+(i/2**32|0)|0,If=(i,e,t,s,r)=>(i>>>0)+(e>>>0)+(t>>>0)+(s>>>0)+(r>>>0),$f=(i,e,t,s,r,n)=>e+t+s+r+n+(i/2**32|0)|0,H={fromBig:xh,split:sf,toBig:rf,shrSH:nf,shrSL:of,rotrSH:af,rotrSL:cf,rotrBH:hf,rotrBL:lf,rotr32H:uf,rotr32L:df,rotlSH:pf,rotlSL:ff,rotlBH:gf,rotlBL:yf,add:mf,add3L:wf,add3H:bf,add4L:vf,add4H:Ef,add5H:$f,add5L:If},[_f,Pf]=H.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(i=>BigInt(i))),Ct=new Uint32Array(80),Rt=new Uint32Array(80);let Sf=class extends tf{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:s,Bl:r,Ch:n,Cl:o,Dh:a,Dl:c,Eh:h,El:l,Fh:u,Fl:d,Gh:f,Gl:p,Hh:g,Hl:y}=this;return[e,t,s,r,n,o,a,c,h,l,u,d,f,p,g,y]}set(e,t,s,r,n,o,a,c,h,l,u,d,f,p,g,y){this.Ah=e|0,this.Al=t|0,this.Bh=s|0,this.Bl=r|0,this.Ch=n|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=h|0,this.El=l|0,this.Fh=u|0,this.Fl=d|0,this.Gh=f|0,this.Gl=p|0,this.Hh=g|0,this.Hl=y|0}process(e,t){for(let w=0;w<16;w++,t+=4)Ct[w]=e.getUint32(t),Rt[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const $=Ct[w-15]|0,A=Rt[w-15]|0,S=H.rotrSH($,A,1)^H.rotrSH($,A,8)^H.shrSH($,A,7),x=H.rotrSL($,A,1)^H.rotrSL($,A,8)^H.shrSL($,A,7),N=Ct[w-2]|0,_=Rt[w-2]|0,L=H.rotrSH(N,_,19)^H.rotrBH(N,_,61)^H.shrSH(N,_,6),j=H.rotrSL(N,_,19)^H.rotrBL(N,_,61)^H.shrSL(N,_,6),q=H.add4L(x,j,Rt[w-7],Rt[w-16]),M=H.add4H(q,S,L,Ct[w-7],Ct[w-16]);Ct[w]=M|0,Rt[w]=q|0}let{Ah:s,Al:r,Bh:n,Bl:o,Ch:a,Cl:c,Dh:h,Dl:l,Eh:u,El:d,Fh:f,Fl:p,Gh:g,Gl:y,Hh:b,Hl:m}=this;for(let w=0;w<80;w++){const $=H.rotrSH(u,d,14)^H.rotrSH(u,d,18)^H.rotrBH(u,d,41),A=H.rotrSL(u,d,14)^H.rotrSL(u,d,18)^H.rotrBL(u,d,41),S=u&f^~u&g,x=d&p^~d&y,N=H.add5L(m,A,x,Pf[w],Rt[w]),_=H.add5H(N,b,$,S,_f[w],Ct[w]),L=N|0,j=H.rotrSH(s,r,28)^H.rotrBH(s,r,34)^H.rotrBH(s,r,39),q=H.rotrSL(s,r,28)^H.rotrBL(s,r,34)^H.rotrBL(s,r,39),M=s&n^s&a^n&a,C=r&o^r&c^o&c;b=g|0,m=y|0,g=f|0,y=p|0,f=u|0,p=d|0,{h:u,l:d}=H.add(h|0,l|0,_|0,L|0),h=a|0,l=c|0,a=n|0,c=o|0,n=s|0,o=r|0;const E=H.add3L(L,q,C);s=H.add3H(E,_,j,M),r=E|0}({h:s,l:r}=H.add(this.Ah|0,this.Al|0,s|0,r|0)),{h:n,l:o}=H.add(this.Bh|0,this.Bl|0,n|0,o|0),{h:a,l:c}=H.add(this.Ch|0,this.Cl|0,a|0,c|0),{h,l}=H.add(this.Dh|0,this.Dl|0,h|0,l|0),{h:u,l:d}=H.add(this.Eh|0,this.El|0,u|0,d|0),{h:f,l:p}=H.add(this.Fh|0,this.Fl|0,f|0,p|0),{h:g,l:y}=H.add(this.Gh|0,this.Gl|0,g|0,y|0),{h:b,l:m}=H.add(this.Hh|0,this.Hl|0,b|0,m|0),this.set(s,r,n,o,a,c,h,l,u,d,f,p,g,y,b,m)}roundClean(){Ct.fill(0),Rt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}};const xf=Xp(()=>new Sf);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vn=BigInt(0),Oh=BigInt(1),Of=BigInt(2);function Wn(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function Gn(i){if(!Wn(i))throw new Error("Uint8Array expected")}function Or(i,e){if(typeof e!="boolean")throw new Error(i+" boolean expected, got "+e)}const Af=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function Jn(i){Gn(i);let e="";for(let t=0;t<i.length;t++)e+=Af[i[t]];return e}function Ah(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);return i===""?Vn:BigInt("0x"+i)}const It={_0:48,_9:57,A:65,F:70,a:97,f:102};function Jo(i){if(i>=It._0&&i<=It._9)return i-It._0;if(i>=It.A&&i<=It.F)return i-(It.A-10);if(i>=It.a&&i<=It.f)return i-(It.a-10)}function Ch(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);const e=i.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(t);for(let r=0,n=0;r<t;r++,n+=2){const o=Jo(i.charCodeAt(n)),a=Jo(i.charCodeAt(n+1));if(o===void 0||a===void 0){const c=i[n]+i[n+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+n)}s[r]=o*16+a}return s}function Cf(i){return Ah(Jn(i))}function Fs(i){return Gn(i),Ah(Jn(Uint8Array.from(i).reverse()))}function Rh(i,e){return Ch(i.toString(16).padStart(e*2,"0"))}function cn(i,e){return Rh(i,e).reverse()}function $t(i,e,t){let s;if(typeof e=="string")try{s=Ch(e)}catch(n){throw new Error(i+" must be hex string or Uint8Array, cause: "+n)}else if(Wn(e))s=Uint8Array.from(e);else throw new Error(i+" must be hex string or Uint8Array");const r=s.length;if(typeof t=="number"&&r!==t)throw new Error(i+" of length "+t+" expected, got "+r);return s}function Yo(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];Gn(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const n=i[s];t.set(n,r),r+=n.length}return t}const Ar=i=>typeof i=="bigint"&&Vn<=i;function Rf(i,e,t){return Ar(i)&&Ar(e)&&Ar(t)&&e<=i&&i<t}function Gi(i,e,t,s){if(!Rf(e,t,s))throw new Error("expected valid "+i+": "+t+" <= n < "+s+", got "+e)}function Nf(i){let e;for(e=0;i>Vn;i>>=Oh,e+=1);return e}const Tf=i=>(Of<<BigInt(i-1))-Oh,Bf={bigint:i=>typeof i=="bigint",function:i=>typeof i=="function",boolean:i=>typeof i=="boolean",string:i=>typeof i=="string",stringOrUint8Array:i=>typeof i=="string"||Wn(i),isSafeInteger:i=>Number.isSafeInteger(i),array:i=>Array.isArray(i),field:(i,e)=>e.Fp.isValid(i),hash:i=>typeof i=="function"&&Number.isSafeInteger(i.outputLen)};function Yn(i,e,t={}){const s=(r,n,o)=>{const a=Bf[n];if(typeof a!="function")throw new Error("invalid validator function");const c=i[r];if(!(o&&c===void 0)&&!a(c,i))throw new Error("param "+String(r)+" is invalid. Expected "+n+", got "+c)};for(const[r,n]of Object.entries(e))s(r,n,!1);for(const[r,n]of Object.entries(t))s(r,n,!0);return i}function Zo(i){const e=new WeakMap;return(t,...s)=>{const r=e.get(t);if(r!==void 0)return r;const n=i(t,...s);return e.set(t,n),n}}const we=BigInt(0),ae=BigInt(1),Kt=BigInt(2),Df=BigInt(3),hn=BigInt(4),Qo=BigInt(5),Xo=BigInt(8);function de(i,e){const t=i%e;return t>=we?t:e+t}function jf(i,e,t){if(e<we)throw new Error("invalid exponent, negatives unsupported");if(t<=we)throw new Error("invalid modulus");if(t===ae)return we;let s=ae;for(;e>we;)e&ae&&(s=s*i%t),i=i*i%t,e>>=ae;return s}function lt(i,e,t){let s=i;for(;e-- >we;)s*=s,s%=t;return s}function ea(i,e){if(i===we)throw new Error("invert: expected non-zero number");if(e<=we)throw new Error("invert: expected positive modulus, got "+e);let t=de(i,e),s=e,r=we,n=ae;for(;t!==we;){const o=s/t,a=s%t,c=r-n*o;s=t,t=a,r=n,n=c}if(s!==ae)throw new Error("invert: does not exist");return de(r,e)}function kf(i){const e=(i-ae)/Kt;let t,s,r;for(t=i-ae,s=0;t%Kt===we;t/=Kt,s++);for(r=Kt;r<i&&jf(r,e,i)!==i-ae;r++)if(r>1e3)throw new Error("Cannot find square root: likely non-prime P");if(s===1){const o=(i+ae)/hn;return function(a,c){const h=a.pow(c,o);if(!a.eql(a.sqr(h),c))throw new Error("Cannot find square root");return h}}const n=(t+ae)/Kt;return function(o,a){if(o.pow(a,e)===o.neg(o.ONE))throw new Error("Cannot find square root");let c=s,h=o.pow(o.mul(o.ONE,r),t),l=o.pow(a,n),u=o.pow(a,t);for(;!o.eql(u,o.ONE);){if(o.eql(u,o.ZERO))return o.ZERO;let d=1;for(let p=o.sqr(u);d<c&&!o.eql(p,o.ONE);d++)p=o.sqr(p);const f=o.pow(h,ae<<BigInt(c-d-1));h=o.sqr(f),l=o.mul(l,f),u=o.mul(u,h),c=d}return l}}function qf(i){if(i%hn===Df){const e=(i+ae)/hn;return function(t,s){const r=t.pow(s,e);if(!t.eql(t.sqr(r),s))throw new Error("Cannot find square root");return r}}if(i%Xo===Qo){const e=(i-Qo)/Xo;return function(t,s){const r=t.mul(s,Kt),n=t.pow(r,e),o=t.mul(s,n),a=t.mul(t.mul(o,Kt),n),c=t.mul(o,t.sub(a,t.ONE));if(!t.eql(t.sqr(c),s))throw new Error("Cannot find square root");return c}}return kf(i)}const Uf=(i,e)=>(de(i,e)&ae)===ae,Lf=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Mf(i){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Lf.reduce((s,r)=>(s[r]="function",s),e);return Yn(i,t)}function Ff(i,e,t){if(t<we)throw new Error("invalid exponent, negatives unsupported");if(t===we)return i.ONE;if(t===ae)return e;let s=i.ONE,r=e;for(;t>we;)t&ae&&(s=i.mul(s,r)),r=i.sqr(r),t>>=ae;return s}function zf(i,e){const t=new Array(e.length),s=e.reduce((n,o,a)=>i.is0(o)?n:(t[a]=n,i.mul(n,o)),i.ONE),r=i.inv(s);return e.reduceRight((n,o,a)=>i.is0(o)?n:(t[a]=i.mul(n,t[a]),i.mul(n,o)),r),t}function Nh(i,e){const t=e!==void 0?e:i.toString(2).length,s=Math.ceil(t/8);return{nBitLength:t,nByteLength:s}}function Th(i,e,t=!1,s={}){if(i<=we)throw new Error("invalid field: expected ORDER > 0, got "+i);const{nBitLength:r,nByteLength:n}=Nh(i,e);if(n>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:i,isLE:t,BITS:r,BYTES:n,MASK:Tf(r),ZERO:we,ONE:ae,create:c=>de(c,i),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return we<=c&&c<i},is0:c=>c===we,isOdd:c=>(c&ae)===ae,neg:c=>de(-c,i),eql:(c,h)=>c===h,sqr:c=>de(c*c,i),add:(c,h)=>de(c+h,i),sub:(c,h)=>de(c-h,i),mul:(c,h)=>de(c*h,i),pow:(c,h)=>Ff(a,c,h),div:(c,h)=>de(c*ea(h,i),i),sqrN:c=>c*c,addN:(c,h)=>c+h,subN:(c,h)=>c-h,mulN:(c,h)=>c*h,inv:c=>ea(c,i),sqrt:s.sqrt||(c=>(o||(o=qf(i)),o(a,c))),invertBatch:c=>zf(a,c),cmov:(c,h,l)=>l?h:c,toBytes:c=>t?cn(c,n):Rh(c,n),fromBytes:c=>{if(c.length!==n)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+c.length);return t?Fs(c):Cf(c)}});return Object.freeze(a)}const ta=BigInt(0),Os=BigInt(1);function Cr(i,e){const t=e.negate();return i?t:e}function Bh(i,e){if(!Number.isSafeInteger(i)||i<=0||i>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+i)}function Rr(i,e){Bh(i,e);const t=Math.ceil(e/i)+1,s=2**(i-1);return{windows:t,windowSize:s}}function Hf(i,e){if(!Array.isArray(i))throw new Error("array expected");i.forEach((t,s)=>{if(!(t instanceof e))throw new Error("invalid point at index "+s)})}function Kf(i,e){if(!Array.isArray(i))throw new Error("array of scalars expected");i.forEach((t,s)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+s)})}const Nr=new WeakMap,Dh=new WeakMap;function Tr(i){return Dh.get(i)||1}function Vf(i,e){return{constTimeNegate:Cr,hasPrecomputes(t){return Tr(t)!==1},unsafeLadder(t,s,r=i.ZERO){let n=t;for(;s>ta;)s&Os&&(r=r.add(n)),n=n.double(),s>>=Os;return r},precomputeWindow(t,s){const{windows:r,windowSize:n}=Rr(s,e),o=[];let a=t,c=a;for(let h=0;h<r;h++){c=a,o.push(c);for(let l=1;l<n;l++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,s,r){const{windows:n,windowSize:o}=Rr(t,e);let a=i.ZERO,c=i.BASE;const h=BigInt(2**t-1),l=2**t,u=BigInt(t);for(let d=0;d<n;d++){const f=d*o;let p=Number(r&h);r>>=u,p>o&&(p-=l,r+=Os);const g=f,y=f+Math.abs(p)-1,b=d%2!==0,m=p<0;p===0?c=c.add(Cr(b,s[g])):a=a.add(Cr(m,s[y]))}return{p:a,f:c}},wNAFUnsafe(t,s,r,n=i.ZERO){const{windows:o,windowSize:a}=Rr(t,e),c=BigInt(2**t-1),h=2**t,l=BigInt(t);for(let u=0;u<o;u++){const d=u*a;if(r===ta)break;let f=Number(r&c);if(r>>=l,f>a&&(f-=h,r+=Os),f===0)continue;let p=s[d+Math.abs(f)-1];f<0&&(p=p.negate()),n=n.add(p)}return n},getPrecomputes(t,s,r){let n=Nr.get(s);return n||(n=this.precomputeWindow(s,t),t!==1&&Nr.set(s,r(n))),n},wNAFCached(t,s,r){const n=Tr(t);return this.wNAF(n,this.getPrecomputes(n,t,r),s)},wNAFCachedUnsafe(t,s,r,n){const o=Tr(t);return o===1?this.unsafeLadder(t,s,n):this.wNAFUnsafe(o,this.getPrecomputes(o,t,r),s,n)},setWindowSize(t,s){Bh(s,e),Dh.set(t,s),Nr.delete(t)}}}function Wf(i,e,t,s){if(Hf(t,i),Kf(s,e),t.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const r=i.ZERO,n=Nf(BigInt(t.length)),o=n>12?n-3:n>4?n-2:n?2:1,a=(1<<o)-1,c=new Array(a+1).fill(r),h=Math.floor((e.BITS-1)/o)*o;let l=r;for(let u=h;u>=0;u-=o){c.fill(r);for(let f=0;f<s.length;f++){const p=s[f],g=Number(p>>BigInt(u)&BigInt(a));c[g]=c[g].add(t[f])}let d=r;for(let f=c.length-1,p=r;f>0;f--)p=p.add(c[f]),d=d.add(p);if(l=l.add(d),u!==0)for(let f=0;f<o;f++)l=l.double()}return l}function Gf(i){return Mf(i.Fp),Yn(i,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Nh(i.n,i.nBitLength),...i,p:i.Fp.ORDER})}const it=BigInt(0),Te=BigInt(1),As=BigInt(2),Jf=BigInt(8),Yf={zip215:!0};function Zf(i){const e=Gf(i);return Yn(i,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Qf(i){const e=Zf(i),{Fp:t,n:s,prehash:r,hash:n,randomBytes:o,nByteLength:a,h:c}=e,h=As<<BigInt(a*8)-Te,l=t.create,u=Th(e.n,e.nBitLength),d=e.uvRatio||((E,v)=>{try{return{isValid:!0,value:t.sqrt(E*t.inv(v))}}catch{return{isValid:!1,value:it}}}),f=e.adjustScalarBytes||(E=>E),p=e.domain||((E,v,P)=>{if(Or("phflag",P),v.length||P)throw new Error("Contexts/pre-hash are not supported");return E});function g(E,v){Gi("coordinate "+E,v,it,h)}function y(E){if(!(E instanceof w))throw new Error("ExtendedPoint expected")}const b=Zo((E,v)=>{const{ex:P,ey:O,ez:I}=E,B=E.is0();v==null&&(v=B?Jf:t.inv(I));const k=l(P*v),U=l(O*v),F=l(I*v);if(B)return{x:it,y:Te};if(F!==Te)throw new Error("invZ was invalid");return{x:k,y:U}}),m=Zo(E=>{const{a:v,d:P}=e;if(E.is0())throw new Error("bad point: ZERO");const{ex:O,ey:I,ez:B,et:k}=E,U=l(O*O),F=l(I*I),z=l(B*B),K=l(z*z),G=l(U*v),re=l(z*l(G+F)),ee=l(K+l(P*l(U*F)));if(re!==ee)throw new Error("bad point: equation left != right (1)");const J=l(O*I),xe=l(B*k);if(J!==xe)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(v,P,O,I){this.ex=v,this.ey=P,this.ez=O,this.et=I,g("x",v),g("y",P),g("z",O),g("t",I),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(v){if(v instanceof w)throw new Error("extended point not allowed");const{x:P,y:O}=v||{};return g("x",P),g("y",O),new w(P,O,Te,l(P*O))}static normalizeZ(v){const P=t.invertBatch(v.map(O=>O.ez));return v.map((O,I)=>O.toAffine(P[I])).map(w.fromAffine)}static msm(v,P){return Wf(w,u,v,P)}_setWindowSize(v){S.setWindowSize(this,v)}assertValidity(){m(this)}equals(v){y(v);const{ex:P,ey:O,ez:I}=this,{ex:B,ey:k,ez:U}=v,F=l(P*U),z=l(B*I),K=l(O*U),G=l(k*I);return F===z&&K===G}is0(){return this.equals(w.ZERO)}negate(){return new w(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:v}=e,{ex:P,ey:O,ez:I}=this,B=l(P*P),k=l(O*O),U=l(As*l(I*I)),F=l(v*B),z=P+O,K=l(l(z*z)-B-k),G=F+k,re=G-U,ee=F-k,J=l(K*re),xe=l(G*ee),ve=l(K*ee),Ae=l(re*G);return new w(J,xe,Ae,ve)}add(v){y(v);const{a:P,d:O}=e,{ex:I,ey:B,ez:k,et:U}=this,{ex:F,ey:z,ez:K,et:G}=v;if(P===BigInt(-1)){const lo=l((B-I)*(z+F)),uo=l((B+I)*(z-F)),vr=l(uo-lo);if(vr===it)return this.double();const po=l(k*As*G),fo=l(U*As*K),go=fo+po,yo=uo+lo,mo=fo-po,Iu=l(go*vr),$u=l(yo*mo),_u=l(go*mo),Pu=l(vr*yo);return new w(Iu,$u,Pu,_u)}const re=l(I*F),ee=l(B*z),J=l(U*O*G),xe=l(k*K),ve=l((I+B)*(F+z)-re-ee),Ae=xe-J,We=xe+J,vt=l(ee-P*re),hi=l(ve*Ae),bu=l(We*vt),vu=l(ve*vt),Eu=l(Ae*We);return new w(hi,bu,Eu,vu)}subtract(v){return this.add(v.negate())}wNAF(v){return S.wNAFCached(this,v,w.normalizeZ)}multiply(v){const P=v;Gi("scalar",P,Te,s);const{p:O,f:I}=this.wNAF(P);return w.normalizeZ([O,I])[0]}multiplyUnsafe(v,P=w.ZERO){const O=v;return Gi("scalar",O,it,s),O===it?A:this.is0()||O===Te?this:S.wNAFCachedUnsafe(this,O,w.normalizeZ,P)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return S.unsafeLadder(this,s).is0()}toAffine(v){return b(this,v)}clearCofactor(){const{h:v}=e;return v===Te?this:this.multiplyUnsafe(v)}static fromHex(v,P=!1){const{d:O,a:I}=e,B=t.BYTES;v=$t("pointHex",v,B),Or("zip215",P);const k=v.slice(),U=v[B-1];k[B-1]=U&-129;const F=Fs(k),z=P?h:t.ORDER;Gi("pointHex.y",F,it,z);const K=l(F*F),G=l(K-Te),re=l(O*K-I);let{isValid:ee,value:J}=d(G,re);if(!ee)throw new Error("Point.fromHex: invalid y coordinate");const xe=(J&Te)===Te,ve=(U&128)!==0;if(!P&&J===it&&ve)throw new Error("Point.fromHex: x=0 and x_0=1");return ve!==xe&&(J=l(-J)),w.fromAffine({x:J,y:F})}static fromPrivateKey(v){return _(v).point}toRawBytes(){const{x:v,y:P}=this.toAffine(),O=cn(P,t.BYTES);return O[O.length-1]|=v&Te?128:0,O}toHex(){return Jn(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,Te,l(e.Gx*e.Gy)),w.ZERO=new w(it,Te,Te,it);const{BASE:$,ZERO:A}=w,S=Vf(w,a*8);function x(E){return de(E,s)}function N(E){return x(Fs(E))}function _(E){const v=t.BYTES;E=$t("private key",E,v);const P=$t("hashed private key",n(E),2*v),O=f(P.slice(0,v)),I=P.slice(v,2*v),B=N(O),k=$.multiply(B),U=k.toRawBytes();return{head:O,prefix:I,scalar:B,point:k,pointBytes:U}}function L(E){return _(E).pointBytes}function j(E=new Uint8Array,...v){const P=Yo(...v);return N(n(p(P,$t("context",E),!!r)))}function q(E,v,P={}){E=$t("message",E),r&&(E=r(E));const{prefix:O,scalar:I,pointBytes:B}=_(v),k=j(P.context,O,E),U=$.multiply(k).toRawBytes(),F=j(P.context,U,B,E),z=x(k+F*I);Gi("signature.s",z,it,s);const K=Yo(U,cn(z,t.BYTES));return $t("result",K,t.BYTES*2)}const M=Yf;function C(E,v,P,O=M){const{context:I,zip215:B}=O,k=t.BYTES;E=$t("signature",E,2*k),v=$t("message",v),P=$t("publicKey",P,k),B!==void 0&&Or("zip215",B),r&&(v=r(v));const U=Fs(E.slice(k,2*k));let F,z,K;try{F=w.fromHex(P,B),z=w.fromHex(E.slice(0,k),B),K=$.multiplyUnsafe(U)}catch{return!1}if(!B&&F.isSmallOrder())return!1;const G=j(I,z.toRawBytes(),F.toRawBytes(),v);return z.add(F.multiplyUnsafe(G)).subtract(K).clearCofactor().equals(w.ZERO)}return $._setWindowSize(8),{CURVE:e,getPublicKey:L,sign:q,verify:C,ExtendedPoint:w,utils:{getExtendedPublicKey:_,randomPrivateKey:()=>o(t.BYTES),precompute(E=8,v=w.BASE){return v._setWindowSize(E),v.multiply(BigInt(3)),v}}}}BigInt(0),BigInt(1);const Zn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),ia=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Xf=BigInt(1),sa=BigInt(2);BigInt(3);const eg=BigInt(5),tg=BigInt(8);function ig(i){const e=BigInt(10),t=BigInt(20),s=BigInt(40),r=BigInt(80),n=Zn,o=i*i%n*i%n,a=lt(o,sa,n)*o%n,c=lt(a,Xf,n)*i%n,h=lt(c,eg,n)*c%n,l=lt(h,e,n)*h%n,u=lt(l,t,n)*l%n,d=lt(u,s,n)*u%n,f=lt(d,r,n)*d%n,p=lt(f,r,n)*d%n,g=lt(p,e,n)*h%n;return{pow_p_5_8:lt(g,sa,n)*i%n,b2:o}}function sg(i){return i[0]&=248,i[31]&=127,i[31]|=64,i}function rg(i,e){const t=Zn,s=de(e*e*e,t),r=de(s*s*e,t),n=ig(i*r).pow_p_5_8;let o=de(i*s*n,t);const a=de(e*o*o,t),c=o,h=de(o*ia,t),l=a===i,u=a===de(-i,t),d=a===de(-i*ia,t);return l&&(o=c),(u||d)&&(o=h),Uf(o,t)&&(o=de(-o,t)),{isValid:l||u,value:o}}const ng=Th(Zn,void 0,!0),og={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:ng,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:tg,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:xf,randomBytes:Sh,adjustScalarBytes:sg,uvRatio:rg},jh=Qf(og),ag="EdDSA",cg="JWT",Gs=".",cr="base64url",kh="utf8",qh="utf8",hg=":",lg="did",ug="key",ra="base58btc",dg="z",pg="K36",fg=32;function Qn(i){return globalThis.Buffer!=null?new Uint8Array(i.buffer,i.byteOffset,i.byteLength):i}function Uh(i=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?Qn(globalThis.Buffer.allocUnsafe(i)):new Uint8Array(i)}function Lh(i,e){e||(e=i.reduce((r,n)=>r+n.length,0));const t=Uh(e);let s=0;for(const r of i)t.set(r,s),s+=r.length;return Qn(t)}function gg(i,e){if(i.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),s=0;s<t.length;s++)t[s]=255;for(var r=0;r<i.length;r++){var n=i.charAt(r),o=n.charCodeAt(0);if(t[o]!==255)throw new TypeError(n+" is ambiguous");t[o]=r}var a=i.length,c=i.charAt(0),h=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function u(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var g=0,y=0,b=0,m=p.length;b!==m&&p[b]===0;)b++,g++;for(var w=(m-b)*l+1>>>0,$=new Uint8Array(w);b!==m;){for(var A=p[b],S=0,x=w-1;(A!==0||S<y)&&x!==-1;x--,S++)A+=256*$[x]>>>0,$[x]=A%a>>>0,A=A/a>>>0;if(A!==0)throw new Error("Non-zero carry");y=S,b++}for(var N=w-y;N!==w&&$[N]===0;)N++;for(var _=c.repeat(g);N<w;++N)_+=i.charAt($[N]);return _}function d(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var g=0;if(p[g]!==" "){for(var y=0,b=0;p[g]===c;)y++,g++;for(var m=(p.length-g)*h+1>>>0,w=new Uint8Array(m);p[g];){var $=t[p.charCodeAt(g)];if($===255)return;for(var A=0,S=m-1;($!==0||A<b)&&S!==-1;S--,A++)$+=a*w[S]>>>0,w[S]=$%256>>>0,$=$/256>>>0;if($!==0)throw new Error("Non-zero carry");b=A,g++}if(p[g]!==" "){for(var x=m-b;x!==m&&w[x]===0;)x++;for(var N=new Uint8Array(y+(m-x)),_=y;x!==m;)N[_++]=w[x++];return N}}}function f(p){var g=d(p);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:u,decodeUnsafe:d,decode:f}}var yg=gg,mg=yg;const Mh=i=>{if(i instanceof Uint8Array&&i.constructor.name==="Uint8Array")return i;if(i instanceof ArrayBuffer)return new Uint8Array(i);if(ArrayBuffer.isView(i))return new Uint8Array(i.buffer,i.byteOffset,i.byteLength);throw new Error("Unknown type, must be binary type")},wg=i=>new TextEncoder().encode(i),bg=i=>new TextDecoder().decode(i);let vg=class{constructor(e,t,s){this.name=e,this.prefix=t,this.baseEncode=s}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},Eg=class{constructor(e,t,s){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=s}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Fh(this,e)}},Ig=class{constructor(e){this.decoders=e}or(e){return Fh(this,e)}decode(e){const t=e[0],s=this.decoders[t];if(s)return s.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const Fh=(i,e)=>new Ig({...i.decoders||{[i.prefix]:i},...e.decoders||{[e.prefix]:e}});let $g=class{constructor(e,t,s,r){this.name=e,this.prefix=t,this.baseEncode=s,this.baseDecode=r,this.encoder=new vg(e,t,s),this.decoder=new Eg(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const hr=({name:i,prefix:e,encode:t,decode:s})=>new $g(i,e,t,s),ys=({prefix:i,name:e,alphabet:t})=>{const{encode:s,decode:r}=mg(t,e);return hr({prefix:i,name:e,encode:s,decode:n=>Mh(r(n))})},_g=(i,e,t,s)=>{const r={};for(let l=0;l<e.length;++l)r[e[l]]=l;let n=i.length;for(;i[n-1]==="=";)--n;const o=new Uint8Array(n*t/8|0);let a=0,c=0,h=0;for(let l=0;l<n;++l){const u=r[i[l]];if(u===void 0)throw new SyntaxError(`Non-${s} character`);c=c<<t|u,a+=t,a>=8&&(a-=8,o[h++]=255&c>>a)}if(a>=t||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o},Pg=(i,e,t)=>{const s=e[e.length-1]==="=",r=(1<<t)-1;let n="",o=0,a=0;for(let c=0;c<i.length;++c)for(a=a<<8|i[c],o+=8;o>t;)o-=t,n+=e[r&a>>o];if(o&&(n+=e[r&a<<t-o]),s)for(;n.length*t&7;)n+="=";return n},Pe=({name:i,prefix:e,bitsPerChar:t,alphabet:s})=>hr({prefix:e,name:i,encode(r){return Pg(r,s,t)},decode(r){return _g(r,s,t,i)}}),Sg=hr({prefix:"\0",name:"identity",encode:i=>bg(i),decode:i=>wg(i)});var xg=Object.freeze({__proto__:null,identity:Sg});const Og=Pe({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Ag=Object.freeze({__proto__:null,base2:Og});const Cg=Pe({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Rg=Object.freeze({__proto__:null,base8:Cg});const Ng=ys({prefix:"9",name:"base10",alphabet:"0123456789"});var Tg=Object.freeze({__proto__:null,base10:Ng});const Bg=Pe({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Dg=Pe({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var jg=Object.freeze({__proto__:null,base16:Bg,base16upper:Dg});const kg=Pe({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),qg=Pe({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ug=Pe({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Lg=Pe({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Mg=Pe({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Fg=Pe({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),zg=Pe({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Hg=Pe({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Kg=Pe({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Vg=Object.freeze({__proto__:null,base32:kg,base32upper:qg,base32pad:Ug,base32padupper:Lg,base32hex:Mg,base32hexupper:Fg,base32hexpad:zg,base32hexpadupper:Hg,base32z:Kg});const Wg=ys({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Gg=ys({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Jg=Object.freeze({__proto__:null,base36:Wg,base36upper:Gg});const Yg=ys({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Zg=ys({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Qg=Object.freeze({__proto__:null,base58btc:Yg,base58flickr:Zg});const Xg=Pe({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ey=Pe({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ty=Pe({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),iy=Pe({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var sy=Object.freeze({__proto__:null,base64:Xg,base64pad:ey,base64url:ty,base64urlpad:iy});const zh=Array.from(""),ry=zh.reduce((i,e,t)=>(i[t]=e,i),[]),ny=zh.reduce((i,e,t)=>(i[e.codePointAt(0)]=t,i),[]);function oy(i){return i.reduce((e,t)=>(e+=ry[t],e),"")}function ay(i){const e=[];for(const t of i){const s=ny[t.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const cy=hr({prefix:"",name:"base256emoji",encode:oy,decode:ay});var hy=Object.freeze({__proto__:null,base256emoji:cy}),ly=Hh,na=128,uy=-128,dy=Math.pow(2,31);function Hh(i,e,t){e=e||[],t=t||0;for(var s=t;i>=dy;)e[t++]=i&255|na,i/=128;for(;i&uy;)e[t++]=i&255|na,i>>>=7;return e[t]=i|0,Hh.bytes=t-s+1,e}var py=ln,fy=128,oa=127;function ln(i,s){var t=0,s=s||0,r=0,n=s,o,a=i.length;do{if(n>=a)throw ln.bytes=0,new RangeError("Could not decode varint");o=i[n++],t+=r<28?(o&oa)<<r:(o&oa)*Math.pow(2,r),r+=7}while(o>=fy);return ln.bytes=n-s,t}var gy=Math.pow(2,7),yy=Math.pow(2,14),my=Math.pow(2,21),wy=Math.pow(2,28),by=Math.pow(2,35),vy=Math.pow(2,42),Ey=Math.pow(2,49),Iy=Math.pow(2,56),$y=Math.pow(2,63),_y=function(i){return i<gy?1:i<yy?2:i<my?3:i<wy?4:i<by?5:i<vy?6:i<Ey?7:i<Iy?8:i<$y?9:10},Py={encode:ly,decode:py,encodingLength:_y},Kh=Py;const aa=(i,e,t=0)=>(Kh.encode(i,e,t),e),ca=i=>Kh.encodingLength(i),un=(i,e)=>{const t=e.byteLength,s=ca(i),r=s+ca(t),n=new Uint8Array(r+t);return aa(i,n,0),aa(t,n,s),n.set(e,r),new Sy(i,t,e,n)};let Sy=class{constructor(e,t,s,r){this.code=e,this.size=t,this.digest=s,this.bytes=r}};const Vh=({name:i,code:e,encode:t})=>new xy(i,e,t);let xy=class{constructor(e,t,s){this.name=e,this.code=t,this.encode=s}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?un(this.code,t):t.then(s=>un(this.code,s))}else throw Error("Unknown type, must be binary type")}};const Wh=i=>async e=>new Uint8Array(await crypto.subtle.digest(i,e)),Oy=Vh({name:"sha2-256",code:18,encode:Wh("SHA-256")}),Ay=Vh({name:"sha2-512",code:19,encode:Wh("SHA-512")});var Cy=Object.freeze({__proto__:null,sha256:Oy,sha512:Ay});const Gh=0,Ry="identity",Jh=Mh,Ny=i=>un(Gh,Jh(i)),Ty={code:Gh,name:Ry,encode:Jh,digest:Ny};var By=Object.freeze({__proto__:null,identity:Ty});new TextEncoder,new TextDecoder;const ha={...xg,...Ag,...Rg,...Tg,...jg,...Vg,...Jg,...Qg,...sy,...hy};({...Cy,...By});function Yh(i,e,t,s){return{name:i,prefix:e,encoder:{name:i,prefix:e,encode:t},decoder:{decode:s}}}const la=Yh("utf8","u",i=>"u"+new TextDecoder("utf8").decode(i),i=>new TextEncoder().encode(i.substring(1))),Br=Yh("ascii","a",i=>{let e="a";for(let t=0;t<i.length;t++)e+=String.fromCharCode(i[t]);return e},i=>{i=i.substring(1);const e=Uh(i.length);for(let t=0;t<i.length;t++)e[t]=i.charCodeAt(t);return e}),Zh={utf8:la,"utf-8":la,hex:ha.base16,latin1:Br,ascii:Br,binary:Br,...ha};function lr(i,e="utf8"){const t=Zh[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(i.buffer,i.byteOffset,i.byteLength).toString("utf8"):t.encoder.encode(i).substring(1)}function Fi(i,e="utf8"){const t=Zh[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?Qn(globalThis.Buffer.from(i,"utf-8")):t.decoder.decode(`${t.prefix}${i}`)}function ua(i){return Qt(lr(Fi(i,cr),kh))}function Js(i){return lr(Fi(Xt(i),kh),cr)}function Qh(i){const e=Fi(pg,ra),t=dg+lr(Lh([e,i]),ra);return[lg,ug,t].join(hg)}function Dy(i){return lr(i,cr)}function jy(i){return Fi(i,cr)}function ky(i){return Fi([Js(i.header),Js(i.payload)].join(Gs),qh)}function qy(i){return[Js(i.header),Js(i.payload),Dy(i.signature)].join(Gs)}function dn(i){const e=i.split(Gs),t=ua(e[0]),s=ua(e[1]),r=jy(e[2]),n=Fi(e.slice(0,2).join(Gs),qh);return{header:t,payload:s,signature:r,data:n}}function da(i=Sh(fg)){const e=jh.getPublicKey(i);return{secretKey:Lh([i,e]),publicKey:e}}async function Uy(i,e,t,s,r=T.fromMiliseconds(Date.now())){const n={alg:ag,typ:cg},o=Qh(s.publicKey),a=r+t,c={iss:o,sub:i,aud:e,iat:r,exp:a},h=ky({header:n,payload:c}),l=jh.sign(h,s.secretKey.slice(0,32));return qy({header:n,payload:c,signature:l})}var Ly={};const My=":";function Ri(i){const[e,t]=i.split(My);return{namespace:e,reference:t}}function pa(i,e=[]){const t=[];return Object.keys(i).forEach(s=>{if(e.length&&!e.includes(s))return;const r=i[s];t.push(...r.accounts)}),t}function Xh(i,e){return i.includes(":")?[i]:e.chains||[]}var Fy=Object.defineProperty,zy=Object.defineProperties,Hy=Object.getOwnPropertyDescriptors,fa=Object.getOwnPropertySymbols,Ky=Object.prototype.hasOwnProperty,Vy=Object.prototype.propertyIsEnumerable,ga=(i,e,t)=>e in i?Fy(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ya=(i,e)=>{for(var t in e||(e={}))Ky.call(e,t)&&ga(i,t,e[t]);if(fa)for(var t of fa(e))Vy.call(e,t)&&ga(i,t,e[t]);return i},Wy=(i,e)=>zy(i,Hy(e));const Gy="ReactNative",He={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"},Jy="js";function Ys(){return typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"}function Lt(){return!Ni()&&!!th()&&navigator.product===Gy}function Yy(){return Lt()&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"&&(global==null?void 0:global.Platform.OS)==="android"}function Zy(){return Lt()&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"&&(global==null?void 0:global.Platform.OS)==="ios"}function zi(){return!Ys()&&!!th()&&!!Ni()}function ms(){return Lt()?He.reactNative:Ys()?He.node:zi()?He.browser:He.unknown}function ma(){var i;try{return Lt()&&typeof global<"u"&&typeof(global==null?void 0:global.Application)<"u"?(i=global.Application)==null?void 0:i.applicationId:void 0}catch{return}}function Qy(i,e){const t=new URLSearchParams(i);for(const s of Object.keys(e).sort())if(e.hasOwnProperty(s)){const r=e[s];r!==void 0&&t.set(s,r)}return t.toString()}function Xy(i){var e,t;const s=el();try{return i!=null&&i.url&&s.url&&new URL(i.url).host!==new URL(s.url).host&&(i.url=s.url),(e=i?.icons)!=null&&e.length&&i.icons.length>0&&(i.icons=i.icons.filter(r=>r!=="")),Wy(ya(ya({},s),i),{url:i?.url||s.url,name:i?.name||s.name,description:i?.description||s.description,icons:(t=i?.icons)!=null&&t.length&&i.icons.length>0?i.icons:s.icons})}catch{return i||s}}function el(){return ju()||{name:"",description:"",url:"",icons:[""]}}function em(){if(ms()===He.reactNative&&typeof global<"u"&&typeof(global==null?void 0:global.Platform)<"u"){const{OS:t,Version:s}=global.Platform;return[t,s].join("-")}const i=Gu();if(i===null)return"unknown";const e=i.os?i.os.replace(" ","").toLowerCase():"unknown";return i.type==="browser"?[e,i.name,i.version].join("-"):[e,i.version].join("-")}function tm(){var i;const e=ms();return e===He.browser?[e,((i=ku())==null?void 0:i.host)||"unknown"].join(":"):e}function tl(i,e,t){const s=em(),r=tm();return[[i,e].join("-"),[Jy,t].join("-"),s,r].join("/")}function im({protocol:i,version:e,relayUrl:t,sdkVersion:s,auth:r,projectId:n,useOnCloseEvent:o,bundleId:a,packageName:c}){const h=t.split("?"),l=tl(i,e,s),u={auth:r,ua:l,projectId:n,useOnCloseEvent:o,packageName:c||void 0,bundleId:a||void 0},d=Qy(h[1]||"",u);return h[0]+"?"+d}function Yt(i,e){return i.filter(t=>e.includes(t)).length===i.length}function pn(i){return Object.fromEntries(i.entries())}function fn(i){return new Map(Object.entries(i))}function zt(i=T.FIVE_MINUTES,e){const t=T.toMiliseconds(i||T.FIVE_MINUTES);let s,r,n,o;return{resolve:a=>{n&&s&&(clearTimeout(n),s(a),o=Promise.resolve(a))},reject:a=>{n&&r&&(clearTimeout(n),r(a))},done:()=>new Promise((a,c)=>{if(o)return a(o);n=setTimeout(()=>{const h=new Error(e);o=Promise.reject(h),c(h)},t),s=a,r=c})}}function kt(i,e,t){return new Promise(async(s,r)=>{const n=setTimeout(()=>r(new Error(t)),e);try{const o=await i;s(o)}catch(o){r(o)}clearTimeout(n)})}function il(i,e){if(typeof e=="string"&&e.startsWith(`${i}:`))return e;if(i.toLowerCase()==="topic"){if(typeof e!="string")throw new Error('Value must be "string" for expirer target type: topic');return`topic:${e}`}else if(i.toLowerCase()==="id"){if(typeof e!="number")throw new Error('Value must be "number" for expirer target type: id');return`id:${e}`}throw new Error(`Unknown expirer target type: ${i}`)}function sm(i){return il("topic",i)}function rm(i){return il("id",i)}function sl(i){const[e,t]=i.split(":"),s={id:void 0,topic:void 0};if(e==="topic"&&typeof t=="string")s.topic=t;else if(e==="id"&&Number.isInteger(Number(t)))s.id=Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);return s}function ue(i,e){return T.fromMiliseconds(Date.now()+T.toMiliseconds(i))}function Bt(i){return Date.now()>=T.toMiliseconds(i)}function X(i,e){return`${i}${e?`:${e}`:""}`}function wt(i=[],e=[]){return[...new Set([...i,...e])]}async function nm({id:i,topic:e,wcDeepLink:t}){var s;try{if(!t)return;const r=typeof t=="string"?JSON.parse(t):t,n=r?.href;if(typeof n!="string")return;const o=om(n,i,e),a=ms();if(a===He.browser){if(!((s=Ni())!=null&&s.hasFocus()))return;am(o)}else a===He.reactNative&&typeof(global==null?void 0:global.Linking)<"u"&&await global.Linking.openURL(o)}catch{}}function om(i,e,t){const s=`requestId=${e}&sessionTopic=${t}`;i.endsWith("/")&&(i=i.slice(0,-1));let r=`${i}`;if(i.startsWith("https://t.me")){const n=i.includes("?")?"&startapp=":"?startapp=";r=`${r}${n}${um(s,!0)}`}else r=`${r}/wc?${s}`;return r}function am(i){let e="_self";lm()?e="_top":(hm()||i.startsWith("https://")||i.startsWith("http://"))&&(e="_blank"),window.open(i,e,"noreferrer noopener")}async function cm(i,e){let t="";try{if(zi()&&(t=localStorage.getItem(e),t))return t;t=await i.getItem(e)}catch{}return t}function wa(i,e){if(!i.includes(e))return null;const t=i.split(/([&,?,=])/),s=t.indexOf(e);return t[s+2]}function ba(){return typeof crypto<"u"&&crypto!=null&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu,i=>{const e=Math.random()*16|0;return(i==="x"?e:e&3|8).toString(16)})}function Xn(){return typeof process<"u"&&Ly.IS_VITEST==="true"}function hm(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function lm(){try{return window.self!==window.top}catch{return!1}}function um(i,e=!1){const t=Buffer.from(i).toString("base64");return e?t.replace(/[=]/g,""):t}function rl(i){return Buffer.from(i,"base64").toString("utf-8")}function dm(i){return new Promise(e=>setTimeout(e,i))}function ls(i){if(!Number.isSafeInteger(i)||i<0)throw new Error("positive integer expected, got "+i)}function pm(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function ws(i,...e){if(!pm(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function eo(i){if(typeof i!="function"||typeof i.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ls(i.outputLen),ls(i.blockLen)}function Ti(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function nl(i,e){ws(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const Cs=BigInt(2**32-1),va=BigInt(32);function fm(i,e=!1){return e?{h:Number(i&Cs),l:Number(i>>va&Cs)}:{h:Number(i>>va&Cs)|0,l:Number(i&Cs)|0}}function gm(i,e=!1){let t=new Uint32Array(i.length),s=new Uint32Array(i.length);for(let r=0;r<i.length;r++){const{h:n,l:o}=fm(i[r],e);[t[r],s[r]]=[n,o]}return[t,s]}const ym=(i,e,t)=>i<<t|e>>>32-t,mm=(i,e,t)=>e<<t|i>>>32-t,wm=(i,e,t)=>e<<t-32|i>>>64-t,bm=(i,e,t)=>i<<t-32|e>>>64-t,di=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function vm(i){return new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4))}function Dr(i){return new DataView(i.buffer,i.byteOffset,i.byteLength)}function ut(i,e){return i<<32-e|i>>>e}const Ea=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Em(i){return i<<24&4278190080|i<<8&16711680|i>>>8&65280|i>>>24&255}function Ia(i){for(let e=0;e<i.length;e++)i[e]=Em(i[e])}function Im(i){if(typeof i!="string")throw new Error("utf8ToBytes expected string, got "+typeof i);return new Uint8Array(new TextEncoder().encode(i))}function Bi(i){return typeof i=="string"&&(i=Im(i)),ws(i),i}function $m(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];ws(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const n=i[s];t.set(n,r),r+=n.length}return t}let to=class{clone(){return this._cloneInto()}};function ol(i){const e=s=>i().update(Bi(s)).digest(),t=i();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>i(),e}function Hi(i=32){if(di&&typeof di.getRandomValues=="function")return di.getRandomValues(new Uint8Array(i));if(di&&typeof di.randomBytes=="function")return di.randomBytes(i);throw new Error("crypto.getRandomValues must be defined")}const al=[],cl=[],hl=[],_m=BigInt(0),Ji=BigInt(1),Pm=BigInt(2),Sm=BigInt(7),xm=BigInt(256),Om=BigInt(113);for(let i=0,e=Ji,t=1,s=0;i<24;i++){[t,s]=[s,(2*t+3*s)%5],al.push(2*(5*s+t)),cl.push((i+1)*(i+2)/2%64);let r=_m;for(let n=0;n<7;n++)e=(e<<Ji^(e>>Sm)*Om)%xm,e&Pm&&(r^=Ji<<(Ji<<BigInt(n))-Ji);hl.push(r)}const[Am,Cm]=gm(hl,!0),$a=(i,e,t)=>t>32?wm(i,e,t):ym(i,e,t),_a=(i,e,t)=>t>32?bm(i,e,t):mm(i,e,t);function Rm(i,e=24){const t=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let o=0;o<10;o++)t[o]=i[o]^i[o+10]^i[o+20]^i[o+30]^i[o+40];for(let o=0;o<10;o+=2){const a=(o+8)%10,c=(o+2)%10,h=t[c],l=t[c+1],u=$a(h,l,1)^t[a],d=_a(h,l,1)^t[a+1];for(let f=0;f<50;f+=10)i[o+f]^=u,i[o+f+1]^=d}let r=i[2],n=i[3];for(let o=0;o<24;o++){const a=cl[o],c=$a(r,n,a),h=_a(r,n,a),l=al[o];r=i[l],n=i[l+1],i[l]=c,i[l+1]=h}for(let o=0;o<50;o+=10){for(let a=0;a<10;a++)t[a]=i[o+a];for(let a=0;a<10;a++)i[o+a]^=~t[(a+2)%10]&t[(a+4)%10]}i[0]^=Am[s],i[1]^=Cm[s]}t.fill(0)}let Nm=class ll extends to{constructor(e,t,s,r=!1,n=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=s,this.enableXOF=r,this.rounds=n,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,ls(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=vm(this.state)}keccak(){Ea||Ia(this.state32),Rm(this.state32,this.rounds),Ea||Ia(this.state32),this.posOut=0,this.pos=0}update(e){Ti(this);const{blockLen:t,state:s}=this;e=Bi(e);const r=e.length;for(let n=0;n<r;){const o=Math.min(t-this.pos,r-n);for(let a=0;a<o;a++)s[this.pos++]^=e[n++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:s,blockLen:r}=this;e[s]^=t,t&128&&s===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){Ti(this,!1),ws(e),this.finish();const t=this.state,{blockLen:s}=this;for(let r=0,n=e.length;r<n;){this.posOut>=s&&this.keccak();const o=Math.min(s-this.posOut,n-r);e.set(t.subarray(this.posOut,this.posOut+o),r),this.posOut+=o,r+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return ls(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(nl(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:s,outputLen:r,rounds:n,enableXOF:o}=this;return e||(e=new ll(t,s,r,o,n)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=n,e.suffix=s,e.outputLen=r,e.enableXOF=o,e.destroyed=this.destroyed,e}};const Tm=(i,e,t)=>ol(()=>new Nm(e,i,t)),Bm=Tm(1,136,256/8),Dm="https://rpc.walletconnect.org/v1";function ul(i){const e=`Ethereum Signed Message:
${i.length}`,t=new TextEncoder().encode(e+i);return"0x"+Buffer.from(Bm(t)).toString("hex")}async function jm(i,e,t,s,r,n){switch(t.t){case"eip191":return await km(i,e,t.s);case"eip1271":return await qm(i,e,t.s,s,r,n);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`)}}async function km(i,e,t){return(await Kp({hash:ul(e),signature:t})).toLowerCase()===i.toLowerCase()}async function qm(i,e,t,s,r,n){const o=Ri(s);if(!o.namespace||!o.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${s}`);try{const a="0x1626ba7e",c="0000000000000000000000000000000000000000000000000000000000000040",h="0000000000000000000000000000000000000000000000000000000000000041",l=t.substring(2),u=ul(e).substring(2),d=a+u+c+h+l,f=await fetch(`${n||Dm}/?chainId=${s}&projectId=${r}`,{method:"POST",body:JSON.stringify({id:Um(),jsonrpc:"2.0",method:"eth_call",params:[{to:i,data:d},"latest"]})}),{result:p}=await f.json();return p?p.slice(0,a.length).toLowerCase()===a.toLowerCase():!1}catch{return!1}}function Um(){return Date.now()+Math.floor(Math.random()*1e3)}function Lm(i){const e=atob(i),t=new Uint8Array(e.length);for(let o=0;o<e.length;o++)t[o]=e.charCodeAt(o);const s=t[0];if(s===0)throw new Error("No signatures found");const r=1+s*64;if(t.length<r)throw new Error("Transaction data too short for claimed signature count");if(t.length<100)throw new Error("Transaction too short");const n=Buffer.from(i,"base64").slice(1,65);return Gp.encode(n)}var Mm=Object.defineProperty,Fm=Object.defineProperties,zm=Object.getOwnPropertyDescriptors,Pa=Object.getOwnPropertySymbols,Hm=Object.prototype.hasOwnProperty,Km=Object.prototype.propertyIsEnumerable,Sa=(i,e,t)=>e in i?Mm(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Vm=(i,e)=>{for(var t in e||(e={}))Hm.call(e,t)&&Sa(i,t,e[t]);if(Pa)for(var t of Pa(e))Km.call(e,t)&&Sa(i,t,e[t]);return i},Wm=(i,e)=>Fm(i,zm(e));const Gm="did:pkh:",io=i=>i?.split(":"),Jm=i=>{const e=i&&io(i);if(e)return i.includes(Gm)?e[3]:e[1]},gn=i=>{const e=i&&io(i);if(e)return e[2]+":"+e[3]},Zs=i=>{const e=i&&io(i);if(e)return e.pop()};async function xa(i){const{cacao:e,projectId:t}=i,{s,p:r}=e,n=dl(r,r.iss),o=Zs(r.iss);return await jm(o,n,s,gn(r.iss),t)}const dl=(i,e)=>{const t=`${i.domain} wants you to sign in with your Ethereum account:`,s=Zs(e);if(!i.aud&&!i.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let r=i.statement||void 0;const n=`URI: ${i.aud||i.uri}`,o=`Version: ${i.version}`,a=`Chain ID: ${Jm(e)}`,c=`Nonce: ${i.nonce}`,h=`Issued At: ${i.iat}`,l=i.exp?`Expiration Time: ${i.exp}`:void 0,u=i.nbf?`Not Before: ${i.nbf}`:void 0,d=i.requestId?`Request ID: ${i.requestId}`:void 0,f=i.resources?`Resources:${i.resources.map(g=>`
- ${g}`).join("")}`:void 0,p=zs(i.resources);if(p){const g=us(p);r=rw(r,g)}return[t,s,"",r,"",n,o,a,c,h,l,u,d,f].filter(g=>g!=null).join(`
`)};function Ym(i){return Buffer.from(JSON.stringify(i)).toString("base64")}function Zm(i){return JSON.parse(Buffer.from(i,"base64").toString("utf-8"))}function ti(i){if(!i)throw new Error("No recap provided, value is undefined");if(!i.att)throw new Error("No `att` property found");const e=Object.keys(i.att);if(!(e!=null&&e.length))throw new Error("No resources found in `att` property");e.forEach(t=>{const s=i.att[t];if(Array.isArray(s))throw new Error(`Resource must be an object: ${t}`);if(typeof s!="object")throw new Error(`Resource must be an object: ${t}`);if(!Object.keys(s).length)throw new Error(`Resource object is empty: ${t}`);Object.keys(s).forEach(r=>{const n=s[r];if(!Array.isArray(n))throw new Error(`Ability limits ${r} must be an array of objects, found: ${n}`);if(!n.length)throw new Error(`Value of ${r} is empty array, must be an array with objects`);n.forEach(o=>{if(typeof o!="object")throw new Error(`Ability limits (${r}) must be an array of objects, found: ${o}`)})})})}function Qm(i,e,t,s={}){return t?.sort((r,n)=>r.localeCompare(n)),{att:{[i]:Xm(e,t,s)}}}function Xm(i,e,t={}){e=e?.sort((r,n)=>r.localeCompare(n));const s=e.map(r=>({[`${i}/${r}`]:[t]}));return Object.assign({},...s)}function pl(i){return ti(i),`urn:recap:${Ym(i).replace(/=/g,"")}`}function us(i){const e=Zm(i.replace("urn:recap:",""));return ti(e),e}function ew(i,e,t){const s=Qm(i,e,t);return pl(s)}function tw(i){return i&&i.includes("urn:recap:")}function iw(i,e){const t=us(i),s=us(e),r=sw(t,s);return pl(r)}function sw(i,e){ti(i),ti(e);const t=Object.keys(i.att).concat(Object.keys(e.att)).sort((r,n)=>r.localeCompare(n)),s={att:{}};return t.forEach(r=>{var n,o;Object.keys(((n=i.att)==null?void 0:n[r])||{}).concat(Object.keys(((o=e.att)==null?void 0:o[r])||{})).sort((a,c)=>a.localeCompare(c)).forEach(a=>{var c,h;s.att[r]=Wm(Vm({},s.att[r]),{[a]:((c=i.att[r])==null?void 0:c[a])||((h=e.att[r])==null?void 0:h[a])})})}),s}function rw(i="",e){ti(e);const t="I further authorize the stated URI to perform the following actions on my behalf: ";if(i.includes(t))return i;const s=[];let r=0;Object.keys(e.att).forEach(a=>{const c=Object.keys(e.att[a]).map(u=>({ability:u.split("/")[0],action:u.split("/")[1]}));c.sort((u,d)=>u.action.localeCompare(d.action));const h={};c.forEach(u=>{h[u.ability]||(h[u.ability]=[]),h[u.ability].push(u.action)});const l=Object.keys(h).map(u=>(r++,`(${r}) '${u}': '${h[u].join("', '")}' for '${a}'.`));s.push(l.join(", ").replace(".,","."))});const n=s.join(" "),o=`${t}${n}`;return`${i?i+" ":""}${o}`}function Oa(i){var e;const t=us(i);ti(t);const s=(e=t.att)==null?void 0:e.eip155;return s?Object.keys(s).map(r=>r.split("/")[1]):[]}function Aa(i){const e=us(i);ti(e);const t=[];return Object.values(e.att).forEach(s=>{Object.values(s).forEach(r=>{var n;(n=r?.[0])!=null&&n.chains&&t.push(r[0].chains)})}),[...new Set(t.flat())]}function zs(i){if(!i)return;const e=i?.[i.length-1];return tw(e)?e:void 0}function jr(i){if(!Number.isSafeInteger(i)||i<0)throw new Error("positive integer expected, got "+i)}function fl(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function ze(i,...e){if(!fl(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function Ca(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function nw(i,e){ze(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Ra(i){if(typeof i!="boolean")throw new Error(`boolean expected, not ${i}`)}const qt=i=>new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4)),ow=i=>new DataView(i.buffer,i.byteOffset,i.byteLength),aw=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!aw)throw new Error("Non little-endian hardware is not supported");function cw(i){if(typeof i!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(i))}function yn(i){if(typeof i=="string")i=cw(i);else if(fl(i))i=mn(i);else throw new Error("Uint8Array expected, got "+typeof i);return i}function hw(i,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(i,e)}function lw(i,e){if(i.length!==e.length)return!1;let t=0;for(let s=0;s<i.length;s++)t|=i[s]^e[s];return t===0}const uw=(i,e)=>{function t(s,...r){if(ze(s),i.nonceLength!==void 0){const h=r[0];if(!h)throw new Error("nonce / iv required");i.varSizeNonce?ze(h):ze(h,i.nonceLength)}const n=i.tagLength;n&&r[1]!==void 0&&ze(r[1]);const o=e(s,...r),a=(h,l)=>{if(l!==void 0){if(h!==2)throw new Error("cipher output not supported");ze(l)}};let c=!1;return{encrypt(h,l){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,ze(h),a(o.encrypt.length,l),o.encrypt(h,l)},decrypt(h,l){if(ze(h),n&&h.length<n)throw new Error("invalid ciphertext length: smaller than tagLength="+n);return a(o.decrypt.length,l),o.decrypt(h,l)}}}return Object.assign(t,i),t};function Na(i,e,t=!0){if(e===void 0)return new Uint8Array(i);if(e.length!==i)throw new Error("invalid output length, expected "+i+", got: "+e.length);if(t&&!dw(e))throw new Error("invalid output, must be aligned");return e}function Ta(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(t>>r&n),a=Number(t&n);i.setUint32(e+4,o,s),i.setUint32(e+0,a,s)}function dw(i){return i.byteOffset%4===0}function mn(i){return Uint8Array.from(i)}function Di(...i){for(let e=0;e<i.length;e++)i[e].fill(0)}const gl=i=>Uint8Array.from(i.split("").map(e=>e.charCodeAt(0))),pw=gl("expand 16-byte k"),fw=gl("expand 32-byte k"),gw=qt(pw),yw=qt(fw);function Y(i,e){return i<<e|i>>>32-e}function wn(i){return i.byteOffset%4===0}const Rs=64,mw=16,yl=2**32-1,Ba=new Uint32Array;function ww(i,e,t,s,r,n,o,a){const c=r.length,h=new Uint8Array(Rs),l=qt(h),u=wn(r)&&wn(n),d=u?qt(r):Ba,f=u?qt(n):Ba;for(let p=0;p<c;o++){if(i(e,t,s,l,o,a),o>=yl)throw new Error("arx: counter overflow");const g=Math.min(Rs,c-p);if(u&&g===Rs){const y=p/4;if(p%4!==0)throw new Error("arx: invalid block position");for(let b=0,m;b<mw;b++)m=y+b,f[m]=d[m]^l[b];p+=Rs;continue}for(let y=0,b;y<g;y++)b=p+y,n[b]=r[b]^h[y];p+=g}}function bw(i,e){const{allowShortKeys:t,extendNonceFn:s,counterLength:r,counterRight:n,rounds:o}=hw({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof i!="function")throw new Error("core must be a function");return jr(r),jr(o),Ra(n),Ra(t),(a,c,h,l,u=0)=>{ze(a),ze(c),ze(h);const d=h.length;if(l===void 0&&(l=new Uint8Array(d)),ze(l),jr(u),u<0||u>=yl)throw new Error("arx: counter overflow");if(l.length<d)throw new Error(`arx: output (${l.length}) is shorter than data (${d})`);const f=[];let p=a.length,g,y;if(p===32)f.push(g=mn(a)),y=yw;else if(p===16&&t)g=new Uint8Array(32),g.set(a),g.set(a,16),y=gw,f.push(g);else throw new Error(`arx: invalid 32-byte key, got length=${p}`);wn(c)||f.push(c=mn(c));const b=qt(g);if(s){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(y,b,qt(c.subarray(0,16)),b),c=c.subarray(16)}const m=16-r;if(m!==c.length)throw new Error(`arx: nonce must be ${m} or 16 bytes`);if(m!==12){const $=new Uint8Array(12);$.set(c,n?0:12-c.length),c=$,f.push(c)}const w=qt(c);return ww(i,y,b,w,h,l,u,o),Di(...f),l}}const Ee=(i,e)=>i[e++]&255|(i[e++]&255)<<8;class vw{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=yn(e),ze(e,32);const t=Ee(e,0),s=Ee(e,2),r=Ee(e,4),n=Ee(e,6),o=Ee(e,8),a=Ee(e,10),c=Ee(e,12),h=Ee(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|s<<3)&8191,this.r[2]=(s>>>10|r<<6)&7939,this.r[3]=(r>>>7|n<<9)&8191,this.r[4]=(n>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|h<<8)&8191,this.r[9]=h>>>5&127;for(let l=0;l<8;l++)this.pad[l]=Ee(e,16+2*l)}process(e,t,s=!1){const r=s?0:2048,{h:n,r:o}=this,a=o[0],c=o[1],h=o[2],l=o[3],u=o[4],d=o[5],f=o[6],p=o[7],g=o[8],y=o[9],b=Ee(e,t+0),m=Ee(e,t+2),w=Ee(e,t+4),$=Ee(e,t+6),A=Ee(e,t+8),S=Ee(e,t+10),x=Ee(e,t+12),N=Ee(e,t+14);let _=n[0]+(b&8191),L=n[1]+((b>>>13|m<<3)&8191),j=n[2]+((m>>>10|w<<6)&8191),q=n[3]+((w>>>7|$<<9)&8191),M=n[4]+(($>>>4|A<<12)&8191),C=n[5]+(A>>>1&8191),E=n[6]+((A>>>14|S<<2)&8191),v=n[7]+((S>>>11|x<<5)&8191),P=n[8]+((x>>>8|N<<8)&8191),O=n[9]+(N>>>5|r),I=0,B=I+_*a+L*(5*y)+j*(5*g)+q*(5*p)+M*(5*f);I=B>>>13,B&=8191,B+=C*(5*d)+E*(5*u)+v*(5*l)+P*(5*h)+O*(5*c),I+=B>>>13,B&=8191;let k=I+_*c+L*a+j*(5*y)+q*(5*g)+M*(5*p);I=k>>>13,k&=8191,k+=C*(5*f)+E*(5*d)+v*(5*u)+P*(5*l)+O*(5*h),I+=k>>>13,k&=8191;let U=I+_*h+L*c+j*a+q*(5*y)+M*(5*g);I=U>>>13,U&=8191,U+=C*(5*p)+E*(5*f)+v*(5*d)+P*(5*u)+O*(5*l),I+=U>>>13,U&=8191;let F=I+_*l+L*h+j*c+q*a+M*(5*y);I=F>>>13,F&=8191,F+=C*(5*g)+E*(5*p)+v*(5*f)+P*(5*d)+O*(5*u),I+=F>>>13,F&=8191;let z=I+_*u+L*l+j*h+q*c+M*a;I=z>>>13,z&=8191,z+=C*(5*y)+E*(5*g)+v*(5*p)+P*(5*f)+O*(5*d),I+=z>>>13,z&=8191;let K=I+_*d+L*u+j*l+q*h+M*c;I=K>>>13,K&=8191,K+=C*a+E*(5*y)+v*(5*g)+P*(5*p)+O*(5*f),I+=K>>>13,K&=8191;let G=I+_*f+L*d+j*u+q*l+M*h;I=G>>>13,G&=8191,G+=C*c+E*a+v*(5*y)+P*(5*g)+O*(5*p),I+=G>>>13,G&=8191;let re=I+_*p+L*f+j*d+q*u+M*l;I=re>>>13,re&=8191,re+=C*h+E*c+v*a+P*(5*y)+O*(5*g),I+=re>>>13,re&=8191;let ee=I+_*g+L*p+j*f+q*d+M*u;I=ee>>>13,ee&=8191,ee+=C*l+E*h+v*c+P*a+O*(5*y),I+=ee>>>13,ee&=8191;let J=I+_*y+L*g+j*p+q*f+M*d;I=J>>>13,J&=8191,J+=C*u+E*l+v*h+P*c+O*a,I+=J>>>13,J&=8191,I=(I<<2)+I|0,I=I+B|0,B=I&8191,I=I>>>13,k+=I,n[0]=B,n[1]=k,n[2]=U,n[3]=F,n[4]=z,n[5]=K,n[6]=G,n[7]=re,n[8]=ee,n[9]=J}finalize(){const{h:e,pad:t}=this,s=new Uint16Array(10);let r=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=r,r=e[a]>>>13,e[a]&=8191;e[0]+=r*5,r=e[0]>>>13,e[0]&=8191,e[1]+=r,r=e[1]>>>13,e[1]&=8191,e[2]+=r,s[0]=e[0]+5,r=s[0]>>>13,s[0]&=8191;for(let a=1;a<10;a++)s[a]=e[a]+r,r=s[a]>>>13,s[a]&=8191;s[9]-=8192;let n=(r^1)-1;for(let a=0;a<10;a++)s[a]&=n;n=~n;for(let a=0;a<10;a++)e[a]=e[a]&n|s[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;Di(s)}update(e){Ca(this);const{buffer:t,blockLen:s}=this;e=yn(e);const r=e.length;for(let n=0;n<r;){const o=Math.min(s-this.pos,r-n);if(o===s){for(;s<=r-n;n+=s)this.process(e,n);continue}t.set(e.subarray(n,n+o),this.pos),this.pos+=o,n+=o,this.pos===s&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){Di(this.h,this.r,this.buffer,this.pad)}digestInto(e){Ca(this),nw(e,this),this.finished=!0;const{buffer:t,h:s}=this;let{pos:r}=this;if(r){for(t[r++]=1;r<16;r++)t[r]=0;this.process(t,0,!0)}this.finalize();let n=0;for(let o=0;o<8;o++)e[n++]=s[o]>>>0,e[n++]=s[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}}function Ew(i){const e=(s,r)=>i(r).update(yn(s)).digest(),t=i(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=s=>i(s),e}const Iw=Ew(i=>new vw(i));function $w(i,e,t,s,r,n=20){let o=i[0],a=i[1],c=i[2],h=i[3],l=e[0],u=e[1],d=e[2],f=e[3],p=e[4],g=e[5],y=e[6],b=e[7],m=r,w=t[0],$=t[1],A=t[2],S=o,x=a,N=c,_=h,L=l,j=u,q=d,M=f,C=p,E=g,v=y,P=b,O=m,I=w,B=$,k=A;for(let F=0;F<n;F+=2)S=S+L|0,O=Y(O^S,16),C=C+O|0,L=Y(L^C,12),S=S+L|0,O=Y(O^S,8),C=C+O|0,L=Y(L^C,7),x=x+j|0,I=Y(I^x,16),E=E+I|0,j=Y(j^E,12),x=x+j|0,I=Y(I^x,8),E=E+I|0,j=Y(j^E,7),N=N+q|0,B=Y(B^N,16),v=v+B|0,q=Y(q^v,12),N=N+q|0,B=Y(B^N,8),v=v+B|0,q=Y(q^v,7),_=_+M|0,k=Y(k^_,16),P=P+k|0,M=Y(M^P,12),_=_+M|0,k=Y(k^_,8),P=P+k|0,M=Y(M^P,7),S=S+j|0,k=Y(k^S,16),v=v+k|0,j=Y(j^v,12),S=S+j|0,k=Y(k^S,8),v=v+k|0,j=Y(j^v,7),x=x+q|0,O=Y(O^x,16),P=P+O|0,q=Y(q^P,12),x=x+q|0,O=Y(O^x,8),P=P+O|0,q=Y(q^P,7),N=N+M|0,I=Y(I^N,16),C=C+I|0,M=Y(M^C,12),N=N+M|0,I=Y(I^N,8),C=C+I|0,M=Y(M^C,7),_=_+L|0,B=Y(B^_,16),E=E+B|0,L=Y(L^E,12),_=_+L|0,B=Y(B^_,8),E=E+B|0,L=Y(L^E,7);let U=0;s[U++]=o+S|0,s[U++]=a+x|0,s[U++]=c+N|0,s[U++]=h+_|0,s[U++]=l+L|0,s[U++]=u+j|0,s[U++]=d+q|0,s[U++]=f+M|0,s[U++]=p+C|0,s[U++]=g+E|0,s[U++]=y+v|0,s[U++]=b+P|0,s[U++]=m+O|0,s[U++]=w+I|0,s[U++]=$+B|0,s[U++]=A+k|0}const _w=bw($w,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Pw=new Uint8Array(16),Da=(i,e)=>{i.update(e);const t=e.length%16;t&&i.update(Pw.subarray(t))},Sw=new Uint8Array(32);function ja(i,e,t,s,r){const n=i(e,t,Sw),o=Iw.create(n);r&&Da(o,r),Da(o,s);const a=new Uint8Array(16),c=ow(a);Ta(c,0,BigInt(r?r.length:0),!0),Ta(c,8,BigInt(s.length),!0),o.update(a);const h=o.digest();return Di(n,a),h}const xw=i=>(e,t,s)=>({encrypt(r,n){const o=r.length;n=Na(o+16,n,!1),n.set(r);const a=n.subarray(0,-16);i(e,t,a,a,1);const c=ja(i,e,t,a,s);return n.set(c,o),Di(c),n},decrypt(r,n){n=Na(r.length-16,n,!1);const o=r.subarray(0,-16),a=r.subarray(-16),c=ja(i,e,t,o,s);if(!lw(a,c))throw new Error("invalid tag");return n.set(r.subarray(0,-16)),i(e,t,n,n,1),Di(c),n}}),ml=uw({blockSize:64,nonceLength:12,tagLength:16},xw(_w));let wl=class extends to{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,eo(e);const s=Bi(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,n=new Uint8Array(r);n.set(s.length>r?e.create().update(s).digest():s);for(let o=0;o<n.length;o++)n[o]^=54;this.iHash.update(n),this.oHash=e.create();for(let o=0;o<n.length;o++)n[o]^=106;this.oHash.update(n),n.fill(0)}update(e){return Ti(this),this.iHash.update(e),this}digestInto(e){Ti(this),ws(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:s,finished:r,destroyed:n,blockLen:o,outputLen:a}=this;return e=e,e.finished=r,e.destroyed=n,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const ur=(i,e,t)=>new wl(i,e).update(t).digest();ur.create=(i,e)=>new wl(i,e);function Ow(i,e,t){return eo(i),t===void 0&&(t=new Uint8Array(i.outputLen)),ur(i,Bi(t),Bi(e))}const kr=new Uint8Array([0]),ka=new Uint8Array;function Aw(i,e,t,s=32){if(eo(i),ls(s),s>255*i.outputLen)throw new Error("Length should be <= 255*HashLen");const r=Math.ceil(s/i.outputLen);t===void 0&&(t=ka);const n=new Uint8Array(r*i.outputLen),o=ur.create(i,e),a=o._cloneInto(),c=new Uint8Array(o.outputLen);for(let h=0;h<r;h++)kr[0]=h+1,a.update(h===0?ka:c).update(t).update(kr).digestInto(c),n.set(c,i.outputLen*h),o._cloneInto(a);return o.destroy(),a.destroy(),c.fill(0),kr.fill(0),n.slice(0,s)}const Cw=(i,e,t,s,r)=>Aw(i,Ow(i,e,t),s,r);function Rw(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),n=BigInt(4294967295),o=Number(t>>r&n),a=Number(t&n),c=s?4:0,h=s?0:4;i.setUint32(e+c,o,s),i.setUint32(e+h,a,s)}function Nw(i,e,t){return i&e^~i&t}function Tw(i,e,t){return i&e^i&t^e&t}let Bw=class extends to{constructor(e,t,s,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Dr(this.buffer)}update(e){Ti(this);const{view:t,buffer:s,blockLen:r}=this;e=Bi(e);const n=e.length;for(let o=0;o<n;){const a=Math.min(r-this.pos,n-o);if(a===r){const c=Dr(e);for(;r<=n-o;o+=r)this.process(c,o);continue}s.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ti(this),nl(e,this),this.finished=!0;const{buffer:t,view:s,blockLen:r,isLE:n}=this;let{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>r-o&&(this.process(s,0),o=0);for(let u=o;u<r;u++)t[u]=0;Rw(s,r-8,BigInt(this.length*8),n),this.process(s,0);const a=Dr(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=c/4,l=this.get();if(h>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<h;u++)a.setUint32(4*u,l[u],n)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:s,length:r,finished:n,destroyed:o,pos:a}=this;return e.length=r,e.pos=a,e.finished=n,e.destroyed=o,r%t&&e.buffer.set(s),e}};const Dw=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Nt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Tt=new Uint32Array(64);class jw extends Bw{constructor(){super(64,32,8,!1),this.A=Nt[0]|0,this.B=Nt[1]|0,this.C=Nt[2]|0,this.D=Nt[3]|0,this.E=Nt[4]|0,this.F=Nt[5]|0,this.G=Nt[6]|0,this.H=Nt[7]|0}get(){const{A:e,B:t,C:s,D:r,E:n,F:o,G:a,H:c}=this;return[e,t,s,r,n,o,a,c]}set(e,t,s,r,n,o,a,c){this.A=e|0,this.B=t|0,this.C=s|0,this.D=r|0,this.E=n|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let u=0;u<16;u++,t+=4)Tt[u]=e.getUint32(t,!1);for(let u=16;u<64;u++){const d=Tt[u-15],f=Tt[u-2],p=ut(d,7)^ut(d,18)^d>>>3,g=ut(f,17)^ut(f,19)^f>>>10;Tt[u]=g+Tt[u-7]+p+Tt[u-16]|0}let{A:s,B:r,C:n,D:o,E:a,F:c,G:h,H:l}=this;for(let u=0;u<64;u++){const d=ut(a,6)^ut(a,11)^ut(a,25),f=l+d+Nw(a,c,h)+Dw[u]+Tt[u]|0,p=(ut(s,2)^ut(s,13)^ut(s,22))+Tw(s,r,n)|0;l=h,h=c,c=a,a=o+f|0,o=n,n=r,r=s,s=f+p|0}s=s+this.A|0,r=r+this.B|0,n=n+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,h=h+this.G|0,l=l+this.H|0,this.set(s,r,n,o,a,c,h,l)}roundClean(){Tt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const bs=ol(()=>new jw);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dr=BigInt(0),pr=BigInt(1),kw=BigInt(2);function ii(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function vs(i){if(!ii(i))throw new Error("Uint8Array expected")}function ji(i,e){if(typeof e!="boolean")throw new Error(i+" boolean expected, got "+e)}const qw=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function ki(i){vs(i);let e="";for(let t=0;t<i.length;t++)e+=qw[i[t]];return e}function Oi(i){const e=i.toString(16);return e.length&1?"0"+e:e}function so(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);return i===""?dr:BigInt("0x"+i)}const _t={_0:48,_9:57,A:65,F:70,a:97,f:102};function qa(i){if(i>=_t._0&&i<=_t._9)return i-_t._0;if(i>=_t.A&&i<=_t.F)return i-(_t.A-10);if(i>=_t.a&&i<=_t.f)return i-(_t.a-10)}function qi(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);const e=i.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(t);for(let r=0,n=0;r<t;r++,n+=2){const o=qa(i.charCodeAt(n)),a=qa(i.charCodeAt(n+1));if(o===void 0||a===void 0){const c=i[n]+i[n+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+n)}s[r]=o*16+a}return s}function Zt(i){return so(ki(i))}function ds(i){return vs(i),so(ki(Uint8Array.from(i).reverse()))}function Ui(i,e){return qi(i.toString(16).padStart(e*2,"0"))}function fr(i,e){return Ui(i,e).reverse()}function Uw(i){return qi(Oi(i))}function Fe(i,e,t){let s;if(typeof e=="string")try{s=qi(e)}catch(n){throw new Error(i+" must be hex string or Uint8Array, cause: "+n)}else if(ii(e))s=Uint8Array.from(e);else throw new Error(i+" must be hex string or Uint8Array");const r=s.length;if(typeof t=="number"&&r!==t)throw new Error(i+" of length "+t+" expected, got "+r);return s}function ps(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];vs(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const n=i[s];t.set(n,r),r+=n.length}return t}function Lw(i,e){if(i.length!==e.length)return!1;let t=0;for(let s=0;s<i.length;s++)t|=i[s]^e[s];return t===0}function Mw(i){if(typeof i!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(i))}const qr=i=>typeof i=="bigint"&&dr<=i;function gr(i,e,t){return qr(i)&&qr(e)&&qr(t)&&e<=i&&i<t}function Ot(i,e,t,s){if(!gr(e,t,s))throw new Error("expected valid "+i+": "+t+" <= n < "+s+", got "+e)}function bl(i){let e;for(e=0;i>dr;i>>=pr,e+=1);return e}function Fw(i,e){return i>>BigInt(e)&pr}function zw(i,e,t){return i|(t?pr:dr)<<BigInt(e)}const ro=i=>(kw<<BigInt(i-1))-pr,Ur=i=>new Uint8Array(i),Ua=i=>Uint8Array.from(i);function vl(i,e,t){if(typeof i!="number"||i<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let s=Ur(i),r=Ur(i),n=0;const o=()=>{s.fill(1),r.fill(0),n=0},a=(...l)=>t(r,s,...l),c=(l=Ur())=>{r=a(Ua([0]),l),s=a(),l.length!==0&&(r=a(Ua([1]),l),s=a())},h=()=>{if(n++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const u=[];for(;l<e;){s=a();const d=s.slice();u.push(d),l+=s.length}return ps(...u)};return(l,u)=>{o(),c(l);let d;for(;!(d=u(h()));)c();return o(),d}}const Hw={bigint:i=>typeof i=="bigint",function:i=>typeof i=="function",boolean:i=>typeof i=="boolean",string:i=>typeof i=="string",stringOrUint8Array:i=>typeof i=="string"||ii(i),isSafeInteger:i=>Number.isSafeInteger(i),array:i=>Array.isArray(i),field:(i,e)=>e.Fp.isValid(i),hash:i=>typeof i=="function"&&Number.isSafeInteger(i.outputLen)};function Ki(i,e,t={}){const s=(r,n,o)=>{const a=Hw[n];if(typeof a!="function")throw new Error("invalid validator function");const c=i[r];if(!(o&&c===void 0)&&!a(c,i))throw new Error("param "+String(r)+" is invalid. Expected "+n+", got "+c)};for(const[r,n]of Object.entries(e))s(r,n,!1);for(const[r,n]of Object.entries(t))s(r,n,!0);return i}const Kw=()=>{throw new Error("not implemented")};function bn(i){const e=new WeakMap;return(t,...s)=>{const r=e.get(t);if(r!==void 0)return r;const n=i(t,...s);return e.set(t,n),n}}var Vw=Object.freeze({__proto__:null,isBytes:ii,abytes:vs,abool:ji,bytesToHex:ki,numberToHexUnpadded:Oi,hexToNumber:so,hexToBytes:qi,bytesToNumberBE:Zt,bytesToNumberLE:ds,numberToBytesBE:Ui,numberToBytesLE:fr,numberToVarBytesBE:Uw,ensureBytes:Fe,concatBytes:ps,equalBytes:Lw,utf8ToBytes:Mw,inRange:gr,aInRange:Ot,bitLen:bl,bitGet:Fw,bitSet:zw,bitMask:ro,createHmacDrbg:vl,validateObject:Ki,notImplemented:Kw,memoized:bn});const be=BigInt(0),ce=BigInt(1),Vt=BigInt(2),Ww=BigInt(3),vn=BigInt(4),La=BigInt(5),Ma=BigInt(8);function ke(i,e){const t=i%e;return t>=be?t:e+t}function El(i,e,t){if(e<be)throw new Error("invalid exponent, negatives unsupported");if(t<=be)throw new Error("invalid modulus");if(t===ce)return be;let s=ce;for(;e>be;)e&ce&&(s=s*i%t),i=i*i%t,e>>=ce;return s}function ot(i,e,t){let s=i;for(;e-- >be;)s*=s,s%=t;return s}function En(i,e){if(i===be)throw new Error("invert: expected non-zero number");if(e<=be)throw new Error("invert: expected positive modulus, got "+e);let t=ke(i,e),s=e,r=be,n=ce;for(;t!==be;){const o=s/t,a=s%t,c=r-n*o;s=t,t=a,r=n,n=c}if(s!==ce)throw new Error("invert: does not exist");return ke(r,e)}function Gw(i){const e=(i-ce)/Vt;let t,s,r;for(t=i-ce,s=0;t%Vt===be;t/=Vt,s++);for(r=Vt;r<i&&El(r,e,i)!==i-ce;r++)if(r>1e3)throw new Error("Cannot find square root: likely non-prime P");if(s===1){const o=(i+ce)/vn;return function(a,c){const h=a.pow(c,o);if(!a.eql(a.sqr(h),c))throw new Error("Cannot find square root");return h}}const n=(t+ce)/Vt;return function(o,a){if(o.pow(a,e)===o.neg(o.ONE))throw new Error("Cannot find square root");let c=s,h=o.pow(o.mul(o.ONE,r),t),l=o.pow(a,n),u=o.pow(a,t);for(;!o.eql(u,o.ONE);){if(o.eql(u,o.ZERO))return o.ZERO;let d=1;for(let p=o.sqr(u);d<c&&!o.eql(p,o.ONE);d++)p=o.sqr(p);const f=o.pow(h,ce<<BigInt(c-d-1));h=o.sqr(f),l=o.mul(l,f),u=o.mul(u,h),c=d}return l}}function Jw(i){if(i%vn===Ww){const e=(i+ce)/vn;return function(t,s){const r=t.pow(s,e);if(!t.eql(t.sqr(r),s))throw new Error("Cannot find square root");return r}}if(i%Ma===La){const e=(i-La)/Ma;return function(t,s){const r=t.mul(s,Vt),n=t.pow(r,e),o=t.mul(s,n),a=t.mul(t.mul(o,Vt),n),c=t.mul(o,t.sub(a,t.ONE));if(!t.eql(t.sqr(c),s))throw new Error("Cannot find square root");return c}}return Gw(i)}const Yw=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Zw(i){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Yw.reduce((s,r)=>(s[r]="function",s),e);return Ki(i,t)}function Qw(i,e,t){if(t<be)throw new Error("invalid exponent, negatives unsupported");if(t===be)return i.ONE;if(t===ce)return e;let s=i.ONE,r=e;for(;t>be;)t&ce&&(s=i.mul(s,r)),r=i.sqr(r),t>>=ce;return s}function Xw(i,e){const t=new Array(e.length),s=e.reduce((n,o,a)=>i.is0(o)?n:(t[a]=n,i.mul(n,o)),i.ONE),r=i.inv(s);return e.reduceRight((n,o,a)=>i.is0(o)?n:(t[a]=i.mul(n,t[a]),i.mul(n,o)),r),t}function Il(i,e){const t=e!==void 0?e:i.toString(2).length,s=Math.ceil(t/8);return{nBitLength:t,nByteLength:s}}function $l(i,e,t=!1,s={}){if(i<=be)throw new Error("invalid field: expected ORDER > 0, got "+i);const{nBitLength:r,nByteLength:n}=Il(i,e);if(n>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:i,isLE:t,BITS:r,BYTES:n,MASK:ro(r),ZERO:be,ONE:ce,create:c=>ke(c,i),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return be<=c&&c<i},is0:c=>c===be,isOdd:c=>(c&ce)===ce,neg:c=>ke(-c,i),eql:(c,h)=>c===h,sqr:c=>ke(c*c,i),add:(c,h)=>ke(c+h,i),sub:(c,h)=>ke(c-h,i),mul:(c,h)=>ke(c*h,i),pow:(c,h)=>Qw(a,c,h),div:(c,h)=>ke(c*En(h,i),i),sqrN:c=>c*c,addN:(c,h)=>c+h,subN:(c,h)=>c-h,mulN:(c,h)=>c*h,inv:c=>En(c,i),sqrt:s.sqrt||(c=>(o||(o=Jw(i)),o(a,c))),invertBatch:c=>Xw(a,c),cmov:(c,h,l)=>l?h:c,toBytes:c=>t?fr(c,n):Ui(c,n),fromBytes:c=>{if(c.length!==n)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+c.length);return t?ds(c):Zt(c)}});return Object.freeze(a)}function _l(i){if(typeof i!="bigint")throw new Error("field order must be bigint");const e=i.toString(2).length;return Math.ceil(e/8)}function Pl(i){const e=_l(i);return e+Math.ceil(e/2)}function eb(i,e,t=!1){const s=i.length,r=_l(e),n=Pl(e);if(s<16||s<n||s>1024)throw new Error("expected "+n+"-1024 bytes of input, got "+s);const o=t?ds(i):Zt(i),a=ke(o,e-ce)+ce;return t?fr(a,r):Ui(a,r)}const Fa=BigInt(0),Ns=BigInt(1);function Lr(i,e){const t=e.negate();return i?t:e}function Sl(i,e){if(!Number.isSafeInteger(i)||i<=0||i>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+i)}function Mr(i,e){Sl(i,e);const t=Math.ceil(e/i)+1,s=2**(i-1);return{windows:t,windowSize:s}}function tb(i,e){if(!Array.isArray(i))throw new Error("array expected");i.forEach((t,s)=>{if(!(t instanceof e))throw new Error("invalid point at index "+s)})}function ib(i,e){if(!Array.isArray(i))throw new Error("array of scalars expected");i.forEach((t,s)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+s)})}const Fr=new WeakMap,xl=new WeakMap;function zr(i){return xl.get(i)||1}function sb(i,e){return{constTimeNegate:Lr,hasPrecomputes(t){return zr(t)!==1},unsafeLadder(t,s,r=i.ZERO){let n=t;for(;s>Fa;)s&Ns&&(r=r.add(n)),n=n.double(),s>>=Ns;return r},precomputeWindow(t,s){const{windows:r,windowSize:n}=Mr(s,e),o=[];let a=t,c=a;for(let h=0;h<r;h++){c=a,o.push(c);for(let l=1;l<n;l++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,s,r){const{windows:n,windowSize:o}=Mr(t,e);let a=i.ZERO,c=i.BASE;const h=BigInt(2**t-1),l=2**t,u=BigInt(t);for(let d=0;d<n;d++){const f=d*o;let p=Number(r&h);r>>=u,p>o&&(p-=l,r+=Ns);const g=f,y=f+Math.abs(p)-1,b=d%2!==0,m=p<0;p===0?c=c.add(Lr(b,s[g])):a=a.add(Lr(m,s[y]))}return{p:a,f:c}},wNAFUnsafe(t,s,r,n=i.ZERO){const{windows:o,windowSize:a}=Mr(t,e),c=BigInt(2**t-1),h=2**t,l=BigInt(t);for(let u=0;u<o;u++){const d=u*a;if(r===Fa)break;let f=Number(r&c);if(r>>=l,f>a&&(f-=h,r+=Ns),f===0)continue;let p=s[d+Math.abs(f)-1];f<0&&(p=p.negate()),n=n.add(p)}return n},getPrecomputes(t,s,r){let n=Fr.get(s);return n||(n=this.precomputeWindow(s,t),t!==1&&Fr.set(s,r(n))),n},wNAFCached(t,s,r){const n=zr(t);return this.wNAF(n,this.getPrecomputes(n,t,r),s)},wNAFCachedUnsafe(t,s,r,n){const o=zr(t);return o===1?this.unsafeLadder(t,s,n):this.wNAFUnsafe(o,this.getPrecomputes(o,t,r),s,n)},setWindowSize(t,s){Sl(s,e),xl.set(t,s),Fr.delete(t)}}}function rb(i,e,t,s){if(tb(t,i),ib(s,e),t.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const r=i.ZERO,n=bl(BigInt(t.length)),o=n>12?n-3:n>4?n-2:n?2:1,a=(1<<o)-1,c=new Array(a+1).fill(r),h=Math.floor((e.BITS-1)/o)*o;let l=r;for(let u=h;u>=0;u-=o){c.fill(r);for(let f=0;f<s.length;f++){const p=s[f],g=Number(p>>BigInt(u)&BigInt(a));c[g]=c[g].add(t[f])}let d=r;for(let f=c.length-1,p=r;f>0;f--)p=p.add(c[f]),d=d.add(p);if(l=l.add(d),u!==0)for(let f=0;f<o;f++)l=l.double()}return l}function Ol(i){return Zw(i.Fp),Ki(i,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Il(i.n,i.nBitLength),...i,p:i.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const pi=BigInt(0),Hr=BigInt(1);function nb(i){return Ki(i,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...i})}function ob(i){const e=nb(i),{P:t}=e,s=m=>ke(m,t),r=e.montgomeryBits,n=Math.ceil(r/8),o=e.nByteLength,a=e.adjustScalarBytes||(m=>m),c=e.powPminus2||(m=>El(m,t-BigInt(2),t));function h(m,w,$){const A=s(m*(w-$));return w=s(w-A),$=s($+A),[w,$]}const l=(e.a-BigInt(2))/BigInt(4);function u(m,w){Ot("u",m,pi,t),Ot("scalar",w,pi,t);const $=w,A=m;let S=Hr,x=pi,N=m,_=Hr,L=pi,j;for(let M=BigInt(r-1);M>=pi;M--){const C=$>>M&Hr;L^=C,j=h(L,S,N),S=j[0],N=j[1],j=h(L,x,_),x=j[0],_=j[1],L=C;const E=S+x,v=s(E*E),P=S-x,O=s(P*P),I=v-O,B=N+_,k=N-_,U=s(k*E),F=s(B*P),z=U+F,K=U-F;N=s(z*z),_=s(A*s(K*K)),S=s(v*O),x=s(I*(v+s(l*I)))}j=h(L,S,N),S=j[0],N=j[1],j=h(L,x,_),x=j[0],_=j[1];const q=c(x);return s(S*q)}function d(m){return fr(s(m),n)}function f(m){const w=Fe("u coordinate",m,n);return o===32&&(w[31]&=127),ds(w)}function p(m){const w=Fe("scalar",m),$=w.length;if($!==n&&$!==o){let A=""+n+" or "+o;throw new Error("invalid scalar, expected "+A+" bytes, got "+$)}return ds(a(w))}function g(m,w){const $=f(w),A=p(m),S=u($,A);if(S===pi)throw new Error("invalid private or public key received");return d(S)}const y=d(e.Gu);function b(m){return g(m,y)}return{scalarMult:g,scalarMultBase:b,getSharedSecret:(m,w)=>g(m,w),getPublicKey:m=>b(m),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:y}}const In=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const ab=BigInt(1),za=BigInt(2),cb=BigInt(3),hb=BigInt(5);BigInt(8);function lb(i){const e=BigInt(10),t=BigInt(20),s=BigInt(40),r=BigInt(80),n=In,o=i*i%n*i%n,a=ot(o,za,n)*o%n,c=ot(a,ab,n)*i%n,h=ot(c,hb,n)*c%n,l=ot(h,e,n)*h%n,u=ot(l,t,n)*l%n,d=ot(u,s,n)*u%n,f=ot(d,r,n)*d%n,p=ot(f,r,n)*d%n,g=ot(p,e,n)*h%n;return{pow_p_5_8:ot(g,za,n)*i%n,b2:o}}function ub(i){return i[0]&=248,i[31]&=127,i[31]|=64,i}const $n=ob({P:In,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:i=>{const e=In,{pow_p_5_8:t,b2:s}=lb(i);return ke(ot(t,cb,e)*s,e)},adjustScalarBytes:ub,randomBytes:Hi});function Ha(i){i.lowS!==void 0&&ji("lowS",i.lowS),i.prehash!==void 0&&ji("prehash",i.prehash)}function db(i){const e=Ol(i);Ki(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:s,a:r}=e;if(t){if(!s.eql(r,s.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:pb,hexToBytes:fb}=Vw;class gb extends Error{constructor(e=""){super(e)}}const St={Err:gb,_tlv:{encode:(i,e)=>{const{Err:t}=St;if(i<0||i>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const s=e.length/2,r=Oi(s);if(r.length/2&128)throw new t("tlv.encode: long form length too big");const n=s>127?Oi(r.length/2|128):"";return Oi(i)+n+r+e},decode(i,e){const{Err:t}=St;let s=0;if(i<0||i>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[s++]!==i)throw new t("tlv.decode: wrong tlv");const r=e[s++],n=!!(r&128);let o=0;if(!n)o=r;else{const c=r&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const h=e.subarray(s,s+c);if(h.length!==c)throw new t("tlv.decode: length bytes not complete");if(h[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const l of h)o=o<<8|l;if(s+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(s,s+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(s+o)}}},_int:{encode(i){const{Err:e}=St;if(i<xt)throw new e("integer: negative integers are not allowed");let t=Oi(i);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(i){const{Err:e}=St;if(i[0]&128)throw new e("invalid signature integer: negative");if(i[0]===0&&!(i[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return pb(i)}},toSig(i){const{Err:e,_int:t,_tlv:s}=St,r=typeof i=="string"?fb(i):i;vs(r);const{v:n,l:o}=s.decode(48,r);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=s.decode(2,n),{v:h,l}=s.decode(2,c);if(l.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(h)}},hexFromSig(i){const{_tlv:e,_int:t}=St,s=e.encode(2,t.encode(i.r)),r=e.encode(2,t.encode(i.s)),n=s+r;return e.encode(48,n)}},xt=BigInt(0),ye=BigInt(1);BigInt(2);const Ka=BigInt(3);BigInt(4);function yb(i){const e=db(i),{Fp:t}=e,s=$l(e.n,e.nBitLength),r=e.toBytes||((g,y,b)=>{const m=y.toAffine();return ps(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),n=e.fromBytes||(g=>{const y=g.subarray(1),b=t.fromBytes(y.subarray(0,t.BYTES)),m=t.fromBytes(y.subarray(t.BYTES,2*t.BYTES));return{x:b,y:m}});function o(g){const{a:y,b}=e,m=t.sqr(g),w=t.mul(m,g);return t.add(t.add(w,t.mul(g,y)),b)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(g){return gr(g,ye,e.n)}function c(g){const{allowedPrivateKeyLengths:y,nByteLength:b,wrapPrivateKey:m,n:w}=e;if(y&&typeof g!="bigint"){if(ii(g)&&(g=ki(g)),typeof g!="string"||!y.includes(g.length))throw new Error("invalid private key");g=g.padStart(b*2,"0")}let $;try{$=typeof g=="bigint"?g:Zt(Fe("private key",g,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof g)}return m&&($=ke($,w)),Ot("private key",$,ye,w),$}function h(g){if(!(g instanceof d))throw new Error("ProjectivePoint expected")}const l=bn((g,y)=>{const{px:b,py:m,pz:w}=g;if(t.eql(w,t.ONE))return{x:b,y:m};const $=g.is0();y==null&&(y=$?t.ONE:t.inv(w));const A=t.mul(b,y),S=t.mul(m,y),x=t.mul(w,y);if($)return{x:t.ZERO,y:t.ZERO};if(!t.eql(x,t.ONE))throw new Error("invZ was invalid");return{x:A,y:S}}),u=bn(g=>{if(g.is0()){if(e.allowInfinityPoint&&!t.is0(g.py))return;throw new Error("bad point: ZERO")}const{x:y,y:b}=g.toAffine();if(!t.isValid(y)||!t.isValid(b))throw new Error("bad point: x or y not FE");const m=t.sqr(b),w=o(y);if(!t.eql(m,w))throw new Error("bad point: equation left != right");if(!g.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(y,b,m){if(this.px=y,this.py=b,this.pz=m,y==null||!t.isValid(y))throw new Error("x required");if(b==null||!t.isValid(b))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(y){const{x:b,y:m}=y||{};if(!y||!t.isValid(b)||!t.isValid(m))throw new Error("invalid affine point");if(y instanceof d)throw new Error("projective point not allowed");const w=$=>t.eql($,t.ZERO);return w(b)&&w(m)?d.ZERO:new d(b,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){const b=t.invertBatch(y.map(m=>m.pz));return y.map((m,w)=>m.toAffine(b[w])).map(d.fromAffine)}static fromHex(y){const b=d.fromAffine(n(Fe("pointHex",y)));return b.assertValidity(),b}static fromPrivateKey(y){return d.BASE.multiply(c(y))}static msm(y,b){return rb(d,s,y,b)}_setWindowSize(y){p.setWindowSize(this,y)}assertValidity(){u(this)}hasEvenY(){const{y}=this.toAffine();if(t.isOdd)return!t.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(y){h(y);const{px:b,py:m,pz:w}=this,{px:$,py:A,pz:S}=y,x=t.eql(t.mul(b,S),t.mul($,w)),N=t.eql(t.mul(m,S),t.mul(A,w));return x&&N}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){const{a:y,b}=e,m=t.mul(b,Ka),{px:w,py:$,pz:A}=this;let S=t.ZERO,x=t.ZERO,N=t.ZERO,_=t.mul(w,w),L=t.mul($,$),j=t.mul(A,A),q=t.mul(w,$);return q=t.add(q,q),N=t.mul(w,A),N=t.add(N,N),S=t.mul(y,N),x=t.mul(m,j),x=t.add(S,x),S=t.sub(L,x),x=t.add(L,x),x=t.mul(S,x),S=t.mul(q,S),N=t.mul(m,N),j=t.mul(y,j),q=t.sub(_,j),q=t.mul(y,q),q=t.add(q,N),N=t.add(_,_),_=t.add(N,_),_=t.add(_,j),_=t.mul(_,q),x=t.add(x,_),j=t.mul($,A),j=t.add(j,j),_=t.mul(j,q),S=t.sub(S,_),N=t.mul(j,L),N=t.add(N,N),N=t.add(N,N),new d(S,x,N)}add(y){h(y);const{px:b,py:m,pz:w}=this,{px:$,py:A,pz:S}=y;let x=t.ZERO,N=t.ZERO,_=t.ZERO;const L=e.a,j=t.mul(e.b,Ka);let q=t.mul(b,$),M=t.mul(m,A),C=t.mul(w,S),E=t.add(b,m),v=t.add($,A);E=t.mul(E,v),v=t.add(q,M),E=t.sub(E,v),v=t.add(b,w);let P=t.add($,S);return v=t.mul(v,P),P=t.add(q,C),v=t.sub(v,P),P=t.add(m,w),x=t.add(A,S),P=t.mul(P,x),x=t.add(M,C),P=t.sub(P,x),_=t.mul(L,v),x=t.mul(j,C),_=t.add(x,_),x=t.sub(M,_),_=t.add(M,_),N=t.mul(x,_),M=t.add(q,q),M=t.add(M,q),C=t.mul(L,C),v=t.mul(j,v),M=t.add(M,C),C=t.sub(q,C),C=t.mul(L,C),v=t.add(v,C),q=t.mul(M,v),N=t.add(N,q),q=t.mul(P,v),x=t.mul(E,x),x=t.sub(x,q),q=t.mul(E,M),_=t.mul(P,_),_=t.add(_,q),new d(x,N,_)}subtract(y){return this.add(y.negate())}is0(){return this.equals(d.ZERO)}wNAF(y){return p.wNAFCached(this,y,d.normalizeZ)}multiplyUnsafe(y){const{endo:b,n:m}=e;Ot("scalar",y,xt,m);const w=d.ZERO;if(y===xt)return w;if(this.is0()||y===ye)return this;if(!b||p.hasPrecomputes(this))return p.wNAFCachedUnsafe(this,y,d.normalizeZ);let{k1neg:$,k1:A,k2neg:S,k2:x}=b.splitScalar(y),N=w,_=w,L=this;for(;A>xt||x>xt;)A&ye&&(N=N.add(L)),x&ye&&(_=_.add(L)),L=L.double(),A>>=ye,x>>=ye;return $&&(N=N.negate()),S&&(_=_.negate()),_=new d(t.mul(_.px,b.beta),_.py,_.pz),N.add(_)}multiply(y){const{endo:b,n:m}=e;Ot("scalar",y,ye,m);let w,$;if(b){const{k1neg:A,k1:S,k2neg:x,k2:N}=b.splitScalar(y);let{p:_,f:L}=this.wNAF(S),{p:j,f:q}=this.wNAF(N);_=p.constTimeNegate(A,_),j=p.constTimeNegate(x,j),j=new d(t.mul(j.px,b.beta),j.py,j.pz),w=_.add(j),$=L.add(q)}else{const{p:A,f:S}=this.wNAF(y);w=A,$=S}return d.normalizeZ([w,$])[0]}multiplyAndAddUnsafe(y,b,m){const w=d.BASE,$=(S,x)=>x===xt||x===ye||!S.equals(w)?S.multiplyUnsafe(x):S.multiply(x),A=$(this,b).add($(y,m));return A.is0()?void 0:A}toAffine(y){return l(this,y)}isTorsionFree(){const{h:y,isTorsionFree:b}=e;if(y===ye)return!0;if(b)return b(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:y,clearCofactor:b}=e;return y===ye?this:b?b(d,this):this.multiplyUnsafe(e.h)}toRawBytes(y=!0){return ji("isCompressed",y),this.assertValidity(),r(d,this,y)}toHex(y=!0){return ji("isCompressed",y),ki(this.toRawBytes(y))}}d.BASE=new d(e.Gx,e.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);const f=e.nBitLength,p=sb(d,e.endo?Math.ceil(f/2):f);return{CURVE:e,ProjectivePoint:d,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function mb(i){const e=Ol(i);return Ki(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function wb(i){const e=mb(i),{Fp:t,n:s}=e,r=t.BYTES+1,n=2*t.BYTES+1;function o(C){return ke(C,s)}function a(C){return En(C,s)}const{ProjectivePoint:c,normPrivateKeyToScalar:h,weierstrassEquation:l,isWithinCurveOrder:u}=yb({...e,toBytes(C,E,v){const P=E.toAffine(),O=t.toBytes(P.x),I=ps;return ji("isCompressed",v),v?I(Uint8Array.from([E.hasEvenY()?2:3]),O):I(Uint8Array.from([4]),O,t.toBytes(P.y))},fromBytes(C){const E=C.length,v=C[0],P=C.subarray(1);if(E===r&&(v===2||v===3)){const O=Zt(P);if(!gr(O,ye,t.ORDER))throw new Error("Point is not on curve");const I=l(O);let B;try{B=t.sqrt(I)}catch(U){const F=U instanceof Error?": "+U.message:"";throw new Error("Point is not on curve"+F)}const k=(B&ye)===ye;return(v&1)===1!==k&&(B=t.neg(B)),{x:O,y:B}}else if(E===n&&v===4){const O=t.fromBytes(P.subarray(0,t.BYTES)),I=t.fromBytes(P.subarray(t.BYTES,2*t.BYTES));return{x:O,y:I}}else{const O=r,I=n;throw new Error("invalid Point, expected length of "+O+", or uncompressed "+I+", got "+E)}}}),d=C=>ki(Ui(C,e.nByteLength));function f(C){const E=s>>ye;return C>E}function p(C){return f(C)?o(-C):C}const g=(C,E,v)=>Zt(C.slice(E,v));class y{constructor(E,v,P){this.r=E,this.s=v,this.recovery=P,this.assertValidity()}static fromCompact(E){const v=e.nByteLength;return E=Fe("compactSignature",E,v*2),new y(g(E,0,v),g(E,v,2*v))}static fromDER(E){const{r:v,s:P}=St.toSig(Fe("DER",E));return new y(v,P)}assertValidity(){Ot("r",this.r,ye,s),Ot("s",this.s,ye,s)}addRecoveryBit(E){return new y(this.r,this.s,E)}recoverPublicKey(E){const{r:v,s:P,recovery:O}=this,I=S(Fe("msgHash",E));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const B=O===2||O===3?v+e.n:v;if(B>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const k=O&1?"03":"02",U=c.fromHex(k+d(B)),F=a(B),z=o(-I*F),K=o(P*F),G=c.BASE.multiplyAndAddUnsafe(U,z,K);if(!G)throw new Error("point at infinify");return G.assertValidity(),G}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new y(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return qi(this.toDERHex())}toDERHex(){return St.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return qi(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const b={isValidPrivateKey(C){try{return h(C),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const C=Pl(e.n);return eb(e.randomBytes(C),e.n)},precompute(C=8,E=c.BASE){return E._setWindowSize(C),E.multiply(BigInt(3)),E}};function m(C,E=!0){return c.fromPrivateKey(C).toRawBytes(E)}function w(C){const E=ii(C),v=typeof C=="string",P=(E||v)&&C.length;return E?P===r||P===n:v?P===2*r||P===2*n:C instanceof c}function $(C,E,v=!0){if(w(C))throw new Error("first arg must be private key");if(!w(E))throw new Error("second arg must be public key");return c.fromHex(E).multiply(h(C)).toRawBytes(v)}const A=e.bits2int||function(C){if(C.length>8192)throw new Error("input is too large");const E=Zt(C),v=C.length*8-e.nBitLength;return v>0?E>>BigInt(v):E},S=e.bits2int_modN||function(C){return o(A(C))},x=ro(e.nBitLength);function N(C){return Ot("num < 2^"+e.nBitLength,C,xt,x),Ui(C,e.nByteLength)}function _(C,E,v=L){if(["recovered","canonical"].some(ee=>ee in v))throw new Error("sign() legacy options not supported");const{hash:P,randomBytes:O}=e;let{lowS:I,prehash:B,extraEntropy:k}=v;I==null&&(I=!0),C=Fe("msgHash",C),Ha(v),B&&(C=Fe("prehashed msgHash",P(C)));const U=S(C),F=h(E),z=[N(F),N(U)];if(k!=null&&k!==!1){const ee=k===!0?O(t.BYTES):k;z.push(Fe("extraEntropy",ee))}const K=ps(...z),G=U;function re(ee){const J=A(ee);if(!u(J))return;const xe=a(J),ve=c.BASE.multiply(J).toAffine(),Ae=o(ve.x);if(Ae===xt)return;const We=o(xe*o(G+Ae*F));if(We===xt)return;let vt=(ve.x===Ae?0:2)|Number(ve.y&ye),hi=We;return I&&f(We)&&(hi=p(We),vt^=1),new y(Ae,hi,vt)}return{seed:K,k2sig:re}}const L={lowS:e.lowS,prehash:!1},j={lowS:e.lowS,prehash:!1};function q(C,E,v=L){const{seed:P,k2sig:O}=_(C,E,v),I=e;return vl(I.hash.outputLen,I.nByteLength,I.hmac)(P,O)}c.BASE._setWindowSize(8);function M(C,E,v,P=j){const O=C;E=Fe("msgHash",E),v=Fe("publicKey",v);const{lowS:I,prehash:B,format:k}=P;if(Ha(P),"strict"in P)throw new Error("options.strict was renamed to lowS");if(k!==void 0&&k!=="compact"&&k!=="der")throw new Error("format must be compact or der");const U=typeof O=="string"||ii(O),F=!U&&!k&&typeof O=="object"&&O!==null&&typeof O.r=="bigint"&&typeof O.s=="bigint";if(!U&&!F)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let z,K;try{if(F&&(z=new y(O.r,O.s)),U){try{k!=="compact"&&(z=y.fromDER(O))}catch(We){if(!(We instanceof St.Err))throw We}!z&&k!=="der"&&(z=y.fromCompact(O))}K=c.fromHex(v)}catch{return!1}if(!z||I&&z.hasHighS())return!1;B&&(E=e.hash(E));const{r:G,s:re}=z,ee=S(E),J=a(re),xe=o(ee*J),ve=o(G*J),Ae=c.BASE.multiplyAndAddUnsafe(K,xe,ve)?.toAffine();return Ae?o(Ae.x)===G:!1}return{CURVE:e,getPublicKey:m,getSharedSecret:$,sign:q,verify:M,ProjectivePoint:c,Signature:y,utils:b}}function bb(i){return{hash:i,hmac:(e,...t)=>ur(i,e,$m(...t)),randomBytes:Hi}}function vb(i,e){const t=s=>wb({...i,...bb(s)});return{...t(e),create:t}}const Al=$l(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),Eb=Al.create(BigInt("-3")),Ib=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),$b=vb({a:Eb,b:Ib,Fp:Al,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},bs),Cl="base10",Re="base16",at="base64pad",Dt="base64url",Es="utf8",Rl=0,At=1,Is=2,_b=0,Va=1,os=12,no=32;function Pb(){const i=$n.utils.randomPrivateKey(),e=$n.getPublicKey(i);return{privateKey:qe(i,Re),publicKey:qe(e,Re)}}function _n(){const i=Hi(no);return qe(i,Re)}function Sb(i,e){const t=$n.getSharedSecret(Qe(i,Re),Qe(e,Re)),s=Cw(bs,t,void 0,void 0,no);return qe(s,Re)}function Hs(i){const e=bs(Qe(i,Re));return qe(e,Re)}function mt(i){const e=bs(Qe(i,Es));return qe(e,Re)}function Nl(i){return Qe(`${i}`,Cl)}function si(i){return Number(qe(i,Cl))}function Tl(i){return i.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function Bl(i){const e=i.replace(/-/g,"+").replace(/_/g,"/"),t=(4-e.length%4)%4;return e+"=".repeat(t)}function xb(i){const e=Nl(typeof i.type<"u"?i.type:Rl);if(si(e)===At&&typeof i.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const t=typeof i.senderPublicKey<"u"?Qe(i.senderPublicKey,Re):void 0,s=typeof i.iv<"u"?Qe(i.iv,Re):Hi(os),r=Qe(i.symKey,Re),n=ml(r,s).encrypt(Qe(i.message,Es)),o=Dl({type:e,sealed:n,iv:s,senderPublicKey:t});return i.encoding===Dt?Tl(o):o}function Ob(i){const e=Qe(i.symKey,Re),{sealed:t,iv:s}=fs({encoded:i.encoded,encoding:i.encoding}),r=ml(e,s).decrypt(t);if(r===null)throw new Error("Failed to decrypt");return qe(r,Es)}function Ab(i,e){const t=Nl(Is),s=Hi(os),r=Qe(i,Es),n=Dl({type:t,sealed:r,iv:s});return e===Dt?Tl(n):n}function Cb(i,e){const{sealed:t}=fs({encoded:i,encoding:e});return qe(t,Es)}function Dl(i){if(si(i.type)===Is)return qe(rs([i.type,i.sealed]),at);if(si(i.type)===At){if(typeof i.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return qe(rs([i.type,i.senderPublicKey,i.iv,i.sealed]),at)}return qe(rs([i.type,i.iv,i.sealed]),at)}function fs(i){const e=(i.encoding||at)===Dt?Bl(i.encoded):i.encoded,t=Qe(e,at),s=t.slice(_b,Va),r=Va;if(si(s)===At){const c=r+no,h=c+os,l=t.slice(r,c),u=t.slice(c,h),d=t.slice(h);return{type:s,sealed:d,iv:u,senderPublicKey:l}}if(si(s)===Is){const c=t.slice(r),h=Hi(os);return{type:s,sealed:c,iv:h}}const n=r+os,o=t.slice(r,n),a=t.slice(n);return{type:s,sealed:a,iv:o}}function Rb(i,e){const t=fs({encoded:i,encoding:e?.encoding});return jl({type:si(t.type),senderPublicKey:typeof t.senderPublicKey<"u"?qe(t.senderPublicKey,Re):void 0,receiverPublicKey:e?.receiverPublicKey})}function jl(i){const e=i?.type||Rl;if(e===At){if(typeof i?.senderPublicKey>"u")throw new Error("missing sender public key");if(typeof i?.receiverPublicKey>"u")throw new Error("missing receiver public key")}return{type:e,senderPublicKey:i?.senderPublicKey,receiverPublicKey:i?.receiverPublicKey}}function Wa(i){return i.type===At&&typeof i.senderPublicKey=="string"&&typeof i.receiverPublicKey=="string"}function Ga(i){return i.type===Is}function Nb(i){const e=Buffer.from(i.x,"base64"),t=Buffer.from(i.y,"base64");return rs([new Uint8Array([4]),e,t])}function Tb(i,e){const[t,s,r]=i.split("."),n=Buffer.from(Bl(r),"base64");if(n.length!==64)throw new Error("Invalid signature length");const o=n.slice(0,32),a=n.slice(32,64),c=`${t}.${s}`,h=bs(c),l=Nb(e);if(!$b.verify(rs([o,a]),h,l))throw new Error("Invalid signature");return dn(i).payload}const Bb="irn";function Qs(i){return i?.relay||{protocol:Bb}}function is(i){const e=ed[i];if(typeof e>"u")throw new Error(`Relay Protocol not supported: ${i}`);return e}function Db(i,e="-"){const t={},s="relay"+e;return Object.keys(i).forEach(r=>{if(r.startsWith(s)){const n=r.replace(s,""),o=i[r];t[n]=o}}),t}function Ja(i){if(!i.includes("wc:")){const h=rl(i);h!=null&&h.includes("wc:")&&(i=h)}i=i.includes("wc://")?i.replace("wc://",""):i,i=i.includes("wc:")?i.replace("wc:",""):i;const e=i.indexOf(":"),t=i.indexOf("?")!==-1?i.indexOf("?"):void 0,s=i.substring(0,e),r=i.substring(e+1,t).split("@"),n=typeof t<"u"?i.substring(t):"",o=new URLSearchParams(n),a={};o.forEach((h,l)=>{a[l]=h});const c=typeof a.methods=="string"?a.methods.split(","):void 0;return{protocol:s,topic:jb(r[0]),version:parseInt(r[1],10),symKey:a.symKey,relay:Db(a),methods:c,expiryTimestamp:a.expiryTimestamp?parseInt(a.expiryTimestamp,10):void 0}}function jb(i){return i.startsWith("//")?i.substring(2):i}function kb(i,e="-"){const t="relay",s={};return Object.keys(i).forEach(r=>{const n=r,o=t+e+n;i[n]&&(s[o]=i[n])}),s}function Ya(i){const e=new URLSearchParams,t=kb(i.relay);Object.keys(t).sort().forEach(r=>{e.set(r,t[r])}),e.set("symKey",i.symKey),i.expiryTimestamp&&e.set("expiryTimestamp",i.expiryTimestamp.toString()),i.methods&&e.set("methods",i.methods.join(","));const s=e.toString();return`${i.protocol}:${i.topic}@${i.version}?${s}`}function Ts(i,e,t){return`${i}?wc_ev=${t}&topic=${e}`}var qb=Object.defineProperty,Ub=Object.defineProperties,Lb=Object.getOwnPropertyDescriptors,Za=Object.getOwnPropertySymbols,Mb=Object.prototype.hasOwnProperty,Fb=Object.prototype.propertyIsEnumerable,Qa=(i,e,t)=>e in i?qb(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,zb=(i,e)=>{for(var t in e||(e={}))Mb.call(e,t)&&Qa(i,t,e[t]);if(Za)for(var t of Za(e))Fb.call(e,t)&&Qa(i,t,e[t]);return i},Hb=(i,e)=>Ub(i,Lb(e));function Vi(i){const e=[];return i.forEach(t=>{const[s,r]=t.split(":");e.push(`${s}:${r}`)}),e}function Kb(i){const e=[];return Object.values(i).forEach(t=>{e.push(...Vi(t.accounts))}),e}function Vb(i,e){const t=[];return Object.values(i).forEach(s=>{Vi(s.accounts).includes(e)&&t.push(...s.methods)}),t}function Wb(i,e){const t=[];return Object.values(i).forEach(s=>{Vi(s.accounts).includes(e)&&t.push(...s.events)}),t}function yr(i){return i.includes(":")}function Ai(i){return yr(i)?i.split(":")[0]:i}function Xa(i){var e,t,s;const r={};if(!Ut(i))return r;for(const[n,o]of Object.entries(i)){const a=yr(n)?[n]:o.chains,c=o.methods||[],h=o.events||[],l=Ai(n);r[l]=Hb(zb({},r[l]),{chains:wt(a,(e=r[l])==null?void 0:e.chains),methods:wt(c,(t=r[l])==null?void 0:t.methods),events:wt(h,(s=r[l])==null?void 0:s.events)})}return r}function Gb(i){const e={};return i?.forEach(t=>{var s;const[r,n]=t.split(":");e[r]||(e[r]={accounts:[],chains:[],events:[],methods:[]}),e[r].accounts.push(t),(s=e[r].chains)==null||s.push(`${r}:${n}`)}),e}function ec(i,e){e=e.map(s=>s.replace("did:pkh:",""));const t=Gb(e);for(const[s,r]of Object.entries(t))r.methods?r.methods=wt(r.methods,i):r.methods=i,r.events=["chainChanged","accountsChanged"];return t}function Jb(i,e){var t,s,r,n,o,a;const c=Xa(i),h=Xa(e),l={},u=Object.keys(c).concat(Object.keys(h));for(const d of u)l[d]={chains:wt((t=c[d])==null?void 0:t.chains,(s=h[d])==null?void 0:s.chains),methods:wt((r=c[d])==null?void 0:r.methods,(n=h[d])==null?void 0:n.methods),events:wt((o=c[d])==null?void 0:o.events,(a=h[d])==null?void 0:a.events)};return l}const Yb={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},Zb={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function D(i,e){const{message:t,code:s}=Zb[i];return{message:e?`${t} ${e}`:t,code:s}}function te(i,e){const{message:t,code:s}=Yb[i];return{message:e?`${t} ${e}`:t,code:s}}function ct(i,e){return!!Array.isArray(i)}function Ut(i){return Object.getPrototypeOf(i)===Object.prototype&&Object.keys(i).length}function _e(i){return typeof i>"u"}function le(i,e){return e&&_e(i)?!0:typeof i=="string"&&!!i.trim().length}function oo(i,e){return e&&_e(i)?!0:typeof i=="number"&&!isNaN(i)}function Qb(i,e){const{requiredNamespaces:t}=e,s=Object.keys(i.namespaces),r=Object.keys(t);let n=!0;return Yt(r,s)?(s.forEach(o=>{const{accounts:a,methods:c,events:h}=i.namespaces[o],l=Vi(a),u=t[o];(!Yt(Xh(o,u),l)||!Yt(u.methods,c)||!Yt(u.events,h))&&(n=!1)}),n):!1}function Xs(i){return le(i,!1)&&i.includes(":")?i.split(":").length===2:!1}function Xb(i){if(le(i,!1)&&i.includes(":")){const e=i.split(":");if(e.length===3){const t=e[0]+":"+e[1];return!!e[2]&&Xs(t)}}return!1}function ev(i){function e(t){try{return typeof new URL(t)<"u"}catch{return!1}}try{if(le(i,!1)){if(e(i))return!0;const t=rl(i);return e(t)}}catch{}return!1}function tv(i){var e;return(e=i?.proposer)==null?void 0:e.publicKey}function iv(i){return i?.topic}function sv(i,e){let t=null;return le(i?.publicKey,!1)||(t=D("MISSING_OR_INVALID",`${e} controller public key should be a string`)),t}function tc(i){let e=!0;return ct(i)?i.length&&(e=i.every(t=>le(t,!1))):e=!1,e}function rv(i,e,t){let s=null;return ct(e)&&e.length?e.forEach(r=>{s||Xs(r)||(s=te("UNSUPPORTED_CHAINS",`${t}, chain ${r} should be a string and conform to "namespace:chainId" format`))}):Xs(i)||(s=te("UNSUPPORTED_CHAINS",`${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),s}function nv(i,e,t){let s=null;return Object.entries(i).forEach(([r,n])=>{if(s)return;const o=rv(r,Xh(r,n),`${e} ${t}`);o&&(s=o)}),s}function ov(i,e){let t=null;return ct(i)?i.forEach(s=>{t||Xb(s)||(t=te("UNSUPPORTED_ACCOUNTS",`${e}, account ${s} should be a string and conform to "namespace:chainId:address" format`))}):t=te("UNSUPPORTED_ACCOUNTS",`${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),t}function av(i,e){let t=null;return Object.values(i).forEach(s=>{if(t)return;const r=ov(s?.accounts,`${e} namespace`);r&&(t=r)}),t}function cv(i,e){let t=null;return tc(i?.methods)?tc(i?.events)||(t=te("UNSUPPORTED_EVENTS",`${e}, events should be an array of strings or empty array for no events`)):t=te("UNSUPPORTED_METHODS",`${e}, methods should be an array of strings or empty array for no methods`),t}function kl(i,e){let t=null;return Object.values(i).forEach(s=>{if(t)return;const r=cv(s,`${e}, namespace`);r&&(t=r)}),t}function hv(i,e,t){let s=null;if(i&&Ut(i)){const r=kl(i,e);r&&(s=r);const n=nv(i,e,t);n&&(s=n)}else s=D("MISSING_OR_INVALID",`${e}, ${t} should be an object with data`);return s}function Kr(i,e){let t=null;if(i&&Ut(i)){const s=kl(i,e);s&&(t=s);const r=av(i,e);r&&(t=r)}else t=D("MISSING_OR_INVALID",`${e}, namespaces should be an object with data`);return t}function ql(i){return le(i.protocol,!0)}function lv(i,e){let t=!1;return i?i&&ct(i)&&i.length&&i.forEach(s=>{t=ql(s)}):t=!0,t}function uv(i){return typeof i=="number"}function je(i){return typeof i<"u"&&typeof i!==null}function dv(i){return!(!i||typeof i!="object"||!i.code||!oo(i.code,!1)||!i.message||!le(i.message,!1))}function pv(i){return!(_e(i)||!le(i.method,!1))}function fv(i){return!(_e(i)||_e(i.result)&&_e(i.error)||!oo(i.id,!1)||!le(i.jsonrpc,!1))}function gv(i){return!(_e(i)||!le(i.name,!1))}function ic(i,e){return!(!Xs(e)||!Kb(i).includes(e))}function yv(i,e,t){return le(t,!1)?Vb(i,e).includes(t):!1}function mv(i,e,t){return le(t,!1)?Wb(i,e).includes(t):!1}function sc(i,e,t){let s=null;const r=wv(i),n=bv(e),o=Object.keys(r),a=Object.keys(n),c=rc(Object.keys(i)),h=rc(Object.keys(e)),l=c.filter(u=>!h.includes(u));return l.length&&(s=D("NON_CONFORMING_NAMESPACES",`${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(e).toString()}`)),Yt(o,a)||(s=D("NON_CONFORMING_NAMESPACES",`${t} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)),Object.keys(e).forEach(u=>{if(!u.includes(":")||s)return;const d=Vi(e[u].accounts);d.includes(u)||(s=D("NON_CONFORMING_NAMESPACES",`${t} namespaces accounts don't satisfy namespace accounts for ${u}
        Required: ${u}
        Approved: ${d.toString()}`))}),o.forEach(u=>{s||(Yt(r[u].methods,n[u].methods)?Yt(r[u].events,n[u].events)||(s=D("NON_CONFORMING_NAMESPACES",`${t} namespaces events don't satisfy namespace events for ${u}`)):s=D("NON_CONFORMING_NAMESPACES",`${t} namespaces methods don't satisfy namespace methods for ${u}`))}),s}function wv(i){const e={};return Object.keys(i).forEach(t=>{var s;t.includes(":")?e[t]=i[t]:(s=i[t].chains)==null||s.forEach(r=>{e[r]={methods:i[t].methods,events:i[t].events}})}),e}function rc(i){return[...new Set(i.map(e=>e.includes(":")?e.split(":")[0]:e))]}function bv(i){const e={};return Object.keys(i).forEach(t=>{t.includes(":")?e[t]=i[t]:Vi(i[t].accounts)?.forEach(r=>{e[r]={accounts:i[t].accounts.filter(n=>n.includes(`${r}:`)),methods:i[t].methods,events:i[t].events}})}),e}function vv(i,e){return oo(i,!1)&&i<=e.max&&i>=e.min}function nc(){const i=ms();return new Promise(e=>{switch(i){case He.browser:e(Ev());break;case He.reactNative:e(Iv());break;case He.node:e($v());break;default:e(!0)}})}function Ev(){return zi()&&navigator?.onLine}async function Iv(){return Lt()&&typeof global<"u"&&global!=null&&global.NetInfo?(await(global==null?void 0:global.NetInfo.fetch()))?.isConnected:!0}function $v(){return!0}function _v(i){switch(ms()){case He.browser:Pv(i);break;case He.reactNative:Sv(i);break}}function Pv(i){!Lt()&&zi()&&(window.addEventListener("online",()=>i(!0)),window.addEventListener("offline",()=>i(!1)))}function Sv(i){Lt()&&typeof global<"u"&&global!=null&&global.NetInfo&&global?.NetInfo.addEventListener(e=>i(e?.isConnected))}function xv(){var i;return zi()&&Ni()?((i=Ni())==null?void 0:i.visibilityState)==="visible":!0}const Vr={};class Yi{static get(e){return Vr[e]}static set(e,t){Vr[e]=t}static delete(e){delete Vr[e]}}var Ov=Object.defineProperty,Av=(i,e,t)=>e in i?Ov(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,oc=(i,e,t)=>Av(i,typeof e!="symbol"?e+"":e,t);let Cv=class extends ni{constructor(e){super(),this.opts=e,oc(this,"protocol","wc"),oc(this,"version",2)}};var Rv=Object.defineProperty,Nv=(i,e,t)=>e in i?Rv(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Tv=(i,e,t)=>Nv(i,e+"",t);let Bv=class extends ni{constructor(e,t){super(),this.core=e,this.logger=t,Tv(this,"records",new Map)}},Dv=class{constructor(e,t){this.logger=e,this.core=t}};class jv extends ni{constructor(e,t){super(),this.relayer=e,this.logger=t}}let kv=class extends ni{constructor(e){super()}},qv=class{constructor(e,t,s,r){this.core=e,this.logger=t,this.name=s}},Uv=class extends ni{constructor(e,t){super(),this.relayer=e,this.logger=t}},Lv=class extends ni{constructor(e,t){super(),this.core=e,this.logger=t}},Mv=class{constructor(e,t,s){this.core=e,this.logger=t,this.store=s}},Fv=class{constructor(e,t){this.projectId=e,this.logger=t}},zv=class{constructor(e,t,s){this.core=e,this.logger=t,this.telemetryEnabled=s}};var Hv=Object.defineProperty,Kv=(i,e,t)=>e in i?Hv(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ac=(i,e,t)=>Kv(i,typeof e!="symbol"?e+"":e,t);let Vv=class{constructor(e){this.opts=e,ac(this,"protocol","wc"),ac(this,"version",2)}},Wv=class{constructor(e){this.client=e}};const Gv=()=>typeof WebSocket<"u"?WebSocket:typeof global<"u"&&typeof global.WebSocket<"u"?global.WebSocket:typeof window<"u"&&typeof window.WebSocket<"u"?window.WebSocket:typeof self<"u"&&typeof self.WebSocket<"u"?self.WebSocket:Zd(),Jv=()=>typeof WebSocket<"u"||typeof global<"u"&&typeof global.WebSocket<"u"||typeof window<"u"&&typeof window.WebSocket<"u"||typeof self<"u"&&typeof self.WebSocket<"u",cc=i=>i.split("?")[0],hc=10,Yv=Gv();let Zv=class{constructor(e){if(this.url=e,this.events=new Xe.EventEmitter,this.registering=!1,!Ro(e))throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);this.url=e}get connected(){return typeof this.socket<"u"}get connecting(){return this.registering}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async open(e=this.url){await this.register(e)}async close(){return new Promise((e,t)=>{if(typeof this.socket>"u"){t(new Error("Connection already closed"));return}this.socket.onclose=s=>{this.onClose(s),e()},this.socket.close()})}async send(e){typeof this.socket>"u"&&(this.socket=await this.register());try{this.socket.send(Xt(e))}catch(t){this.onError(e.id,t)}}register(e=this.url){if(!Ro(e))throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);if(this.registering){const t=this.events.getMaxListeners();return(this.events.listenerCount("register_error")>=t||this.events.listenerCount("open")>=t)&&this.events.setMaxListeners(t+1),new Promise((s,r)=>{this.events.once("register_error",n=>{this.resetMaxListeners(),r(n)}),this.events.once("open",()=>{if(this.resetMaxListeners(),typeof this.socket>"u")return r(new Error("WebSocket connection is missing or invalid"));s(this.socket)})})}return this.url=e,this.registering=!0,new Promise((t,s)=>{const r=qu.isReactNative()?void 0:{rejectUnauthorized:!Yd(e)},n=new Yv(e,[],r);Jv()?n.onerror=o=>{const a=o;s(this.emitError(a.error))}:n.on("error",o=>{s(this.emitError(o))}),n.onopen=()=>{this.onOpen(n),t(n)}})}onOpen(e){e.onmessage=t=>this.onPayload(t),e.onclose=t=>this.onClose(t),this.socket=e,this.registering=!1,this.events.emit("open")}onClose(e){this.socket=void 0,this.registering=!1,this.events.emit("close",e)}onPayload(e){if(typeof e.data>"u")return;const t=typeof e.data=="string"?Qt(e.data):e.data;this.events.emit("payload",t)}onError(e,t){const s=this.parseError(t),r=s.message||s.toString(),n=nr(e,r);this.events.emit("payload",n)}parseError(e,t=this.url){return hh(e,cc(t),"WS")}resetMaxListeners(){this.events.getMaxListeners()>hc&&this.events.setMaxListeners(hc)}emitError(e){const t=this.parseError(new Error(e?.message||`WebSocket connection failed for host: ${cc(this.url)}`));return this.events.emit("register_error",t),t}};var Qv={};const Ul="wc",Ll=2,Pn="core",bt=`${Ul}@2:${Pn}:`,Xv={logger:"error"},e0={database:":memory:"},t0="crypto",lc="client_ed25519_seed",i0=T.ONE_DAY,s0="keychain",r0="0.3",n0="messages",o0="0.3",uc=T.SIX_HOURS,a0="publisher",Ml="irn",c0="error",Fl="wss://relay.walletconnect.org",h0="relayer",me={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},l0="_subscription",Ge={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},u0=.1,Sn="2.21.1",oe={link_mode:"link_mode",relay:"relay"},Ks={inbound:"inbound",outbound:"outbound"},d0="0.3",p0="WALLETCONNECT_CLIENT_ID",dc="WALLETCONNECT_LINK_MODE_APPS",Me={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},f0="subscription",g0="0.3",y0="pairing",m0="0.3",Zi={wc_pairingDelete:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:T.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:T.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:T.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:T.ONE_DAY,prompt:!1,tag:0},res:{ttl:T.ONE_DAY,prompt:!1,tag:0}}},Wt={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},st={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},w0="history",b0="0.3",v0="expirer",Ye={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},E0="0.3",I0="verify-api",$0="https://verify.walletconnect.com",zl="https://verify.walletconnect.org",as=zl,_0=`${as}/v3`,P0=[$0,zl],S0="echo",x0="https://echo.walletconnect.com",ft={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},Pt={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},rt={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},Mt={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},Ft={authenticated_session_approve_started:"authenticated_session_approve_started",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve"},Qi={no_internet_connection:"no_internet_connection",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"},O0=.1,A0="event-client",C0=86400,R0="https://pulse.walletconnect.org/batch";function N0(i,e){if(i.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),s=0;s<t.length;s++)t[s]=255;for(var r=0;r<i.length;r++){var n=i.charAt(r),o=n.charCodeAt(0);if(t[o]!==255)throw new TypeError(n+" is ambiguous");t[o]=r}var a=i.length,c=i.charAt(0),h=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function u(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var g=0,y=0,b=0,m=p.length;b!==m&&p[b]===0;)b++,g++;for(var w=(m-b)*l+1>>>0,$=new Uint8Array(w);b!==m;){for(var A=p[b],S=0,x=w-1;(A!==0||S<y)&&x!==-1;x--,S++)A+=256*$[x]>>>0,$[x]=A%a>>>0,A=A/a>>>0;if(A!==0)throw new Error("Non-zero carry");y=S,b++}for(var N=w-y;N!==w&&$[N]===0;)N++;for(var _=c.repeat(g);N<w;++N)_+=i.charAt($[N]);return _}function d(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var g=0;if(p[g]!==" "){for(var y=0,b=0;p[g]===c;)y++,g++;for(var m=(p.length-g)*h+1>>>0,w=new Uint8Array(m);p[g];){var $=t[p.charCodeAt(g)];if($===255)return;for(var A=0,S=m-1;($!==0||A<b)&&S!==-1;S--,A++)$+=a*w[S]>>>0,w[S]=$%256>>>0,$=$/256>>>0;if($!==0)throw new Error("Non-zero carry");b=A,g++}if(p[g]!==" "){for(var x=m-b;x!==m&&w[x]===0;)x++;for(var N=new Uint8Array(y+(m-x)),_=y;x!==m;)N[_++]=w[x++];return N}}}function f(p){var g=d(p);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:u,decodeUnsafe:d,decode:f}}var T0=N0,B0=T0;const Hl=i=>{if(i instanceof Uint8Array&&i.constructor.name==="Uint8Array")return i;if(i instanceof ArrayBuffer)return new Uint8Array(i);if(ArrayBuffer.isView(i))return new Uint8Array(i.buffer,i.byteOffset,i.byteLength);throw new Error("Unknown type, must be binary type")},D0=i=>new TextEncoder().encode(i),j0=i=>new TextDecoder().decode(i);class k0{constructor(e,t,s){this.name=e,this.prefix=t,this.baseEncode=s}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class q0{constructor(e,t,s){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=s}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Kl(this,e)}}class U0{constructor(e){this.decoders=e}or(e){return Kl(this,e)}decode(e){const t=e[0],s=this.decoders[t];if(s)return s.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Kl=(i,e)=>new U0({...i.decoders||{[i.prefix]:i},...e.decoders||{[e.prefix]:e}});class L0{constructor(e,t,s,r){this.name=e,this.prefix=t,this.baseEncode=s,this.baseDecode=r,this.encoder=new k0(e,t,s),this.decoder=new q0(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const mr=({name:i,prefix:e,encode:t,decode:s})=>new L0(i,e,t,s),$s=({prefix:i,name:e,alphabet:t})=>{const{encode:s,decode:r}=B0(t,e);return mr({prefix:i,name:e,encode:s,decode:n=>Hl(r(n))})},M0=(i,e,t,s)=>{const r={};for(let l=0;l<e.length;++l)r[e[l]]=l;let n=i.length;for(;i[n-1]==="=";)--n;const o=new Uint8Array(n*t/8|0);let a=0,c=0,h=0;for(let l=0;l<n;++l){const u=r[i[l]];if(u===void 0)throw new SyntaxError(`Non-${s} character`);c=c<<t|u,a+=t,a>=8&&(a-=8,o[h++]=255&c>>a)}if(a>=t||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return o},F0=(i,e,t)=>{const s=e[e.length-1]==="=",r=(1<<t)-1;let n="",o=0,a=0;for(let c=0;c<i.length;++c)for(a=a<<8|i[c],o+=8;o>t;)o-=t,n+=e[r&a>>o];if(o&&(n+=e[r&a<<t-o]),s)for(;n.length*t&7;)n+="=";return n},Se=({name:i,prefix:e,bitsPerChar:t,alphabet:s})=>mr({prefix:e,name:i,encode(r){return F0(r,s,t)},decode(r){return M0(r,s,t,i)}}),z0=mr({prefix:"\0",name:"identity",encode:i=>j0(i),decode:i=>D0(i)});var H0=Object.freeze({__proto__:null,identity:z0});const K0=Se({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var V0=Object.freeze({__proto__:null,base2:K0});const W0=Se({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var G0=Object.freeze({__proto__:null,base8:W0});const J0=$s({prefix:"9",name:"base10",alphabet:"0123456789"});var Y0=Object.freeze({__proto__:null,base10:J0});const Z0=Se({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Q0=Se({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var X0=Object.freeze({__proto__:null,base16:Z0,base16upper:Q0});const e1=Se({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),t1=Se({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),i1=Se({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),s1=Se({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),r1=Se({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),n1=Se({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),o1=Se({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),a1=Se({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),c1=Se({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var h1=Object.freeze({__proto__:null,base32:e1,base32upper:t1,base32pad:i1,base32padupper:s1,base32hex:r1,base32hexupper:n1,base32hexpad:o1,base32hexpadupper:a1,base32z:c1});const l1=$s({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),u1=$s({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var d1=Object.freeze({__proto__:null,base36:l1,base36upper:u1});const p1=$s({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),f1=$s({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var g1=Object.freeze({__proto__:null,base58btc:p1,base58flickr:f1});const y1=Se({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),m1=Se({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),w1=Se({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),b1=Se({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var v1=Object.freeze({__proto__:null,base64:y1,base64pad:m1,base64url:w1,base64urlpad:b1});const Vl=Array.from(""),E1=Vl.reduce((i,e,t)=>(i[t]=e,i),[]),I1=Vl.reduce((i,e,t)=>(i[e.codePointAt(0)]=t,i),[]);function $1(i){return i.reduce((e,t)=>(e+=E1[t],e),"")}function _1(i){const e=[];for(const t of i){const s=I1[t.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const P1=mr({prefix:"",name:"base256emoji",encode:$1,decode:_1});var S1=Object.freeze({__proto__:null,base256emoji:P1}),x1=Wl,pc=128,O1=-128,A1=Math.pow(2,31);function Wl(i,e,t){e=e||[],t=t||0;for(var s=t;i>=A1;)e[t++]=i&255|pc,i/=128;for(;i&O1;)e[t++]=i&255|pc,i>>>=7;return e[t]=i|0,Wl.bytes=t-s+1,e}var C1=xn,R1=128,fc=127;function xn(i,s){var t=0,s=s||0,r=0,n=s,o,a=i.length;do{if(n>=a)throw xn.bytes=0,new RangeError("Could not decode varint");o=i[n++],t+=r<28?(o&fc)<<r:(o&fc)*Math.pow(2,r),r+=7}while(o>=R1);return xn.bytes=n-s,t}var N1=Math.pow(2,7),T1=Math.pow(2,14),B1=Math.pow(2,21),D1=Math.pow(2,28),j1=Math.pow(2,35),k1=Math.pow(2,42),q1=Math.pow(2,49),U1=Math.pow(2,56),L1=Math.pow(2,63),M1=function(i){return i<N1?1:i<T1?2:i<B1?3:i<D1?4:i<j1?5:i<k1?6:i<q1?7:i<U1?8:i<L1?9:10},F1={encode:x1,decode:C1,encodingLength:M1},Gl=F1;const gc=(i,e,t=0)=>(Gl.encode(i,e,t),e),yc=i=>Gl.encodingLength(i),On=(i,e)=>{const t=e.byteLength,s=yc(i),r=s+yc(t),n=new Uint8Array(r+t);return gc(i,n,0),gc(t,n,s),n.set(e,r),new z1(i,t,e,n)};class z1{constructor(e,t,s,r){this.code=e,this.size=t,this.digest=s,this.bytes=r}}const Jl=({name:i,code:e,encode:t})=>new H1(i,e,t);class H1{constructor(e,t,s){this.name=e,this.code=t,this.encode=s}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?On(this.code,t):t.then(s=>On(this.code,s))}else throw Error("Unknown type, must be binary type")}}const Yl=i=>async e=>new Uint8Array(await crypto.subtle.digest(i,e)),K1=Jl({name:"sha2-256",code:18,encode:Yl("SHA-256")}),V1=Jl({name:"sha2-512",code:19,encode:Yl("SHA-512")});var W1=Object.freeze({__proto__:null,sha256:K1,sha512:V1});const Zl=0,G1="identity",Ql=Hl,J1=i=>On(Zl,Ql(i)),Y1={code:Zl,name:G1,encode:Ql,digest:J1};var Z1=Object.freeze({__proto__:null,identity:Y1});new TextEncoder,new TextDecoder;const mc={...H0,...V0,...G0,...Y0,...X0,...h1,...d1,...g1,...v1,...S1};({...W1,...Z1});function Q1(i=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(i):new Uint8Array(i)}function Xl(i,e,t,s){return{name:i,prefix:e,encoder:{name:i,prefix:e,encode:t},decoder:{decode:s}}}const wc=Xl("utf8","u",i=>"u"+new TextDecoder("utf8").decode(i),i=>new TextEncoder().encode(i.substring(1))),Wr=Xl("ascii","a",i=>{let e="a";for(let t=0;t<i.length;t++)e+=String.fromCharCode(i[t]);return e},i=>{i=i.substring(1);const e=Q1(i.length);for(let t=0;t<i.length;t++)e[t]=i.charCodeAt(t);return e}),X1={utf8:wc,"utf-8":wc,hex:mc.base16,latin1:Wr,ascii:Wr,binary:Wr,...mc};function eE(i,e="utf8"){const t=X1[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(i,"utf8"):t.decoder.decode(`${t.prefix}${i}`)}var tE=Object.defineProperty,iE=(i,e,t)=>e in i?tE(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,dt=(i,e,t)=>iE(i,typeof e!="symbol"?e+"":e,t);class sE{constructor(e,t){this.core=e,this.logger=t,dt(this,"keychain",new Map),dt(this,"name",s0),dt(this,"version",r0),dt(this,"initialized",!1),dt(this,"storagePrefix",bt),dt(this,"init",async()=>{if(!this.initialized){const s=await this.getKeyChain();typeof s<"u"&&(this.keychain=s),this.initialized=!0}}),dt(this,"has",s=>(this.isInitialized(),this.keychain.has(s))),dt(this,"set",async(s,r)=>{this.isInitialized(),this.keychain.set(s,r),await this.persist()}),dt(this,"get",s=>{this.isInitialized();const r=this.keychain.get(s);if(typeof r>"u"){const{message:n}=D("NO_MATCHING_KEY",`${this.name}: ${s}`);throw new Error(n)}return r}),dt(this,"del",async s=>{this.isInitialized(),this.keychain.delete(s),await this.persist()}),this.core=e,this.logger=Ne(t,this.name)}get context(){return Ve(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,pn(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?fn(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}}var rE=Object.defineProperty,nE=(i,e,t)=>e in i?rE(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ie=(i,e,t)=>nE(i,typeof e!="symbol"?e+"":e,t);class oE{constructor(e,t,s){this.core=e,this.logger=t,Ie(this,"name",t0),Ie(this,"keychain"),Ie(this,"randomSessionIdentifier",_n()),Ie(this,"initialized",!1),Ie(this,"init",async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)}),Ie(this,"hasKeys",r=>(this.isInitialized(),this.keychain.has(r))),Ie(this,"getClientId",async()=>{this.isInitialized();const r=await this.getClientSeed(),n=da(r);return Qh(n.publicKey)}),Ie(this,"generateKeyPair",()=>{this.isInitialized();const r=Pb();return this.setPrivateKey(r.publicKey,r.privateKey)}),Ie(this,"signJWT",async r=>{this.isInitialized();const n=await this.getClientSeed(),o=da(n),a=this.randomSessionIdentifier;return await Uy(a,r,i0,o)}),Ie(this,"generateSharedKey",(r,n,o)=>{this.isInitialized();const a=this.getPrivateKey(r),c=Sb(a,n);return this.setSymKey(c,o)}),Ie(this,"setSymKey",async(r,n)=>{this.isInitialized();const o=n||Hs(r);return await this.keychain.set(o,r),o}),Ie(this,"deleteKeyPair",async r=>{this.isInitialized(),await this.keychain.del(r)}),Ie(this,"deleteSymKey",async r=>{this.isInitialized(),await this.keychain.del(r)}),Ie(this,"encode",async(r,n,o)=>{this.isInitialized();const a=jl(o),c=Xt(n);if(Ga(a))return Ab(c,o?.encoding);if(Wa(a)){const d=a.senderPublicKey,f=a.receiverPublicKey;r=await this.generateSharedKey(d,f)}const h=this.getSymKey(r),{type:l,senderPublicKey:u}=a;return xb({type:l,symKey:h,message:c,senderPublicKey:u,encoding:o?.encoding})}),Ie(this,"decode",async(r,n,o)=>{this.isInitialized();const a=Rb(n,o);if(Ga(a)){const c=Cb(n,o?.encoding);return Qt(c)}if(Wa(a)){const c=a.receiverPublicKey,h=a.senderPublicKey;r=await this.generateSharedKey(c,h)}try{const c=this.getSymKey(r),h=Ob({symKey:c,encoded:n,encoding:o?.encoding});return Qt(h)}catch(c){this.logger.error(`Failed to decode message from topic: '${r}', clientId: '${await this.getClientId()}'`),this.logger.error(c)}}),Ie(this,"getPayloadType",(r,n=at)=>{const o=fs({encoded:r,encoding:n});return si(o.type)}),Ie(this,"getPayloadSenderPublicKey",(r,n=at)=>{const o=fs({encoded:r,encoding:n});return o.senderPublicKey?qe(o.senderPublicKey,Re):void 0}),this.core=e,this.logger=Ne(t,this.name),this.keychain=s||new sE(this.core,this.logger)}get context(){return Ve(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(lc)}catch{e=_n(),await this.keychain.set(lc,e)}return eE(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}}var aE=Object.defineProperty,cE=Object.defineProperties,hE=Object.getOwnPropertyDescriptors,bc=Object.getOwnPropertySymbols,lE=Object.prototype.hasOwnProperty,uE=Object.prototype.propertyIsEnumerable,An=(i,e,t)=>e in i?aE(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,dE=(i,e)=>{for(var t in e||(e={}))lE.call(e,t)&&An(i,t,e[t]);if(bc)for(var t of bc(e))uE.call(e,t)&&An(i,t,e[t]);return i},pE=(i,e)=>cE(i,hE(e)),Ue=(i,e,t)=>An(i,typeof e!="symbol"?e+"":e,t);class fE extends Dv{constructor(e,t){super(e,t),this.logger=e,this.core=t,Ue(this,"messages",new Map),Ue(this,"messagesWithoutClientAck",new Map),Ue(this,"name",n0),Ue(this,"version",o0),Ue(this,"initialized",!1),Ue(this,"storagePrefix",bt),Ue(this,"init",async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const s=await this.getRelayerMessages();typeof s<"u"&&(this.messages=s);const r=await this.getRelayerMessagesWithoutClientAck();typeof r<"u"&&(this.messagesWithoutClientAck=r),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(s){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(s)}finally{this.initialized=!0}}}),Ue(this,"set",async(s,r,n)=>{this.isInitialized();const o=mt(r);let a=this.messages.get(s);if(typeof a>"u"&&(a={}),typeof a[o]<"u")return o;if(a[o]=r,this.messages.set(s,a),n===Ks.inbound){const c=this.messagesWithoutClientAck.get(s)||{};this.messagesWithoutClientAck.set(s,pE(dE({},c),{[o]:r}))}return await this.persist(),o}),Ue(this,"get",s=>{this.isInitialized();let r=this.messages.get(s);return typeof r>"u"&&(r={}),r}),Ue(this,"getWithoutAck",s=>{this.isInitialized();const r={};for(const n of s){const o=this.messagesWithoutClientAck.get(n)||{};r[n]=Object.values(o)}return r}),Ue(this,"has",(s,r)=>{this.isInitialized();const n=this.get(s),o=mt(r);return typeof n[o]<"u"}),Ue(this,"ack",async(s,r)=>{this.isInitialized();const n=this.messagesWithoutClientAck.get(s);if(typeof n>"u")return;const o=mt(r);delete n[o],Object.keys(n).length===0?this.messagesWithoutClientAck.delete(s):this.messagesWithoutClientAck.set(s,n),await this.persist()}),Ue(this,"del",async s=>{this.isInitialized(),this.messages.delete(s),this.messagesWithoutClientAck.delete(s),await this.persist()}),this.logger=Ne(e,this.name),this.core=t}get context(){return Ve(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get storageKeyWithoutClientAck(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name+"_withoutClientAck"}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,pn(e))}async setRelayerMessagesWithoutClientAck(e){await this.core.storage.setItem(this.storageKeyWithoutClientAck,pn(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?fn(e):void 0}async getRelayerMessagesWithoutClientAck(){const e=await this.core.storage.getItem(this.storageKeyWithoutClientAck);return typeof e<"u"?fn(e):void 0}async persist(){await this.setRelayerMessages(this.messages),await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}}var gE=Object.defineProperty,yE=Object.defineProperties,mE=Object.getOwnPropertyDescriptors,vc=Object.getOwnPropertySymbols,wE=Object.prototype.hasOwnProperty,bE=Object.prototype.propertyIsEnumerable,Cn=(i,e,t)=>e in i?gE(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Bs=(i,e)=>{for(var t in e||(e={}))wE.call(e,t)&&Cn(i,t,e[t]);if(vc)for(var t of vc(e))bE.call(e,t)&&Cn(i,t,e[t]);return i},Gr=(i,e)=>yE(i,mE(e)),nt=(i,e,t)=>Cn(i,typeof e!="symbol"?e+"":e,t);class vE extends jv{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,nt(this,"events",new Xe.EventEmitter),nt(this,"name",a0),nt(this,"queue",new Map),nt(this,"publishTimeout",T.toMiliseconds(T.ONE_MINUTE)),nt(this,"initialPublishTimeout",T.toMiliseconds(T.ONE_SECOND*15)),nt(this,"needsTransportRestart",!1),nt(this,"publish",async(s,r,n)=>{var o;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:s,message:r,opts:n}});const a=n?.ttl||uc,c=Qs(n),h=n?.prompt||!1,l=n?.tag||0,u=n?.id||Jt().toString(),d={topic:s,message:r,opts:{ttl:a,relay:c,prompt:h,tag:l,id:u,attestation:n?.attestation,tvf:n?.tvf}},f=`Failed to publish payload, please try again. id:${u} tag:${l}`;try{const p=new Promise(async g=>{const y=({id:m})=>{d.opts.id===m&&(this.removeRequestFromQueue(m),this.relayer.events.removeListener(me.publish,y),g(d))};this.relayer.events.on(me.publish,y);const b=kt(new Promise((m,w)=>{this.rpcPublish({topic:s,message:r,ttl:a,prompt:h,tag:l,id:u,attestation:n?.attestation,tvf:n?.tvf}).then(m).catch($=>{this.logger.warn($,$?.message),w($)})}),this.initialPublishTimeout,`Failed initial publish, retrying.... id:${u} tag:${l}`);try{await b,this.events.removeListener(me.publish,y)}catch(m){this.queue.set(u,Gr(Bs({},d),{attempt:1})),this.logger.warn(m,m?.message)}});this.logger.trace({type:"method",method:"publish",params:{id:u,topic:s,message:r,opts:n}}),await kt(p,this.publishTimeout,f)}catch(p){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(p),(o=n?.internal)!=null&&o.throwOnFailedPublish)throw p}finally{this.queue.delete(u)}}),nt(this,"on",(s,r)=>{this.events.on(s,r)}),nt(this,"once",(s,r)=>{this.events.once(s,r)}),nt(this,"off",(s,r)=>{this.events.off(s,r)}),nt(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.relayer=e,this.logger=Ne(t,this.name),this.registerEventListeners()}get context(){return Ve(this.logger)}async rpcPublish(e){var t,s,r,n;const{topic:o,message:a,ttl:c=uc,prompt:h,tag:l,id:u,attestation:d,tvf:f}=e,p={method:is(Qs().protocol).publish,params:Bs({topic:o,message:a,ttl:c,prompt:h,tag:l,attestation:d},f),id:u};_e((t=p.params)==null?void 0:t.prompt)&&((s=p.params)==null||delete s.prompt),_e((r=p.params)==null?void 0:r.tag)&&((n=p.params)==null||delete n.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:p});const g=await this.relayer.request(p);return this.relayer.events.emit(me.publish,e),this.logger.debug("Successfully Published Payload"),g}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async(e,t)=>{const s=e.attempt+1;this.queue.set(t,Gr(Bs({},e),{attempt:s}));const{topic:r,message:n,opts:o,attestation:a}=e;this.logger.warn({},`Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`),await this.rpcPublish(Gr(Bs({},e),{topic:r,message:n,ttl:o.ttl,prompt:o.prompt,tag:o.tag,id:o.id,attestation:a,tvf:o.tvf})),this.logger.warn({},`Publisher: queue->published: ${e.opts.id}`)})}registerEventListeners(){this.relayer.core.heartbeat.on(oi.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(me.connection_stalled);return}this.checkQueue()}),this.relayer.on(me.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}}var EE=Object.defineProperty,IE=(i,e,t)=>e in i?EE(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,fi=(i,e,t)=>IE(i,typeof e!="symbol"?e+"":e,t);class $E{constructor(){fi(this,"map",new Map),fi(this,"set",(e,t)=>{const s=this.get(e);this.exists(e,t)||this.map.set(e,[...s,t])}),fi(this,"get",e=>this.map.get(e)||[]),fi(this,"exists",(e,t)=>this.get(e).includes(t)),fi(this,"delete",(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const s=this.get(e);if(!this.exists(e,t))return;const r=s.filter(n=>n!==t);if(!r.length){this.map.delete(e);return}this.map.set(e,r)}),fi(this,"clear",()=>{this.map.clear()})}get topics(){return Array.from(this.map.keys())}}var _E=Object.defineProperty,PE=Object.defineProperties,SE=Object.getOwnPropertyDescriptors,Ec=Object.getOwnPropertySymbols,xE=Object.prototype.hasOwnProperty,OE=Object.prototype.propertyIsEnumerable,Rn=(i,e,t)=>e in i?_E(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Xi=(i,e)=>{for(var t in e||(e={}))xE.call(e,t)&&Rn(i,t,e[t]);if(Ec)for(var t of Ec(e))OE.call(e,t)&&Rn(i,t,e[t]);return i},Jr=(i,e)=>PE(i,SE(e)),ie=(i,e,t)=>Rn(i,typeof e!="symbol"?e+"":e,t);class AE extends Uv{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,ie(this,"subscriptions",new Map),ie(this,"topicMap",new $E),ie(this,"events",new Xe.EventEmitter),ie(this,"name",f0),ie(this,"version",g0),ie(this,"pending",new Map),ie(this,"cached",[]),ie(this,"initialized",!1),ie(this,"storagePrefix",bt),ie(this,"subscribeTimeout",T.toMiliseconds(T.ONE_MINUTE)),ie(this,"initialSubscribeTimeout",T.toMiliseconds(T.ONE_SECOND*15)),ie(this,"clientId"),ie(this,"batchSubscribeTopicsLimit",500),ie(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),await this.restore()),this.initialized=!0}),ie(this,"subscribe",async(s,r)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:r}});try{const n=Qs(r),o={topic:s,relay:n,transportType:r?.transportType};this.pending.set(s,o);const a=await this.rpcSubscribe(s,n,r);return typeof a=="string"&&(this.onSubscribe(a,o),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:r}})),a}catch(n){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(n),n}}),ie(this,"unsubscribe",async(s,r)=>{this.isInitialized(),typeof r?.id<"u"?await this.unsubscribeById(s,r.id,r):await this.unsubscribeByTopic(s,r)}),ie(this,"isSubscribed",s=>new Promise(r=>{r(this.topicMap.topics.includes(s))})),ie(this,"isKnownTopic",s=>new Promise(r=>{r(this.topicMap.topics.includes(s)||this.pending.has(s)||this.cached.some(n=>n.topic===s))})),ie(this,"on",(s,r)=>{this.events.on(s,r)}),ie(this,"once",(s,r)=>{this.events.once(s,r)}),ie(this,"off",(s,r)=>{this.events.off(s,r)}),ie(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),ie(this,"start",async()=>{await this.onConnect()}),ie(this,"stop",async()=>{await this.onDisconnect()}),ie(this,"restart",async()=>{await this.restore(),await this.onRestart()}),ie(this,"checkPending",async()=>{if(this.pending.size===0&&(!this.initialized||!this.relayer.connected))return;const s=[];this.pending.forEach(r=>{s.push(r)}),await this.batchSubscribe(s)}),ie(this,"registerEventListeners",()=>{this.relayer.core.heartbeat.on(oi.pulse,async()=>{await this.checkPending()}),this.events.on(Me.created,async s=>{const r=Me.created;this.logger.info(`Emitting ${r}`),this.logger.debug({type:"event",event:r,data:s}),await this.persist()}),this.events.on(Me.deleted,async s=>{const r=Me.deleted;this.logger.info(`Emitting ${r}`),this.logger.debug({type:"event",event:r,data:s}),await this.persist()})}),this.relayer=e,this.logger=Ne(t,this.name),this.clientId=""}get context(){return Ve(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}get hasAnyTopics(){return this.topicMap.topics.length>0||this.pending.size>0||this.cached.length>0||this.subscriptions.size>0}hasSubscription(e,t){let s=!1;try{s=this.getSubscription(e).topic===t}catch{}return s}reset(){this.cached=[],this.initialized=!0}onDisable(){this.values.length>0&&(this.cached=this.values),this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const s=this.topicMap.get(e);await Promise.all(s.map(async r=>await this.unsubscribeById(e,r,t)))}async unsubscribeById(e,t,s){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}});try{const r=Qs(s);await this.restartToComplete({topic:e,id:t,relay:r}),await this.rpcUnsubscribe(e,t,r);const n=te("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,n),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}})}catch(r){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(r),r}}async rpcSubscribe(e,t,s){var r;(!s||s?.transportType===oe.relay)&&await this.restartToComplete({topic:e,id:e,relay:t});const n={method:is(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:n});const o=(r=s?.internal)==null?void 0:r.throwOnFailedPublish;try{const a=await this.getSubscriptionId(e);if(s?.transportType===oe.link_mode)return setTimeout(()=>{(this.relayer.connected||this.relayer.connecting)&&this.relayer.request(n).catch(l=>this.logger.warn(l))},T.toMiliseconds(T.ONE_SECOND)),a;const c=new Promise(async l=>{const u=d=>{d.topic===e&&(this.events.removeListener(Me.created,u),l(d.id))};this.events.on(Me.created,u);try{const d=await kt(new Promise((f,p)=>{this.relayer.request(n).catch(g=>{this.logger.warn(g,g?.message),p(g)}).then(f)}),this.initialSubscribeTimeout,`Subscribing to ${e} failed, please try again`);this.events.removeListener(Me.created,u),l(d)}catch{}}),h=await kt(c,this.subscribeTimeout,`Subscribing to ${e} failed, please try again`);if(!h&&o)throw new Error(`Subscribing to ${e} failed, please try again`);return h?a:null}catch(a){if(this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(me.connection_stalled),o)throw a}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,s={method:is(t.protocol).batchSubscribe,params:{topics:e.map(r=>r.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});try{await await kt(new Promise(r=>{this.relayer.request(s).catch(n=>this.logger.warn(n)).then(r)}),this.subscribeTimeout,"rpcBatchSubscribe failed, please try again")}catch{this.relayer.events.emit(me.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,s={method:is(t.protocol).batchFetchMessages,params:{topics:e.map(n=>n.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});let r;try{r=await await kt(new Promise((n,o)=>{this.relayer.request(s).catch(a=>{this.logger.warn(a),o(a)}).then(n)}),this.subscribeTimeout,"rpcBatchFetchMessages failed, please try again")}catch{this.relayer.events.emit(me.connection_stalled)}return r}rpcUnsubscribe(e,t,s){const r={method:is(s.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:r}),this.relayer.request(r)}onSubscribe(e,t){this.setSubscription(e,Jr(Xi({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,Xi({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,s){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,s),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,Xi({},t)),this.topicMap.set(t.topic,e),this.events.emit(Me.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:s}=D("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const s=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(s.topic,e),this.events.emit(Me.deleted,Jr(Xi({},s),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(Me.sync)}async onRestart(){if(this.cached.length){const e=[...this.cached],t=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let s=0;s<t;s++){const r=e.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(r)}}this.events.emit(Me.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=D("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){e.length&&(await this.rpcBatchSubscribe(e),this.onBatchSubscribe(await Promise.all(e.map(async t=>Jr(Xi({},t),{id:await this.getSubscriptionId(t.topic)})))))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(await dm(T.toMiliseconds(T.ONE_SECOND)),await this.relayer.handleBatchMessageEvents(t.messages))}async onConnect(){await this.restart(),this.reset()}onDisconnect(){this.onDisable()}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(e){!this.relayer.connected&&!this.relayer.connecting&&(this.cached.push(e),await this.relayer.transportOpen())}async getClientId(){return this.clientId||(this.clientId=await this.relayer.core.crypto.getClientId()),this.clientId}async getSubscriptionId(e){return mt(e+await this.getClientId())}}var CE=Object.defineProperty,Ic=Object.getOwnPropertySymbols,RE=Object.prototype.hasOwnProperty,NE=Object.prototype.propertyIsEnumerable,Nn=(i,e,t)=>e in i?CE(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,$c=(i,e)=>{for(var t in e||(e={}))RE.call(e,t)&&Nn(i,t,e[t]);if(Ic)for(var t of Ic(e))NE.call(e,t)&&Nn(i,t,e[t]);return i},Z=(i,e,t)=>Nn(i,typeof e!="symbol"?e+"":e,t);class TE extends kv{constructor(e){super(e),Z(this,"protocol","wc"),Z(this,"version",2),Z(this,"core"),Z(this,"logger"),Z(this,"events",new Xe.EventEmitter),Z(this,"provider"),Z(this,"messages"),Z(this,"subscriber"),Z(this,"publisher"),Z(this,"name",h0),Z(this,"transportExplicitlyClosed",!1),Z(this,"initialized",!1),Z(this,"connectionAttemptInProgress",!1),Z(this,"relayUrl"),Z(this,"projectId"),Z(this,"packageName"),Z(this,"bundleId"),Z(this,"hasExperiencedNetworkDisruption",!1),Z(this,"pingTimeout"),Z(this,"heartBeatTimeout",T.toMiliseconds(T.THIRTY_SECONDS+T.FIVE_SECONDS)),Z(this,"reconnectTimeout"),Z(this,"connectPromise"),Z(this,"reconnectInProgress",!1),Z(this,"requestsInFlight",[]),Z(this,"connectTimeout",T.toMiliseconds(T.ONE_SECOND*15)),Z(this,"request",async t=>{var s,r;this.logger.debug("Publishing Request Payload");const n=t.id||Jt().toString();await this.toEstablishConnection();try{this.logger.trace({id:n,method:t.method,topic:(s=t.params)==null?void 0:s.topic},"relayer.request - publishing...");const o=`${n}:${((r=t.params)==null?void 0:r.tag)||""}`;this.requestsInFlight.push(o);const a=await this.provider.request(t);return this.requestsInFlight=this.requestsInFlight.filter(c=>c!==o),a}catch(o){throw this.logger.debug(`Failed to Publish Request: ${n}`),o}}),Z(this,"resetPingTimeout",()=>{Ys()&&(clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{var t,s,r,n;try{this.logger.debug({},"pingTimeout: Connection stalled, terminating..."),(n=(r=(s=(t=this.provider)==null?void 0:t.connection)==null?void 0:s.socket)==null?void 0:r.terminate)==null||n.call(r)}catch(o){this.logger.warn(o,o?.message)}},this.heartBeatTimeout))}),Z(this,"onPayloadHandler",t=>{this.onProviderPayload(t),this.resetPingTimeout()}),Z(this,"onConnectHandler",()=>{this.logger.warn({},"Relayer connected "),this.startPingTimeout(),this.events.emit(me.connect)}),Z(this,"onDisconnectHandler",()=>{this.logger.warn({},"Relayer disconnected "),this.requestsInFlight=[],this.onProviderDisconnect()}),Z(this,"onProviderErrorHandler",t=>{this.logger.fatal(`Fatal socket error: ${t.message}`),this.events.emit(me.error,t),this.logger.fatal("Fatal socket error received, closing transport"),this.transportClose()}),Z(this,"registerProviderListeners",()=>{this.provider.on(Ge.payload,this.onPayloadHandler),this.provider.on(Ge.connect,this.onConnectHandler),this.provider.on(Ge.disconnect,this.onDisconnectHandler),this.provider.on(Ge.error,this.onProviderErrorHandler)}),this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?Ne(e.logger,this.name):Mn(sr({level:e.logger||c0})),this.messages=new fE(this.logger,e.core),this.subscriber=new AE(this,this.logger),this.publisher=new vE(this,this.logger),this.relayUrl=e?.relayUrl||Fl,this.projectId=e.projectId,Yy()?this.packageName=ma():Zy()&&(this.bundleId=ma()),this.provider={}}async init(){if(this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),this.initialized=!0,this.subscriber.hasAnyTopics)try{await this.transportOpen()}catch(e){this.logger.warn(e,e?.message)}}get context(){return Ve(this.logger)}get connected(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===1||!1}get connecting(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===0||this.connectPromise!==void 0||!1}async publish(e,t,s){this.isInitialized(),await this.publisher.publish(e,t,s),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now(),transportType:oe.relay},Ks.outbound)}async subscribe(e,t){var s,r,n;this.isInitialized(),(!(t!=null&&t.transportType)||t?.transportType==="relay")&&await this.toEstablishConnection();const o=typeof((s=t?.internal)==null?void 0:s.throwOnFailedPublish)>"u"?!0:(r=t?.internal)==null?void 0:r.throwOnFailedPublish;let a=((n=this.subscriber.topicMap.get(e))==null?void 0:n[0])||"",c;const h=l=>{l.topic===e&&(this.subscriber.off(Me.created,h),c())};return await Promise.all([new Promise(l=>{c=l,this.subscriber.on(Me.created,h)}),new Promise(async(l,u)=>{a=await this.subscriber.subscribe(e,$c({internal:{throwOnFailedPublish:o}},t)).catch(d=>{o&&u(d)})||a,l()})]),a}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){this.provider.disconnect&&(this.hasExperiencedNetworkDisruption||this.connected)?await kt(this.provider.disconnect(),2e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){if(!this.subscriber.hasAnyTopics){this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");return}if(this.connectPromise?(this.logger.debug({},"Waiting for existing connection attempt to resolve..."),await this.connectPromise,this.logger.debug({},"Existing connection attempt resolved")):(this.connectPromise=new Promise(async(t,s)=>{await this.connect(e).then(t).catch(s).finally(()=>{this.connectPromise=void 0})}),await this.connectPromise),!this.connected)throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)}async restartTransport(e){this.logger.debug({},"Restarting transport..."),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await nc())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if(e?.length===0){this.logger.trace("Batch message events is empty. Ignoring...");return}const t=e.sort((s,r)=>s.publishedAt-r.publishedAt);this.logger.debug(`Batch of ${t.length} message events sorted`);for(const s of t)try{await this.onMessageEvent(s)}catch(r){this.logger.warn(r,"Error while processing batch message event: "+r?.message)}this.logger.trace(`Batch of ${t.length} message events processed`)}async onLinkMessageEvent(e,t){const{topic:s}=e;if(!t.sessionExists){const r=ue(T.FIVE_MINUTES),n={topic:s,expiry:r,relay:{protocol:"irn"},active:!1};await this.core.pairing.pairings.set(s,n)}this.events.emit(me.message,e),await this.recordMessageEvent(e,Ks.inbound)}async connect(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;let t=1;for(;t<6;){try{if(this.transportExplicitlyClosed)break;this.logger.debug({},`Connecting to ${this.relayUrl}, attempt: ${t}...`),await this.createProvider(),await new Promise(async(s,r)=>{const n=()=>{r(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(Ge.disconnect,n),await kt(new Promise((o,a)=>{this.provider.connect().then(o).catch(a)}),this.connectTimeout,`Socket stalled when trying to connect to ${this.relayUrl}`).catch(o=>{r(o)}).finally(()=>{this.provider.off(Ge.disconnect,n),clearTimeout(this.reconnectTimeout)}),await new Promise(async(o,a)=>{const c=()=>{a(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(Ge.disconnect,c),await this.subscriber.start().then(o).catch(a).finally(()=>{this.provider.off(Ge.disconnect,c)})}),this.hasExperiencedNetworkDisruption=!1,s()})}catch(s){await this.subscriber.stop();const r=s;this.logger.warn({},r.message),this.hasExperiencedNetworkDisruption=!0}finally{this.connectionAttemptInProgress=!1}if(this.connected){this.logger.debug({},`Connected to ${this.relayUrl} successfully on attempt: ${t}`);break}await new Promise(s=>setTimeout(s,T.toMiliseconds(t*1))),t++}}startPingTimeout(){var e,t,s,r,n;if(Ys())try{(t=(e=this.provider)==null?void 0:e.connection)!=null&&t.socket&&((n=(r=(s=this.provider)==null?void 0:s.connection)==null?void 0:r.socket)==null||n.on("ping",()=>{this.resetPingTimeout()})),this.resetPingTimeout()}catch(o){this.logger.warn(o,o?.message)}}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new et(new Zv(im({sdkVersion:Sn,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId,packageName:this.packageName}))),this.registerProviderListeners()}async recordMessageEvent(e,t){const{topic:s,message:r}=e;await this.messages.set(s,r,t)}async shouldIgnoreMessageEvent(e){const{topic:t,message:s}=e;if(!s||s.length===0)return this.logger.warn(`Ignoring invalid/empty message: ${s}`),!0;if(!await this.subscriber.isKnownTopic(t))return this.logger.warn(`Ignoring message for unknown topic ${t}`),!0;const r=this.messages.has(t,s);return r&&this.logger.warn(`Ignoring duplicate message: ${s}`),r}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),Hn(e)){if(!e.method.endsWith(l0))return;const t=e.params,{topic:s,message:r,publishedAt:n,attestation:o}=t.data,a={topic:s,message:r,publishedAt:n,transportType:oe.relay,attestation:o};this.logger.debug("Emitting Relayer Payload"),this.logger.trace($c({type:"event",event:t.id},a)),this.events.emit(t.id,a),await this.acknowledgePayload(e),await this.onMessageEvent(a)}else or(e)&&this.events.emit(me.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(await this.recordMessageEvent(e,Ks.inbound),this.events.emit(me.message,e))}async acknowledgePayload(e){const t=rr(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(Ge.payload,this.onPayloadHandler),this.provider.off(Ge.connect,this.onConnectHandler),this.provider.off(Ge.disconnect,this.onDisconnectHandler),this.provider.off(Ge.error,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await nc();_v(async t=>{e!==t&&(e=t,t?await this.transportOpen().catch(s=>this.logger.error(s,s?.message)):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))}),this.core.heartbeat.on(oi.pulse,async()=>{if(!this.transportExplicitlyClosed&&!this.connected&&xv())try{await this.confirmOnlineStateOrThrow(),await this.transportOpen()}catch(t){this.logger.warn(t,t?.message)}})}async onProviderDisconnect(){clearTimeout(this.pingTimeout),this.events.emit(me.disconnect),this.connectionAttemptInProgress=!1,!this.reconnectInProgress&&(this.reconnectInProgress=!0,await this.subscriber.stop(),this.subscriber.hasAnyTopics&&(this.transportExplicitlyClosed||(this.reconnectTimeout=setTimeout(async()=>{await this.transportOpen().catch(e=>this.logger.error(e,e?.message)),this.reconnectTimeout=void 0,this.reconnectInProgress=!1},T.toMiliseconds(u0)))))}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(await this.confirmOnlineStateOrThrow(),!this.connected){if(this.connectPromise){await this.connectPromise;return}await this.connect()}}}function BE(){}function _c(i){if(!i||typeof i!="object")return!1;const e=Object.getPrototypeOf(i);return e===null||e===Object.prototype||Object.getPrototypeOf(e)===null?Object.prototype.toString.call(i)==="[object Object]":!1}function Pc(i){return Object.getOwnPropertySymbols(i).filter(e=>Object.prototype.propertyIsEnumerable.call(i,e))}function Sc(i){return i==null?i===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(i)}const DE="[object RegExp]",jE="[object String]",kE="[object Number]",qE="[object Boolean]",xc="[object Arguments]",UE="[object Symbol]",LE="[object Date]",ME="[object Map]",FE="[object Set]",zE="[object Array]",HE="[object Function]",KE="[object ArrayBuffer]",Yr="[object Object]",VE="[object Error]",WE="[object DataView]",GE="[object Uint8Array]",JE="[object Uint8ClampedArray]",YE="[object Uint16Array]",ZE="[object Uint32Array]",QE="[object BigUint64Array]",XE="[object Int8Array]",eI="[object Int16Array]",tI="[object Int32Array]",iI="[object BigInt64Array]",sI="[object Float32Array]",rI="[object Float64Array]";function nI(i,e){return i===e||Number.isNaN(i)&&Number.isNaN(e)}function oI(i,e,t){return ss(i,e,void 0,void 0,void 0,void 0,t)}function ss(i,e,t,s,r,n,o){const a=o(i,e,t,s,r,n);if(a!==void 0)return a;if(typeof i==typeof e)switch(typeof i){case"bigint":case"string":case"boolean":case"symbol":case"undefined":return i===e;case"number":return i===e||Object.is(i,e);case"function":return i===e;case"object":return cs(i,e,n,o)}return cs(i,e,n,o)}function cs(i,e,t,s){if(Object.is(i,e))return!0;let r=Sc(i),n=Sc(e);if(r===xc&&(r=Yr),n===xc&&(n=Yr),r!==n)return!1;switch(r){case jE:return i.toString()===e.toString();case kE:{const c=i.valueOf(),h=e.valueOf();return nI(c,h)}case qE:case LE:case UE:return Object.is(i.valueOf(),e.valueOf());case DE:return i.source===e.source&&i.flags===e.flags;case HE:return i===e}t=t??new Map;const o=t.get(i),a=t.get(e);if(o!=null&&a!=null)return o===e;t.set(i,e),t.set(e,i);try{switch(r){case ME:{if(i.size!==e.size)return!1;for(const[c,h]of i.entries())if(!e.has(c)||!ss(h,e.get(c),c,i,e,t,s))return!1;return!0}case FE:{if(i.size!==e.size)return!1;const c=Array.from(i.values()),h=Array.from(e.values());for(let l=0;l<c.length;l++){const u=c[l],d=h.findIndex(f=>ss(u,f,void 0,i,e,t,s));if(d===-1)return!1;h.splice(d,1)}return!0}case zE:case GE:case JE:case YE:case ZE:case QE:case XE:case eI:case tI:case iI:case sI:case rI:{if(typeof Buffer<"u"&&Buffer.isBuffer(i)!==Buffer.isBuffer(e)||i.length!==e.length)return!1;for(let c=0;c<i.length;c++)if(!ss(i[c],e[c],c,i,e,t,s))return!1;return!0}case KE:return i.byteLength!==e.byteLength?!1:cs(new Uint8Array(i),new Uint8Array(e),t,s);case WE:return i.byteLength!==e.byteLength||i.byteOffset!==e.byteOffset?!1:cs(new Uint8Array(i),new Uint8Array(e),t,s);case VE:return i.name===e.name&&i.message===e.message;case Yr:{if(!(cs(i.constructor,e.constructor,t,s)||_c(i)&&_c(e)))return!1;const c=[...Object.keys(i),...Pc(i)],h=[...Object.keys(e),...Pc(e)];if(c.length!==h.length)return!1;for(let l=0;l<c.length;l++){const u=c[l],d=i[u];if(!Object.hasOwn(e,u))return!1;const f=e[u];if(!ss(d,f,u,i,e,t,s))return!1}return!0}default:return!1}}finally{t.delete(i),t.delete(e)}}function aI(i,e){return oI(i,e,BE)}var cI=Object.defineProperty,Oc=Object.getOwnPropertySymbols,hI=Object.prototype.hasOwnProperty,lI=Object.prototype.propertyIsEnumerable,Tn=(i,e,t)=>e in i?cI(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ac=(i,e)=>{for(var t in e||(e={}))hI.call(e,t)&&Tn(i,t,e[t]);if(Oc)for(var t of Oc(e))lI.call(e,t)&&Tn(i,t,e[t]);return i},Be=(i,e,t)=>Tn(i,typeof e!="symbol"?e+"":e,t);class ai extends qv{constructor(e,t,s,r=bt,n=void 0){super(e,t,s,r),this.core=e,this.logger=t,this.name=s,Be(this,"map",new Map),Be(this,"version",d0),Be(this,"cached",[]),Be(this,"initialized",!1),Be(this,"getKey"),Be(this,"storagePrefix",bt),Be(this,"recentlyDeleted",[]),Be(this,"recentlyDeletedLimit",200),Be(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(o=>{this.getKey&&o!==null&&!_e(o)?this.map.set(this.getKey(o),o):tv(o)?this.map.set(o.id,o):iv(o)&&this.map.set(o.topic,o)}),this.cached=[],this.initialized=!0)}),Be(this,"set",async(o,a)=>{this.isInitialized(),this.map.has(o)?await this.update(o,a):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:o,value:a}),this.map.set(o,a),await this.persist())}),Be(this,"get",o=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:o}),this.getData(o))),Be(this,"getAll",o=>(this.isInitialized(),o?this.values.filter(a=>Object.keys(o).every(c=>aI(a[c],o[c]))):this.values)),Be(this,"update",async(o,a)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:o,update:a});const c=Ac(Ac({},this.getData(o)),a);this.map.set(o,c),await this.persist()}),Be(this,"delete",async(o,a)=>{this.isInitialized(),this.map.has(o)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:o,reason:a}),this.map.delete(o),this.addToRecentlyDeleted(o),await this.persist())}),this.logger=Ne(t,this.name),this.storagePrefix=r,this.getKey=n}get context(){return Ve(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:r}=D("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(r),new Error(r)}const{message:s}=D("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=D("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}}var uI=Object.defineProperty,dI=(i,e,t)=>e in i?uI(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,V=(i,e,t)=>dI(i,typeof e!="symbol"?e+"":e,t);class pI{constructor(e,t){this.core=e,this.logger=t,V(this,"name",y0),V(this,"version",m0),V(this,"events",new Fn),V(this,"pairings"),V(this,"initialized",!1),V(this,"storagePrefix",bt),V(this,"ignoredPayloadTypes",[At]),V(this,"registeredMethods",[]),V(this,"init",async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))}),V(this,"register",({methods:s})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...s])]}),V(this,"create",async s=>{this.isInitialized();const r=_n(),n=await this.core.crypto.setSymKey(r),o=ue(T.FIVE_MINUTES),a={protocol:Ml},c={topic:n,expiry:o,relay:a,active:!1,methods:s?.methods},h=Ya({protocol:this.core.protocol,version:this.core.version,topic:n,symKey:r,relay:a,expiryTimestamp:o,methods:s?.methods});return this.events.emit(Wt.create,c),this.core.expirer.set(n,o),await this.pairings.set(n,c),await this.core.relayer.subscribe(n,{transportType:s?.transportType}),{topic:n,uri:h}}),V(this,"pair",async s=>{this.isInitialized();const r=this.core.eventClient.createEvent({properties:{topic:s?.uri,trace:[ft.pairing_started]}});this.isValidPair(s,r);const{topic:n,symKey:o,relay:a,expiryTimestamp:c,methods:h}=Ja(s.uri);r.props.properties.topic=n,r.addTrace(ft.pairing_uri_validation_success),r.addTrace(ft.pairing_uri_not_expired);let l;if(this.pairings.keys.includes(n)){if(l=this.pairings.get(n),r.addTrace(ft.existing_pairing),l.active)throw r.setError(Pt.active_pairing_already_exists),new Error(`Pairing already exists: ${n}. Please try again with a new connection URI.`);r.addTrace(ft.pairing_not_expired)}const u=c||ue(T.FIVE_MINUTES),d={topic:n,relay:a,expiry:u,active:!1,methods:h};this.core.expirer.set(n,u),await this.pairings.set(n,d),r.addTrace(ft.store_new_pairing),s.activatePairing&&await this.activate({topic:n}),this.events.emit(Wt.create,d),r.addTrace(ft.emit_inactive_pairing),this.core.crypto.keychain.has(n)||await this.core.crypto.setSymKey(o,n),r.addTrace(ft.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{r.setError(Pt.no_internet_connection)}try{await this.core.relayer.subscribe(n,{relay:a})}catch(f){throw r.setError(Pt.subscribe_pairing_topic_failure),f}return r.addTrace(ft.subscribe_pairing_topic_success),d}),V(this,"activate",async({topic:s})=>{this.isInitialized();const r=ue(T.FIVE_MINUTES);this.core.expirer.set(s,r),await this.pairings.update(s,{active:!0,expiry:r})}),V(this,"ping",async s=>{this.isInitialized(),await this.isValidPing(s),this.logger.warn("ping() is deprecated and will be removed in the next major release.");const{topic:r}=s;if(this.pairings.keys.includes(r)){const n=await this.sendRequest(r,"wc_pairingPing",{}),{done:o,resolve:a,reject:c}=zt();this.events.once(X("pairing_ping",n),({error:h})=>{h?c(h):a()}),await o()}}),V(this,"updateExpiry",async({topic:s,expiry:r})=>{this.isInitialized(),await this.pairings.update(s,{expiry:r})}),V(this,"updateMetadata",async({topic:s,metadata:r})=>{this.isInitialized(),await this.pairings.update(s,{peerMetadata:r})}),V(this,"getPairings",()=>(this.isInitialized(),this.pairings.values)),V(this,"disconnect",async s=>{this.isInitialized(),await this.isValidDisconnect(s);const{topic:r}=s;this.pairings.keys.includes(r)&&(await this.sendRequest(r,"wc_pairingDelete",te("USER_DISCONNECTED")),await this.deletePairing(r))}),V(this,"formatUriFromPairing",s=>{this.isInitialized();const{topic:r,relay:n,expiry:o,methods:a}=s,c=this.core.crypto.keychain.get(r);return Ya({protocol:this.core.protocol,version:this.core.version,topic:r,symKey:c,relay:n,expiryTimestamp:o,methods:a})}),V(this,"sendRequest",async(s,r,n)=>{const o=jt(r,n),a=await this.core.crypto.encode(s,o),c=Zi[r].req;return this.core.history.set(s,o),this.core.relayer.publish(s,a,c),o.id}),V(this,"sendResult",async(s,r,n)=>{const o=rr(s,n),a=await this.core.crypto.encode(r,o),c=(await this.core.history.get(r,s)).request.method,h=Zi[c].res;await this.core.relayer.publish(r,a,h),await this.core.history.resolve(o)}),V(this,"sendError",async(s,r,n)=>{const o=nr(s,n),a=await this.core.crypto.encode(r,o),c=(await this.core.history.get(r,s)).request.method,h=Zi[c]?Zi[c].res:Zi.unregistered_method.res;await this.core.relayer.publish(r,a,h),await this.core.history.resolve(o)}),V(this,"deletePairing",async(s,r)=>{await this.core.relayer.unsubscribe(s),await Promise.all([this.pairings.delete(s,te("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(s),r?Promise.resolve():this.core.expirer.del(s)])}),V(this,"cleanup",async()=>{const s=this.pairings.getAll().filter(r=>Bt(r.expiry));await Promise.all(s.map(r=>this.deletePairing(r.topic)))}),V(this,"onRelayEventRequest",async s=>{const{topic:r,payload:n}=s;switch(n.method){case"wc_pairingPing":return await this.onPairingPingRequest(r,n);case"wc_pairingDelete":return await this.onPairingDeleteRequest(r,n);default:return await this.onUnknownRpcMethodRequest(r,n)}}),V(this,"onRelayEventResponse",async s=>{const{topic:r,payload:n}=s,o=(await this.core.history.get(r,n.id)).request.method;switch(o){case"wc_pairingPing":return this.onPairingPingResponse(r,n);default:return this.onUnknownRpcMethodResponse(o)}}),V(this,"onPairingPingRequest",async(s,r)=>{const{id:n}=r;try{this.isValidPing({topic:s}),await this.sendResult(n,s,!0),this.events.emit(Wt.ping,{id:n,topic:s})}catch(o){await this.sendError(n,s,o),this.logger.error(o)}}),V(this,"onPairingPingResponse",(s,r)=>{const{id:n}=r;setTimeout(()=>{yt(r)?this.events.emit(X("pairing_ping",n),{}):Ze(r)&&this.events.emit(X("pairing_ping",n),{error:r.error})},500)}),V(this,"onPairingDeleteRequest",async(s,r)=>{const{id:n}=r;try{this.isValidDisconnect({topic:s}),await this.deletePairing(s),this.events.emit(Wt.delete,{id:n,topic:s})}catch(o){await this.sendError(n,s,o),this.logger.error(o)}}),V(this,"onUnknownRpcMethodRequest",async(s,r)=>{const{id:n,method:o}=r;try{if(this.registeredMethods.includes(o))return;const a=te("WC_METHOD_UNSUPPORTED",o);await this.sendError(n,s,a),this.logger.error(a)}catch(a){await this.sendError(n,s,a),this.logger.error(a)}}),V(this,"onUnknownRpcMethodResponse",s=>{this.registeredMethods.includes(s)||this.logger.error(te("WC_METHOD_UNSUPPORTED",s))}),V(this,"isValidPair",(s,r)=>{var n;if(!je(s)){const{message:a}=D("MISSING_OR_INVALID",`pair() params: ${s}`);throw r.setError(Pt.malformed_pairing_uri),new Error(a)}if(!ev(s.uri)){const{message:a}=D("MISSING_OR_INVALID",`pair() uri: ${s.uri}`);throw r.setError(Pt.malformed_pairing_uri),new Error(a)}const o=Ja(s?.uri);if(!((n=o?.relay)!=null&&n.protocol)){const{message:a}=D("MISSING_OR_INVALID","pair() uri#relay-protocol");throw r.setError(Pt.malformed_pairing_uri),new Error(a)}if(!(o!=null&&o.symKey)){const{message:a}=D("MISSING_OR_INVALID","pair() uri#symKey");throw r.setError(Pt.malformed_pairing_uri),new Error(a)}if(o!=null&&o.expiryTimestamp&&T.toMiliseconds(o?.expiryTimestamp)<Date.now()){r.setError(Pt.pairing_expired);const{message:a}=D("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(a)}}),V(this,"isValidPing",async s=>{if(!je(s)){const{message:n}=D("MISSING_OR_INVALID",`ping() params: ${s}`);throw new Error(n)}const{topic:r}=s;await this.isValidPairingTopic(r)}),V(this,"isValidDisconnect",async s=>{if(!je(s)){const{message:n}=D("MISSING_OR_INVALID",`disconnect() params: ${s}`);throw new Error(n)}const{topic:r}=s;await this.isValidPairingTopic(r)}),V(this,"isValidPairingTopic",async s=>{if(!le(s,!1)){const{message:r}=D("MISSING_OR_INVALID",`pairing topic should be a string: ${s}`);throw new Error(r)}if(!this.pairings.keys.includes(s)){const{message:r}=D("NO_MATCHING_KEY",`pairing topic doesn't exist: ${s}`);throw new Error(r)}if(Bt(this.pairings.get(s).expiry)){await this.deletePairing(s);const{message:r}=D("EXPIRED",`pairing topic: ${s}`);throw new Error(r)}}),this.core=e,this.logger=Ne(t,this.name),this.pairings=new ai(this.core,this.logger,this.name,this.storagePrefix)}get context(){return Ve(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(me.message,async e=>{const{topic:t,message:s,transportType:r}=e;if(this.pairings.keys.includes(t)&&r!==oe.link_mode&&!this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))try{const n=await this.core.crypto.decode(t,s);Hn(n)?(this.core.history.set(t,n),await this.onRelayEventRequest({topic:t,payload:n})):or(n)&&(await this.core.history.resolve(n),await this.onRelayEventResponse({topic:t,payload:n}),this.core.history.delete(t,n.id)),await this.core.relayer.messages.ack(t,s)}catch(n){this.logger.error(n)}})}registerExpirerEvents(){this.core.expirer.on(Ye.expired,async e=>{const{topic:t}=sl(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(Wt.expire,{topic:t}))})}}var fI=Object.defineProperty,gI=(i,e,t)=>e in i?fI(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,$e=(i,e,t)=>gI(i,typeof e!="symbol"?e+"":e,t);class yI extends Bv{constructor(e,t){super(e,t),this.core=e,this.logger=t,$e(this,"records",new Map),$e(this,"events",new Xe.EventEmitter),$e(this,"name",w0),$e(this,"version",b0),$e(this,"cached",[]),$e(this,"initialized",!1),$e(this,"storagePrefix",bt),$e(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.records.set(s.id,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),$e(this,"set",(s,r,n)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:s,request:r,chainId:n}),this.records.has(r.id))return;const o={id:r.id,topic:s,request:{method:r.method,params:r.params||null},chainId:n,expiry:ue(T.THIRTY_DAYS)};this.records.set(o.id,o),this.persist(),this.events.emit(st.created,o)}),$e(this,"resolve",async s=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:s}),!this.records.has(s.id))return;const r=await this.getRecord(s.id);typeof r.response>"u"&&(r.response=Ze(s)?{error:s.error}:{result:s.result},this.records.set(r.id,r),this.persist(),this.events.emit(st.updated,r))}),$e(this,"get",async(s,r)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:s,id:r}),await this.getRecord(r))),$e(this,"delete",(s,r)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:r}),this.values.forEach(n=>{if(n.topic===s){if(typeof r<"u"&&n.id!==r)return;this.records.delete(n.id),this.events.emit(st.deleted,n)}}),this.persist()}),$e(this,"exists",async(s,r)=>(this.isInitialized(),this.records.has(r)?(await this.getRecord(r)).topic===s:!1)),$e(this,"on",(s,r)=>{this.events.on(s,r)}),$e(this,"once",(s,r)=>{this.events.once(s,r)}),$e(this,"off",(s,r)=>{this.events.off(s,r)}),$e(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.logger=Ne(t,this.name)}get context(){return Ve(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const s={topic:t.topic,request:jt(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(s)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:s}=D("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(st.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=D("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(st.created,e=>{const t=st.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(st.updated,e=>{const t=st.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(st.deleted,e=>{const t=st.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.core.heartbeat.on(oi.pulse,()=>{this.cleanup()})}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach(t=>{T.toMiliseconds(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(st.deleted,t,!1),e=!0)}),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}}var mI=Object.defineProperty,wI=(i,e,t)=>e in i?mI(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Oe=(i,e,t)=>wI(i,typeof e!="symbol"?e+"":e,t);class bI extends Lv{constructor(e,t){super(e,t),this.core=e,this.logger=t,Oe(this,"expirations",new Map),Oe(this,"events",new Xe.EventEmitter),Oe(this,"name",v0),Oe(this,"version",E0),Oe(this,"cached",[]),Oe(this,"initialized",!1),Oe(this,"storagePrefix",bt),Oe(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.expirations.set(s.target,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),Oe(this,"has",s=>{try{const r=this.formatTarget(s);return typeof this.getExpiration(r)<"u"}catch{return!1}}),Oe(this,"set",(s,r)=>{this.isInitialized();const n=this.formatTarget(s),o={target:n,expiry:r};this.expirations.set(n,o),this.checkExpiry(n,o),this.events.emit(Ye.created,{target:n,expiration:o})}),Oe(this,"get",s=>{this.isInitialized();const r=this.formatTarget(s);return this.getExpiration(r)}),Oe(this,"del",s=>{if(this.isInitialized(),this.has(s)){const r=this.formatTarget(s),n=this.getExpiration(r);this.expirations.delete(r),this.events.emit(Ye.deleted,{target:r,expiration:n})}}),Oe(this,"on",(s,r)=>{this.events.on(s,r)}),Oe(this,"once",(s,r)=>{this.events.once(s,r)}),Oe(this,"off",(s,r)=>{this.events.off(s,r)}),Oe(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.logger=Ne(t,this.name)}get context(){return Ve(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return sm(e);if(typeof e=="number")return rm(e);const{message:t}=D("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(Ye.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=D("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:s}=D("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(s),new Error(s)}return t}checkExpiry(e,t){const{expiry:s}=t;T.toMiliseconds(s)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(Ye.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(oi.pulse,()=>this.checkExpirations()),this.events.on(Ye.created,e=>{const t=Ye.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(Ye.expired,e=>{const t=Ye.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(Ye.deleted,e=>{const t=Ye.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}}var vI=Object.defineProperty,EI=(i,e,t)=>e in i?vI(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,he=(i,e,t)=>EI(i,typeof e!="symbol"?e+"":e,t);class II extends Mv{constructor(e,t,s){super(e,t,s),this.core=e,this.logger=t,this.store=s,he(this,"name",I0),he(this,"abortController"),he(this,"isDevEnv"),he(this,"verifyUrlV3",_0),he(this,"storagePrefix",bt),he(this,"version",Ll),he(this,"publicKey"),he(this,"fetchPromise"),he(this,"init",async()=>{var r;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&T.toMiliseconds((r=this.publicKey)==null?void 0:r.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()))}),he(this,"register",async r=>{if(!zi()||this.isDevEnv)return;const n=window.location.origin,{id:o,decryptedId:a}=r,c=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n}&id=${o}&decryptedId=${a}`;try{const h=Ni(),l=this.startAbortTimer(T.ONE_SECOND*5),u=await new Promise((d,f)=>{const p=()=>{window.removeEventListener("message",y),h.body.removeChild(g),f("attestation aborted")};this.abortController.signal.addEventListener("abort",p);const g=h.createElement("iframe");g.src=c,g.style.display="none",g.addEventListener("error",p,{signal:this.abortController.signal});const y=b=>{if(b.data&&typeof b.data=="string")try{const m=JSON.parse(b.data);if(m.type==="verify_attestation"){if(dn(m.attestation).payload.id!==o)return;clearInterval(l),h.body.removeChild(g),this.abortController.signal.removeEventListener("abort",p),window.removeEventListener("message",y),d(m.attestation===null?"":m.attestation)}}catch(m){this.logger.warn(m)}};h.body.appendChild(g),window.addEventListener("message",y,{signal:this.abortController.signal})});return this.logger.debug("jwt attestation",u),u}catch(h){this.logger.warn(h)}return""}),he(this,"resolve",async r=>{if(this.isDevEnv)return"";const{attestationId:n,hash:o,encryptedId:a}=r;if(n===""){this.logger.debug("resolve: attestationId is empty, skipping");return}if(n){if(dn(n).payload.id!==a)return;const h=await this.isValidJwtAttestation(n);if(h){if(!h.isVerified){this.logger.warn("resolve: jwt attestation: origin url not verified");return}return h}}if(!o)return;const c=this.getVerifyUrl(r?.verifyUrl);return this.fetchAttestation(o,c)}),he(this,"fetchAttestation",async(r,n)=>{this.logger.debug(`resolving attestation: ${r} from url: ${n}`);const o=this.startAbortTimer(T.ONE_SECOND*5),a=await fetch(`${n}/attestation/${r}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(o),a.status===200?await a.json():void 0}),he(this,"getVerifyUrl",r=>{let n=r||as;return P0.includes(n)||(this.logger.info(`verify url: ${n}, not included in trusted list, assigning default: ${as}`),n=as),n}),he(this,"fetchPublicKey",async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const r=this.startAbortTimer(T.FIVE_SECONDS),n=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(r),await n.json()}catch(r){this.logger.warn(r)}}),he(this,"persistPublicKey",async r=>{this.logger.debug("persisting public key to local storage",r),await this.store.setItem(this.storeKey,r),this.publicKey=r}),he(this,"removePublicKey",async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0}),he(this,"isValidJwtAttestation",async r=>{const n=await this.getPublicKey();try{if(n)return this.validateAttestation(r,n)}catch(a){this.logger.error(a),this.logger.warn("error validating attestation")}const o=await this.fetchAndPersistPublicKey();try{if(o)return this.validateAttestation(r,o)}catch(a){this.logger.error(a),this.logger.warn("error validating attestation")}}),he(this,"getPublicKey",async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey()),he(this,"fetchAndPersistPublicKey",async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise(async n=>{const o=await this.fetchPublicKey();o&&(await this.persistPublicKey(o),n(o))});const r=await this.fetchPromise;return this.fetchPromise=void 0,r}),he(this,"validateAttestation",(r,n)=>{const o=Tb(r,n.publicKey),a={hasExpired:T.toMiliseconds(o.exp)<Date.now(),payload:o};if(a.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:a.payload.origin,isScam:a.payload.isScam,isVerified:a.payload.isVerified}}),this.logger=Ne(t,this.name),this.abortController=new AbortController,this.isDevEnv=Xn(),this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return Ve(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),T.toMiliseconds(e))}}var $I=Object.defineProperty,_I=(i,e,t)=>e in i?$I(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Cc=(i,e,t)=>_I(i,typeof e!="symbol"?e+"":e,t);class PI extends Fv{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,Cc(this,"context",S0),Cc(this,"registerDeviceToken",async s=>{const{clientId:r,token:n,notificationType:o,enableEncrypted:a=!1}=s,c=`${x0}/${this.projectId}/clients`;await fetch(c,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:r,type:o,token:n,always_raw:a})})}),this.logger=Ne(t,this.context)}}var SI=Object.defineProperty,Rc=Object.getOwnPropertySymbols,xI=Object.prototype.hasOwnProperty,OI=Object.prototype.propertyIsEnumerable,Bn=(i,e,t)=>e in i?SI(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,es=(i,e)=>{for(var t in e||(e={}))xI.call(e,t)&&Bn(i,t,e[t]);if(Rc)for(var t of Rc(e))OI.call(e,t)&&Bn(i,t,e[t]);return i},pe=(i,e,t)=>Bn(i,typeof e!="symbol"?e+"":e,t);class AI extends zv{constructor(e,t,s=!0){super(e,t,s),this.core=e,this.logger=t,pe(this,"context",A0),pe(this,"storagePrefix",bt),pe(this,"storageVersion",O0),pe(this,"events",new Map),pe(this,"shouldPersist",!1),pe(this,"init",async()=>{if(!Xn())try{const r={eventId:ba(),timestamp:Date.now(),domain:this.getAppDomain(),props:{event:"INIT",type:"",properties:{client_id:await this.core.crypto.getClientId(),user_agent:tl(this.core.relayer.protocol,this.core.relayer.version,Sn)}}};await this.sendEvent([r])}catch(r){this.logger.warn(r)}}),pe(this,"createEvent",r=>{const{event:n="ERROR",type:o="",properties:{topic:a,trace:c}}=r,h=ba(),l=this.core.projectId||"",u=Date.now(),d=es({eventId:h,timestamp:u,props:{event:n,type:o,properties:{topic:a,trace:c}},bundleId:l,domain:this.getAppDomain()},this.setMethods(h));return this.telemetryEnabled&&(this.events.set(h,d),this.shouldPersist=!0),d}),pe(this,"getEvent",r=>{const{eventId:n,topic:o}=r;if(n)return this.events.get(n);const a=Array.from(this.events.values()).find(c=>c.props.properties.topic===o);if(a)return es(es({},a),this.setMethods(a.eventId))}),pe(this,"deleteEvent",r=>{const{eventId:n}=r;this.events.delete(n),this.shouldPersist=!0}),pe(this,"setEventListeners",()=>{this.core.heartbeat.on(oi.pulse,async()=>{this.shouldPersist&&await this.persist(),this.events.forEach(r=>{T.fromMiliseconds(Date.now())-T.fromMiliseconds(r.timestamp)>C0&&(this.events.delete(r.eventId),this.shouldPersist=!0)})})}),pe(this,"setMethods",r=>({addTrace:n=>this.addTrace(r,n),setError:n=>this.setError(r,n)})),pe(this,"addTrace",(r,n)=>{const o=this.events.get(r);o&&(o.props.properties.trace.push(n),this.events.set(r,o),this.shouldPersist=!0)}),pe(this,"setError",(r,n)=>{const o=this.events.get(r);o&&(o.props.type=n,o.timestamp=Date.now(),this.events.set(r,o),this.shouldPersist=!0)}),pe(this,"persist",async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1}),pe(this,"restore",async()=>{try{const r=await this.core.storage.getItem(this.storageKey)||[];if(!r.length)return;r.forEach(n=>{this.events.set(n.eventId,es(es({},n),this.setMethods(n.eventId)))})}catch(r){this.logger.warn(r)}}),pe(this,"submit",async()=>{if(!this.telemetryEnabled||this.events.size===0)return;const r=[];for(const[n,o]of this.events)o.props.type&&r.push(o);if(r.length!==0)try{if((await this.sendEvent(r)).ok)for(const n of r)this.events.delete(n.eventId),this.shouldPersist=!0}catch(n){this.logger.warn(n)}}),pe(this,"sendEvent",async r=>{const n=this.getAppDomain()?"":"&sp=desktop";return await fetch(`${R0}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Sn}${n}`,{method:"POST",body:JSON.stringify(r)})}),pe(this,"getAppDomain",()=>el().url),this.logger=Ne(t,this.context),this.telemetryEnabled=s,s?this.restore().then(async()=>{await this.submit(),this.setEventListeners()}):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}}var CI=Object.defineProperty,Nc=Object.getOwnPropertySymbols,RI=Object.prototype.hasOwnProperty,NI=Object.prototype.propertyIsEnumerable,Dn=(i,e,t)=>e in i?CI(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Tc=(i,e)=>{for(var t in e||(e={}))RI.call(e,t)&&Dn(i,t,e[t]);if(Nc)for(var t of Nc(e))NI.call(e,t)&&Dn(i,t,e[t]);return i},ne=(i,e,t)=>Dn(i,typeof e!="symbol"?e+"":e,t);let TI=class eu extends Cv{constructor(e){var t;super(e),ne(this,"protocol",Ul),ne(this,"version",Ll),ne(this,"name",Pn),ne(this,"relayUrl"),ne(this,"projectId"),ne(this,"customStoragePrefix"),ne(this,"events",new Xe.EventEmitter),ne(this,"logger"),ne(this,"heartbeat"),ne(this,"relayer"),ne(this,"crypto"),ne(this,"storage"),ne(this,"history"),ne(this,"expirer"),ne(this,"pairing"),ne(this,"verify"),ne(this,"echoClient"),ne(this,"linkModeSupportedApps"),ne(this,"eventClient"),ne(this,"initialized",!1),ne(this,"logChunkController"),ne(this,"on",(a,c)=>this.events.on(a,c)),ne(this,"once",(a,c)=>this.events.once(a,c)),ne(this,"off",(a,c)=>this.events.off(a,c)),ne(this,"removeListener",(a,c)=>this.events.removeListener(a,c)),ne(this,"dispatchEnvelope",({topic:a,message:c,sessionExists:h})=>{if(!a||!c)return;const l={topic:a,message:c,publishedAt:Date.now(),transportType:oe.link_mode};this.relayer.onLinkMessageEvent(l,{sessionExists:h})});const s=this.getGlobalCore(e?.customStoragePrefix);if(s)try{return this.customStoragePrefix=s.customStoragePrefix,this.logger=s.logger,this.heartbeat=s.heartbeat,this.crypto=s.crypto,this.history=s.history,this.expirer=s.expirer,this.storage=s.storage,this.relayer=s.relayer,this.pairing=s.pairing,this.verify=s.verify,this.echoClient=s.echoClient,this.linkModeSupportedApps=s.linkModeSupportedApps,this.eventClient=s.eventClient,this.initialized=s.initialized,this.logChunkController=s.logChunkController,s}catch{}this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||Fl,this.customStoragePrefix=e!=null&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const r=sr({level:typeof e?.logger=="string"&&e.logger?e.logger:Xv.logger,name:Pn}),{logger:n,chunkLoggerController:o}=Uu({opts:r,maxSizeInBytes:e?.maxLogBlobSizeInBytes,loggerOverride:e?.logger});this.logChunkController=o,(t=this.logChunkController)!=null&&t.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var a,c;(a=this.logChunkController)!=null&&a.downloadLogsBlobInBrowser&&((c=this.logChunkController)==null||c.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=Ne(n,this.name),this.heartbeat=new Dd,this.crypto=new oE(this,this.logger,e?.keychain),this.history=new yI(this,this.logger),this.expirer=new bI(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new Td(Tc(Tc({},e0),e?.storageOptions)),this.relayer=new TE({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new pI(this,this.logger),this.verify=new II(this,this.logger,this.storage),this.echoClient=new PI(this.projectId||"",this.logger),this.linkModeSupportedApps=[],this.eventClient=new AI(this,this.logger,e?.telemetryEnabled),this.setGlobalCore(this)}static async init(e){const t=new eu(e);await t.initialize();const s=await t.crypto.getClientId();return await t.storage.setItem(p0,s),t}get context(){return Ve(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var e;return(e=this.logChunkController)==null?void 0:e.logsToBlob({clientId:await this.crypto.getClientId()})}async addLinkModeSupportedApp(e){this.linkModeSupportedApps.includes(e)||(this.linkModeSupportedApps.push(e),await this.storage.setItem(dc,this.linkModeSupportedApps))}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.linkModeSupportedApps=await this.storage.getItem(dc)||[],this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}getGlobalCore(e=""){try{if(this.isGlobalCoreDisabled())return;const t=`_walletConnectCore_${e}`,s=`${t}_count`;return globalThis[s]=(globalThis[s]||0)+1,globalThis[s]>1,globalThis[t]}catch{return}}setGlobalCore(e){var t;try{if(this.isGlobalCoreDisabled())return;const s=`_walletConnectCore_${((t=e.opts)==null?void 0:t.customStoragePrefix)||""}`;globalThis[s]=e}catch{}}isGlobalCoreDisabled(){try{return typeof process<"u"&&Qv.DISABLE_GLOBAL_CORE==="true"}catch{return!0}}};const BI=TI,tu="wc",iu=2,su="client",ao=`${tu}@${iu}:${su}:`,Zr={name:su,logger:"error"},Bc="WALLETCONNECT_DEEPLINK_CHOICE",DI="proposal",Dc="Proposal expired",jI="session",gi=T.SEVEN_DAYS,kI="engine",fe={wc_sessionPropose:{req:{ttl:T.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1104},res:{ttl:T.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1106},res:{ttl:T.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:T.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:T.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1112},res:{ttl:T.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1114},res:{ttl:T.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:T.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:T.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1119}}},Qr={min:T.FIVE_MINUTES,max:T.SEVEN_DAYS},pt={idle:"IDLE",active:"ACTIVE"},jc={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},qI="request",UI=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],LI="wc",MI="auth",FI="authKeys",zI="pairingTopics",HI="requests",wr=`${LI}@${1.5}:${MI}:`,Vs=`${wr}:PUB_KEY`;var KI=Object.defineProperty,VI=Object.defineProperties,WI=Object.getOwnPropertyDescriptors,kc=Object.getOwnPropertySymbols,GI=Object.prototype.hasOwnProperty,JI=Object.prototype.propertyIsEnumerable,jn=(i,e,t)=>e in i?KI(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,se=(i,e)=>{for(var t in e||(e={}))GI.call(e,t)&&jn(i,t,e[t]);if(kc)for(var t of kc(e))JI.call(e,t)&&jn(i,t,e[t]);return i},Ce=(i,e)=>VI(i,WI(e)),R=(i,e,t)=>jn(i,typeof e!="symbol"?e+"":e,t);class YI extends Wv{constructor(e){super(e),R(this,"name",kI),R(this,"events",new Fn),R(this,"initialized",!1),R(this,"requestQueue",{state:pt.idle,queue:[]}),R(this,"sessionRequestQueue",{state:pt.idle,queue:[]}),R(this,"requestQueueDelay",T.ONE_SECOND),R(this,"expectedPairingMethodMap",new Map),R(this,"recentlyDeletedMap",new Map),R(this,"recentlyDeletedLimit",200),R(this,"relayMessageCache",[]),R(this,"pendingSessions",new Map),R(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(fe)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},T.toMiliseconds(this.requestQueueDelay)))}),R(this,"connect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const s=Ce(se({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(s),s.optionalNamespaces=Jb(s.requiredNamespaces,s.optionalNamespaces),s.requiredNamespaces={};const{pairingTopic:r,requiredNamespaces:n,optionalNamespaces:o,sessionProperties:a,scopedProperties:c,relays:h}=s;let l=r,u,d=!1;try{if(l){const S=this.client.core.pairing.pairings.get(l);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),d=S.active}}catch(S){throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`),S}if(!l||!d){const{topic:S,uri:x}=await this.client.core.pairing.create();l=S,u=x}if(!l){const{message:S}=D("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(S)}const f=await this.client.core.crypto.generateKeyPair(),p=fe.wc_sessionPropose.req.ttl||T.FIVE_MINUTES,g=ue(p),y=Ce(se(se({requiredNamespaces:n,optionalNamespaces:o,relays:h??[{protocol:Ml}],proposer:{publicKey:f,metadata:this.client.metadata},expiryTimestamp:g,pairingTopic:l},a&&{sessionProperties:a}),c&&{scopedProperties:c}),{id:gt()}),b=X("session_connect",y.id),{reject:m,resolve:w,done:$}=zt(p,Dc),A=({id:S})=>{S===y.id&&(this.client.events.off("proposal_expire",A),this.pendingSessions.delete(y.id),this.events.emit(b,{error:{message:Dc,code:0}}))};return this.client.events.on("proposal_expire",A),this.events.once(b,({error:S,session:x})=>{this.client.events.off("proposal_expire",A),S?m(S):x&&w(x)}),await this.sendRequest({topic:l,method:"wc_sessionPropose",params:y,throwOnFailedPublish:!0,clientRpcId:y.id}),await this.setProposal(y.id,y),{uri:u,approval:$}}),R(this,"pair",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(t)}catch(s){throw this.client.logger.error("pair() failed"),s}}),R(this,"approve",async t=>{var s,r,n;const o=this.client.core.eventClient.createEvent({properties:{topic:(s=t?.id)==null?void 0:s.toString(),trace:[rt.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(_){throw o.setError(Mt.no_internet_connection),_}try{await this.isValidProposalId(t?.id)}catch(_){throw this.client.logger.error(`approve() -> proposal.get(${t?.id}) failed`),o.setError(Mt.proposal_not_found),_}try{await this.isValidApprove(t)}catch(_){throw this.client.logger.error("approve() -> isValidApprove() failed"),o.setError(Mt.session_approve_namespace_validation_failure),_}const{id:a,relayProtocol:c,namespaces:h,sessionProperties:l,scopedProperties:u,sessionConfig:d}=t,f=this.client.proposal.get(a);this.client.core.eventClient.deleteEvent({eventId:o.eventId});const{pairingTopic:p,proposer:g,requiredNamespaces:y,optionalNamespaces:b}=f;let m=(r=this.client.core.eventClient)==null?void 0:r.getEvent({topic:p});m||(m=(n=this.client.core.eventClient)==null?void 0:n.createEvent({type:rt.session_approve_started,properties:{topic:p,trace:[rt.session_approve_started,rt.session_namespaces_validation_success]}}));const w=await this.client.core.crypto.generateKeyPair(),$=g.publicKey,A=await this.client.core.crypto.generateSharedKey(w,$),S=se(se(se({relay:{protocol:c??"irn"},namespaces:h,controller:{publicKey:w,metadata:this.client.metadata},expiry:ue(gi)},l&&{sessionProperties:l}),u&&{scopedProperties:u}),d&&{sessionConfig:d}),x=oe.relay;m.addTrace(rt.subscribing_session_topic);try{await this.client.core.relayer.subscribe(A,{transportType:x})}catch(_){throw m.setError(Mt.subscribe_session_topic_failure),_}m.addTrace(rt.subscribe_session_topic_success);const N=Ce(se({},S),{topic:A,requiredNamespaces:y,optionalNamespaces:b,pairingTopic:p,acknowledged:!1,self:S.controller,peer:{publicKey:g.publicKey,metadata:g.metadata},controller:w,transportType:oe.relay});await this.client.session.set(A,N),m.addTrace(rt.store_session);try{m.addTrace(rt.publishing_session_settle),await this.sendRequest({topic:A,method:"wc_sessionSettle",params:S,throwOnFailedPublish:!0}).catch(_=>{throw m?.setError(Mt.session_settle_publish_failure),_}),m.addTrace(rt.session_settle_publish_success),m.addTrace(rt.publishing_session_approve),await this.sendResult({id:a,topic:p,result:{relay:{protocol:c??"irn"},responderPublicKey:w},throwOnFailedPublish:!0}).catch(_=>{throw m?.setError(Mt.session_approve_publish_failure),_}),m.addTrace(rt.session_approve_publish_success)}catch(_){throw this.client.logger.error(_),this.client.session.delete(A,te("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(A),_}return this.client.core.eventClient.deleteEvent({eventId:m.eventId}),await this.client.core.pairing.updateMetadata({topic:p,metadata:g.metadata}),await this.client.proposal.delete(a,te("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:p}),await this.setExpiry(A,ue(gi)),{topic:A,acknowledged:()=>Promise.resolve(this.client.session.get(A))}}),R(this,"reject",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(t)}catch(o){throw this.client.logger.error("reject() -> isValidReject() failed"),o}const{id:s,reason:r}=t;let n;try{n=this.client.proposal.get(s).pairingTopic}catch(o){throw this.client.logger.error(`reject() -> proposal.get(${s}) failed`),o}n&&(await this.sendError({id:s,topic:n,error:r,rpcOpts:fe.wc_sessionPropose.reject}),await this.client.proposal.delete(s,te("USER_DISCONNECTED")))}),R(this,"update",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(t)}catch(u){throw this.client.logger.error("update() -> isValidUpdate() failed"),u}const{topic:s,namespaces:r}=t,{done:n,resolve:o,reject:a}=zt(),c=gt(),h=Jt().toString(),l=this.client.session.get(s).namespaces;return this.events.once(X("session_update",c),({error:u})=>{u?a(u):o()}),await this.client.session.update(s,{namespaces:r}),await this.sendRequest({topic:s,method:"wc_sessionUpdate",params:{namespaces:r},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:h}).catch(u=>{this.client.logger.error(u),this.client.session.update(s,{namespaces:l}),a(u)}),{acknowledged:n}}),R(this,"extend",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:s}=t,r=gt(),{done:n,resolve:o,reject:a}=zt();return this.events.once(X("session_extend",r),({error:c})=>{c?a(c):o()}),await this.setExpiry(s,ue(gi)),this.sendRequest({topic:s,method:"wc_sessionExtend",params:{},clientRpcId:r,throwOnFailedPublish:!0}).catch(c=>{a(c)}),{acknowledged:n}}),R(this,"request",async t=>{this.isInitialized();try{await this.isValidRequest(t)}catch(b){throw this.client.logger.error("request() -> isValidRequest() failed"),b}const{chainId:s,request:r,topic:n,expiry:o=fe.wc_sessionRequest.req.ttl}=t,a=this.client.session.get(n);a?.transportType===oe.relay&&await this.confirmOnlineStateOrThrow();const c=gt(),h=Jt().toString(),{done:l,resolve:u,reject:d}=zt(o,"Request expired. Please try again.");this.events.once(X("session_request",c),({error:b,result:m})=>{b?d(b):u(m)});const f="wc_sessionRequest",p=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);if(p)return await this.sendRequest({clientRpcId:c,relayRpcId:h,topic:n,method:f,params:{request:Ce(se({},r),{expiryTimestamp:ue(o)}),chainId:s},expiry:o,throwOnFailedPublish:!0,appLink:p}).catch(b=>d(b)),this.client.events.emit("session_request_sent",{topic:n,request:r,chainId:s,id:c}),await l();const g={request:Ce(se({},r),{expiryTimestamp:ue(o)}),chainId:s},y=this.shouldSetTVF(f,g);return await Promise.all([new Promise(async b=>{await this.sendRequest(se({clientRpcId:c,relayRpcId:h,topic:n,method:f,params:g,expiry:o,throwOnFailedPublish:!0},y&&{tvf:this.getTVFParams(c,g)})).catch(m=>d(m)),this.client.events.emit("session_request_sent",{topic:n,request:r,chainId:s,id:c}),b()}),new Promise(async b=>{var m;if(!((m=a.sessionConfig)!=null&&m.disableDeepLink)){const w=await cm(this.client.core.storage,Bc);await nm({id:c,topic:n,wcDeepLink:w})}b()}),l()]).then(b=>b[2])}),R(this,"respond",async t=>{this.isInitialized(),await this.isValidRespond(t);const{topic:s,response:r}=t,{id:n}=r,o=this.client.session.get(s);o.transportType===oe.relay&&await this.confirmOnlineStateOrThrow();const a=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);yt(r)?await this.sendResult({id:n,topic:s,result:r.result,throwOnFailedPublish:!0,appLink:a}):Ze(r)&&await this.sendError({id:n,topic:s,error:r.error,appLink:a}),this.cleanupAfterResponse(t)}),R(this,"ping",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(t)}catch(r){throw this.client.logger.error("ping() -> isValidPing() failed"),r}const{topic:s}=t;if(this.client.session.keys.includes(s)){const r=gt(),n=Jt().toString(),{done:o,resolve:a,reject:c}=zt();this.events.once(X("session_ping",r),({error:h})=>{h?c(h):a()}),await Promise.all([this.sendRequest({topic:s,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:r,relayRpcId:n}),o()])}else this.client.core.pairing.pairings.keys.includes(s)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:s}))}),R(this,"emit",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(t);const{topic:s,event:r,chainId:n}=t,o=Jt().toString(),a=gt();await this.sendRequest({topic:s,method:"wc_sessionEvent",params:{event:r,chainId:n},throwOnFailedPublish:!0,relayRpcId:o,clientRpcId:a})}),R(this,"disconnect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(t);const{topic:s}=t;if(this.client.session.keys.includes(s))await this.sendRequest({topic:s,method:"wc_sessionDelete",params:te("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:s,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(s))await this.client.core.pairing.disconnect({topic:s});else{const{message:r}=D("MISMATCHED_TOPIC",`Session or pairing topic not found: ${s}`);throw new Error(r)}}),R(this,"find",t=>(this.isInitialized(),this.client.session.getAll().filter(s=>Qb(s,t)))),R(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),R(this,"authenticate",async(t,s)=>{var r;this.isInitialized(),this.isValidAuthenticate(t);const n=s&&this.client.core.linkModeSupportedApps.includes(s)&&((r=this.client.metadata.redirect)==null?void 0:r.linkMode),o=n?oe.link_mode:oe.relay;o===oe.relay&&await this.confirmOnlineStateOrThrow();const{chains:a,statement:c="",uri:h,domain:l,nonce:u,type:d,exp:f,nbf:p,methods:g=[],expiry:y}=t,b=[...t.resources||[]],{topic:m,uri:w}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:o});this.client.logger.info({message:"Generated new pairing",pairing:{topic:m,uri:w}});const $=await this.client.core.crypto.generateKeyPair(),A=Hs($);if(await Promise.all([this.client.auth.authKeys.set(Vs,{responseTopic:A,publicKey:$}),this.client.auth.pairingTopics.set(A,{topic:A,pairingTopic:m})]),await this.client.core.relayer.subscribe(A,{transportType:o}),this.client.logger.info(`sending request to new pairing topic: ${m}`),g.length>0){const{namespace:I}=Ri(a[0]);let B=ew(I,"request",g);zs(b)&&(B=iw(B,b.pop())),b.push(B)}const S=y&&y>fe.wc_sessionAuthenticate.req.ttl?y:fe.wc_sessionAuthenticate.req.ttl,x={authPayload:{type:d??"caip122",chains:a,statement:c,aud:h,domain:l,version:"1",nonce:u,iat:new Date().toISOString(),exp:f,nbf:p,resources:b},requester:{publicKey:$,metadata:this.client.metadata},expiryTimestamp:ue(S)},N={eip155:{chains:a,methods:[...new Set(["personal_sign",...g])],events:["chainChanged","accountsChanged"]}},_={requiredNamespaces:{},optionalNamespaces:N,relays:[{protocol:"irn"}],pairingTopic:m,proposer:{publicKey:$,metadata:this.client.metadata},expiryTimestamp:ue(fe.wc_sessionPropose.req.ttl),id:gt()},{done:L,resolve:j,reject:q}=zt(S,"Request expired"),M=gt(),C=X("session_connect",_.id),E=X("session_request",M),v=async({error:I,session:B})=>{this.events.off(E,P),I?q(I):B&&j({session:B})},P=async I=>{var B,k,U;if(await this.deletePendingAuthRequest(M,{message:"fulfilled",code:0}),I.error){const J=te("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return I.error.code===J.code?void 0:(this.events.off(C,v),q(I.error.message))}await this.deleteProposal(_.id),this.events.off(C,v);const{cacaos:F,responder:z}=I.result,K=[],G=[];for(const J of F){await xa({cacao:J,projectId:this.client.core.projectId})||(this.client.logger.error(J,"Signature verification failed"),q(te("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:xe}=J,ve=zs(xe.resources),Ae=[gn(xe.iss)],We=Zs(xe.iss);if(ve){const vt=Oa(ve),hi=Aa(ve);K.push(...vt),Ae.push(...hi)}for(const vt of Ae)G.push(`${vt}:${We}`)}const re=await this.client.core.crypto.generateSharedKey($,z.publicKey);let ee;K.length>0&&(ee={topic:re,acknowledged:!0,self:{publicKey:$,metadata:this.client.metadata},peer:z,controller:z.publicKey,expiry:ue(gi),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:m,namespaces:ec([...new Set(K)],[...new Set(G)]),transportType:o},await this.client.core.relayer.subscribe(re,{transportType:o}),await this.client.session.set(re,ee),m&&await this.client.core.pairing.updateMetadata({topic:m,metadata:z.metadata}),ee=this.client.session.get(re)),(B=this.client.metadata.redirect)!=null&&B.linkMode&&(k=z.metadata.redirect)!=null&&k.linkMode&&(U=z.metadata.redirect)!=null&&U.universal&&s&&(this.client.core.addLinkModeSupportedApp(z.metadata.redirect.universal),this.client.session.update(re,{transportType:oe.link_mode})),j({auths:F,session:ee})};this.events.once(C,v),this.events.once(E,P);let O;try{if(n){const I=jt("wc_sessionAuthenticate",x,M);this.client.core.history.set(m,I);const B=await this.client.core.crypto.encode("",I,{type:Is,encoding:Dt});O=Ts(s,m,B)}else await Promise.all([this.sendRequest({topic:m,method:"wc_sessionAuthenticate",params:x,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:M}),this.sendRequest({topic:m,method:"wc_sessionPropose",params:_,expiry:fe.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:_.id})])}catch(I){throw this.events.off(C,v),this.events.off(E,P),I}return await this.setProposal(_.id,_),await this.setAuthRequest(M,{request:Ce(se({},x),{verifyContext:{}}),pairingTopic:m,transportType:o}),{uri:O??w,response:L}}),R(this,"approveSessionAuthenticate",async t=>{const{id:s,auths:r}=t,n=this.client.core.eventClient.createEvent({properties:{topic:s.toString(),trace:[Ft.authenticated_session_approve_started]}});try{this.isInitialized()}catch(y){throw n.setError(Qi.no_internet_connection),y}const o=this.getPendingAuthRequest(s);if(!o)throw n.setError(Qi.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${s}`);const a=o.transportType||oe.relay;a===oe.relay&&await this.confirmOnlineStateOrThrow();const c=o.requester.publicKey,h=await this.client.core.crypto.generateKeyPair(),l=Hs(c),u={type:At,receiverPublicKey:c,senderPublicKey:h},d=[],f=[];for(const y of r){if(!await xa({cacao:y,projectId:this.client.core.projectId})){n.setError(Qi.invalid_cacao);const A=te("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:s,topic:l,error:A,encodeOpts:u}),new Error(A.message)}n.addTrace(Ft.cacaos_verified);const{p:b}=y,m=zs(b.resources),w=[gn(b.iss)],$=Zs(b.iss);if(m){const A=Oa(m),S=Aa(m);d.push(...A),w.push(...S)}for(const A of w)f.push(`${A}:${$}`)}const p=await this.client.core.crypto.generateSharedKey(h,c);n.addTrace(Ft.create_authenticated_session_topic);let g;if(d?.length>0){g={topic:p,acknowledged:!0,self:{publicKey:h,metadata:this.client.metadata},peer:{publicKey:c,metadata:o.requester.metadata},controller:c,expiry:ue(gi),authentication:r,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:o.pairingTopic,namespaces:ec([...new Set(d)],[...new Set(f)]),transportType:a},n.addTrace(Ft.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(p,{transportType:a})}catch(y){throw n.setError(Qi.subscribe_authenticated_session_topic_failure),y}n.addTrace(Ft.subscribe_authenticated_session_topic_success),await this.client.session.set(p,g),n.addTrace(Ft.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:o.pairingTopic,metadata:o.requester.metadata})}n.addTrace(Ft.publishing_authenticated_session_approve);try{await this.sendResult({topic:l,id:s,result:{cacaos:r,responder:{publicKey:h,metadata:this.client.metadata}},encodeOpts:u,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(o.requester.metadata,a)})}catch(y){throw n.setError(Qi.authenticated_session_approve_publish_failure),y}return await this.client.auth.requests.delete(s,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:o.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:n.eventId}),{session:g}}),R(this,"rejectSessionAuthenticate",async t=>{this.isInitialized();const{id:s,reason:r}=t,n=this.getPendingAuthRequest(s);if(!n)throw new Error(`Could not find pending auth request with id ${s}`);n.transportType===oe.relay&&await this.confirmOnlineStateOrThrow();const o=n.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=Hs(o),h={type:At,receiverPublicKey:o,senderPublicKey:a};await this.sendError({id:s,topic:c,error:r,encodeOpts:h,rpcOpts:fe.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(n.requester.metadata,n.transportType)}),await this.client.auth.requests.delete(s,{message:"rejected",code:0}),await this.client.proposal.delete(s,te("USER_DISCONNECTED"))}),R(this,"formatAuthMessage",t=>{this.isInitialized();const{request:s,iss:r}=t;return dl(s,r)}),R(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)}),R(this,"cleanupDuplicatePairings",async t=>{if(t.pairingTopic)try{const s=this.client.core.pairing.pairings.get(t.pairingTopic),r=this.client.core.pairing.pairings.getAll().filter(n=>{var o,a;return((o=n.peerMetadata)==null?void 0:o.url)&&((a=n.peerMetadata)==null?void 0:a.url)===t.peer.metadata.url&&n.topic&&n.topic!==s.topic});if(r.length===0)return;this.client.logger.info(`Cleaning up ${r.length} duplicate pairing(s)`),await Promise.all(r.map(n=>this.client.core.pairing.disconnect({topic:n.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(s){this.client.logger.error(s)}}),R(this,"deleteSession",async t=>{var s;const{topic:r,expirerHasDeleted:n=!1,emitEvent:o=!0,id:a=0}=t,{self:c}=this.client.session.get(r);await this.client.core.relayer.unsubscribe(r),await this.client.session.delete(r,te("USER_DISCONNECTED")),this.addToRecentlyDeleted(r,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(r)&&await this.client.core.crypto.deleteSymKey(r),n||this.client.core.expirer.del(r),this.client.core.storage.removeItem(Bc).catch(h=>this.client.logger.warn(h)),this.getPendingSessionRequests().forEach(h=>{h.topic===r&&this.deletePendingSessionRequest(h.id,te("USER_DISCONNECTED"))}),r===((s=this.sessionRequestQueue.queue[0])==null?void 0:s.topic)&&(this.sessionRequestQueue.state=pt.idle),o&&this.client.events.emit("session_delete",{id:a,topic:r})}),R(this,"deleteProposal",async(t,s)=>{if(s)try{const r=this.client.proposal.get(t);this.client.core.eventClient.getEvent({topic:r.pairingTopic})?.setError(Mt.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,te("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")}),R(this,"deletePendingSessionRequest",async(t,s,r=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,s),r?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(n=>n.id!==t),r&&(this.sessionRequestQueue.state=pt.idle,this.client.events.emit("session_request_expire",{id:t}))}),R(this,"deletePendingAuthRequest",async(t,s,r=!1)=>{await Promise.all([this.client.auth.requests.delete(t,s),r?Promise.resolve():this.client.core.expirer.del(t)])}),R(this,"setExpiry",async(t,s)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,s),await this.client.session.update(t,{expiry:s}))}),R(this,"setProposal",async(t,s)=>{this.client.core.expirer.set(t,ue(fe.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,s)}),R(this,"setAuthRequest",async(t,s)=>{const{request:r,pairingTopic:n,transportType:o=oe.relay}=s;this.client.core.expirer.set(t,r.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:r.authPayload,requester:r.requester,expiryTimestamp:r.expiryTimestamp,id:t,pairingTopic:n,verifyContext:r.verifyContext,transportType:o})}),R(this,"setPendingSessionRequest",async t=>{const{id:s,topic:r,params:n,verifyContext:o}=t,a=n.request.expiryTimestamp||ue(fe.wc_sessionRequest.req.ttl);this.client.core.expirer.set(s,a),await this.client.pendingRequest.set(s,{id:s,topic:r,params:n,verifyContext:o})}),R(this,"sendRequest",async t=>{const{topic:s,method:r,params:n,expiry:o,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:h,appLink:l,tvf:u}=t,d=jt(r,n,c);let f;const p=!!l;try{const b=p?Dt:at;f=await this.client.core.crypto.encode(s,d,{encoding:b})}catch(b){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${s} failed`),b}let g;if(UI.includes(r)){const b=mt(JSON.stringify(d)),m=mt(f);g=await this.client.core.verify.register({id:m,decryptedId:b})}const y=fe[r].req;if(y.attestation=g,o&&(y.ttl=o),a&&(y.id=a),this.client.core.history.set(s,d),p){const b=Ts(l,s,f);await global.Linking.openURL(b,this.client.name)}else{const b=fe[r].req;o&&(b.ttl=o),a&&(b.id=a),b.tvf=Ce(se({},u),{correlationId:d.id}),h?(b.internal=Ce(se({},b.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,f,b)):this.client.core.relayer.publish(s,f,b).catch(m=>this.client.logger.error(m))}return d.id}),R(this,"sendResult",async t=>{const{id:s,topic:r,result:n,throwOnFailedPublish:o,encodeOpts:a,appLink:c}=t,h=rr(s,n);let l;const u=c&&typeof(global==null?void 0:global.Linking)<"u";try{const p=u?Dt:at;l=await this.client.core.crypto.encode(r,h,Ce(se({},a||{}),{encoding:p}))}catch(p){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${r} failed`),p}let d,f;try{d=await this.client.core.history.get(r,s);const p=d.request;try{this.shouldSetTVF(p.method,p.params)&&(f=this.getTVFParams(s,p.params,n))}catch(g){this.client.logger.warn("sendResult() -> getTVFParams() failed",g)}}catch(p){throw this.client.logger.error(`sendResult() -> history.get(${r}, ${s}) failed`),p}if(u){const p=Ts(c,r,l);await global.Linking.openURL(p,this.client.name)}else{const p=d.request.method,g=fe[p].res;g.tvf=Ce(se({},f),{correlationId:s}),o?(g.internal=Ce(se({},g.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(r,l,g)):this.client.core.relayer.publish(r,l,g).catch(y=>this.client.logger.error(y))}await this.client.core.history.resolve(h)}),R(this,"sendError",async t=>{const{id:s,topic:r,error:n,encodeOpts:o,rpcOpts:a,appLink:c}=t,h=nr(s,n);let l;const u=c&&typeof(global==null?void 0:global.Linking)<"u";try{const f=u?Dt:at;l=await this.client.core.crypto.encode(r,h,Ce(se({},o||{}),{encoding:f}))}catch(f){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${r} failed`),f}let d;try{d=await this.client.core.history.get(r,s)}catch(f){throw this.client.logger.error(`sendError() -> history.get(${r}, ${s}) failed`),f}if(u){const f=Ts(c,r,l);await global.Linking.openURL(f,this.client.name)}else{const f=d.request.method,p=a||fe[f].res;this.client.core.relayer.publish(r,l,p)}await this.client.core.history.resolve(h)}),R(this,"cleanup",async()=>{const t=[],s=[];this.client.session.getAll().forEach(r=>{let n=!1;Bt(r.expiry)&&(n=!0),this.client.core.crypto.keychain.has(r.topic)||(n=!0),n&&t.push(r.topic)}),this.client.proposal.getAll().forEach(r=>{Bt(r.expiryTimestamp)&&s.push(r.id)}),await Promise.all([...t.map(r=>this.deleteSession({topic:r})),...s.map(r=>this.deleteProposal(r))])}),R(this,"onProviderMessageEvent",async t=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(t):await this.onRelayMessage(t)}),R(this,"onRelayEventRequest",async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()}),R(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===pt.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=pt.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(s){this.client.logger.warn(s)}}this.requestQueue.state=pt.idle}),R(this,"processRequest",async t=>{const{topic:s,payload:r,attestation:n,transportType:o,encryptedId:a}=t,c=r.method;if(!this.shouldIgnorePairingRequest({topic:s,requestMethod:c}))switch(c){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:s,payload:r,attestation:n,encryptedId:a});case"wc_sessionSettle":return await this.onSessionSettleRequest(s,r);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(s,r);case"wc_sessionExtend":return await this.onSessionExtendRequest(s,r);case"wc_sessionPing":return await this.onSessionPingRequest(s,r);case"wc_sessionDelete":return await this.onSessionDeleteRequest(s,r);case"wc_sessionRequest":return await this.onSessionRequest({topic:s,payload:r,attestation:n,encryptedId:a,transportType:o});case"wc_sessionEvent":return await this.onSessionEventRequest(s,r);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:s,payload:r,attestation:n,encryptedId:a,transportType:o});default:return this.client.logger.info(`Unsupported request method ${c}`)}}),R(this,"onRelayEventResponse",async t=>{const{topic:s,payload:r,transportType:n}=t,o=(await this.client.core.history.get(s,r.id)).request.method;switch(o){case"wc_sessionPropose":return this.onSessionProposeResponse(s,r,n);case"wc_sessionSettle":return this.onSessionSettleResponse(s,r);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,r);case"wc_sessionExtend":return this.onSessionExtendResponse(s,r);case"wc_sessionPing":return this.onSessionPingResponse(s,r);case"wc_sessionRequest":return this.onSessionRequestResponse(s,r);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(s,r);default:return this.client.logger.info(`Unsupported response method ${o}`)}}),R(this,"onRelayEventUnknownPayload",t=>{const{topic:s}=t,{message:r}=D("MISSING_OR_INVALID",`Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);throw new Error(r)}),R(this,"shouldIgnorePairingRequest",t=>{const{topic:s,requestMethod:r}=t,n=this.expectedPairingMethodMap.get(s);return!n||n.includes(r)?!1:!!(n.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),R(this,"onSessionProposeRequest",async t=>{const{topic:s,payload:r,attestation:n,encryptedId:o}=t,{params:a,id:c}=r;try{const h=this.client.core.eventClient.getEvent({topic:s});this.client.events.listenerCount("session_proposal")===0&&h?.setError(Pt.proposal_listener_not_found),this.isValidConnect(se({},r.params));const l=a.expiryTimestamp||ue(fe.wc_sessionPropose.req.ttl),u=se({id:c,pairingTopic:s,expiryTimestamp:l},a);await this.setProposal(c,u);const d=await this.getVerifyContext({attestationId:n,hash:mt(JSON.stringify(r)),encryptedId:o,metadata:u.proposer.metadata});h?.addTrace(ft.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:u,verifyContext:d})}catch(h){await this.sendError({id:c,topic:s,error:h,rpcOpts:fe.wc_sessionPropose.autoReject}),this.client.logger.error(h)}}),R(this,"onSessionProposeResponse",async(t,s,r)=>{const{id:n}=s;if(yt(s)){const{result:o}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:o});const a=this.client.proposal.get(n);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:a});const c=a.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const h=o.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:h});const l=await this.client.core.crypto.generateSharedKey(c,h);this.pendingSessions.set(n,{sessionTopic:l,pairingTopic:t,proposalId:n,publicKey:c});const u=await this.client.core.relayer.subscribe(l,{transportType:r});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:u}),await this.client.core.pairing.activate({topic:t})}else if(Ze(s)){await this.client.proposal.delete(n,te("USER_DISCONNECTED"));const o=X("session_connect",n);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners, 954`);this.events.emit(o,{error:s.error})}}),R(this,"onSessionSettleRequest",async(t,s)=>{const{id:r,params:n}=s;try{this.isValidSessionSettleRequest(n);const{relay:o,controller:a,expiry:c,namespaces:h,sessionProperties:l,scopedProperties:u,sessionConfig:d}=s.params,f=[...this.pendingSessions.values()].find(y=>y.sessionTopic===t);if(!f)return this.client.logger.error(`Pending session not found for topic ${t}`);const p=this.client.proposal.get(f.proposalId),g=Ce(se(se(se({topic:t,relay:o,expiry:c,namespaces:h,acknowledged:!0,pairingTopic:f.pairingTopic,requiredNamespaces:p.requiredNamespaces,optionalNamespaces:p.optionalNamespaces,controller:a.publicKey,self:{publicKey:f.publicKey,metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},l&&{sessionProperties:l}),u&&{scopedProperties:u}),d&&{sessionConfig:d}),{transportType:oe.relay});await this.client.session.set(g.topic,g),await this.setExpiry(g.topic,g.expiry),await this.client.core.pairing.updateMetadata({topic:f.pairingTopic,metadata:g.peer.metadata}),this.client.events.emit("session_connect",{session:g}),this.events.emit(X("session_connect",f.proposalId),{session:g}),this.pendingSessions.delete(f.proposalId),this.deleteProposal(f.proposalId,!1),this.cleanupDuplicatePairings(g),await this.sendResult({id:s.id,topic:t,result:!0,throwOnFailedPublish:!0})}catch(o){await this.sendError({id:r,topic:t,error:o}),this.client.logger.error(o)}}),R(this,"onSessionSettleResponse",async(t,s)=>{const{id:r}=s;yt(s)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(X("session_approve",r),{})):Ze(s)&&(await this.client.session.delete(t,te("USER_DISCONNECTED")),this.events.emit(X("session_approve",r),{error:s.error}))}),R(this,"onSessionUpdateRequest",async(t,s)=>{const{params:r,id:n}=s;try{const o=`${t}_session_update`,a=Yi.get(o);if(a&&this.isRequestOutOfSync(a,n)){this.client.logger.warn(`Discarding out of sync request - ${n}`),this.sendError({id:n,topic:t,error:te("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(se({topic:t},r));try{Yi.set(o,n),await this.client.session.update(t,{namespaces:r.namespaces}),await this.sendResult({id:n,topic:t,result:!0,throwOnFailedPublish:!0})}catch(c){throw Yi.delete(o),c}this.client.events.emit("session_update",{id:n,topic:t,params:r})}catch(o){await this.sendError({id:n,topic:t,error:o}),this.client.logger.error(o)}}),R(this,"isRequestOutOfSync",(t,s)=>s.toString().slice(0,-3)<t.toString().slice(0,-3)),R(this,"onSessionUpdateResponse",(t,s)=>{const{id:r}=s,n=X("session_update",r);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners`);yt(s)?this.events.emit(X("session_update",r),{}):Ze(s)&&this.events.emit(X("session_update",r),{error:s.error})}),R(this,"onSessionExtendRequest",async(t,s)=>{const{id:r}=s;try{this.isValidExtend({topic:t}),await this.setExpiry(t,ue(gi)),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:r,topic:t})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}}),R(this,"onSessionExtendResponse",(t,s)=>{const{id:r}=s,n=X("session_extend",r);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners`);yt(s)?this.events.emit(X("session_extend",r),{}):Ze(s)&&this.events.emit(X("session_extend",r),{error:s.error})}),R(this,"onSessionPingRequest",async(t,s)=>{const{id:r}=s;try{this.isValidPing({topic:t}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:r,topic:t})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}}),R(this,"onSessionPingResponse",(t,s)=>{const{id:r}=s,n=X("session_ping",r);setTimeout(()=>{if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners 2176`);yt(s)?this.events.emit(X("session_ping",r),{}):Ze(s)&&this.events.emit(X("session_ping",r),{error:s.error})},500)}),R(this,"onSessionDeleteRequest",async(t,s)=>{const{id:r}=s;try{this.isValidDisconnect({topic:t,reason:s.params}),Promise.all([new Promise(n=>{this.client.core.relayer.once(me.publish,async()=>{n(await this.deleteSession({topic:t,id:r}))})}),this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:te("USER_DISCONNECTED")})]).catch(n=>this.client.logger.error(n))}catch(n){this.client.logger.error(n)}}),R(this,"onSessionRequest",async t=>{var s,r,n;const{topic:o,payload:a,attestation:c,encryptedId:h,transportType:l}=t,{id:u,params:d}=a;try{await this.isValidRequest(se({topic:o},d));const f=this.client.session.get(o),p=await this.getVerifyContext({attestationId:c,hash:mt(JSON.stringify(jt("wc_sessionRequest",d,u))),encryptedId:h,metadata:f.peer.metadata,transportType:l}),g={id:u,topic:o,params:d,verifyContext:p};await this.setPendingSessionRequest(g),l===oe.link_mode&&(s=f.peer.metadata.redirect)!=null&&s.universal&&this.client.core.addLinkModeSupportedApp((r=f.peer.metadata.redirect)==null?void 0:r.universal),(n=this.client.signConfig)!=null&&n.disableRequestQueue?this.emitSessionRequest(g):(this.addSessionRequestToSessionRequestQueue(g),this.processSessionRequestQueue())}catch(f){await this.sendError({id:u,topic:o,error:f}),this.client.logger.error(f)}}),R(this,"onSessionRequestResponse",(t,s)=>{const{id:r}=s,n=X("session_request",r);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners`);yt(s)?this.events.emit(X("session_request",r),{result:s.result}):Ze(s)&&this.events.emit(X("session_request",r),{error:s.error})}),R(this,"onSessionEventRequest",async(t,s)=>{const{id:r,params:n}=s;try{const o=`${t}_session_event_${n.event.name}`,a=Yi.get(o);if(a&&this.isRequestOutOfSync(a,r)){this.client.logger.info(`Discarding out of sync request - ${r}`);return}this.isValidEmit(se({topic:t},n)),this.client.events.emit("session_event",{id:r,topic:t,params:n}),Yi.set(o,r)}catch(o){await this.sendError({id:r,topic:t,error:o}),this.client.logger.error(o)}}),R(this,"onSessionAuthenticateResponse",(t,s)=>{const{id:r}=s;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:s}),yt(s)?this.events.emit(X("session_request",r),{result:s.result}):Ze(s)&&this.events.emit(X("session_request",r),{error:s.error})}),R(this,"onSessionAuthenticateRequest",async t=>{var s;const{topic:r,payload:n,attestation:o,encryptedId:a,transportType:c}=t;try{const{requester:h,authPayload:l,expiryTimestamp:u}=n.params,d=await this.getVerifyContext({attestationId:o,hash:mt(JSON.stringify(n)),encryptedId:a,metadata:h.metadata,transportType:c}),f={requester:h,pairingTopic:r,id:n.id,authPayload:l,verifyContext:d,expiryTimestamp:u};await this.setAuthRequest(n.id,{request:f,pairingTopic:r,transportType:c}),c===oe.link_mode&&(s=h.metadata.redirect)!=null&&s.universal&&this.client.core.addLinkModeSupportedApp(h.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:r,params:n.params,id:n.id,verifyContext:d})}catch(h){this.client.logger.error(h);const l=n.params.requester.publicKey,u=await this.client.core.crypto.generateKeyPair(),d=this.getAppLinkIfEnabled(n.params.requester.metadata,c),f={type:At,receiverPublicKey:l,senderPublicKey:u};await this.sendError({id:n.id,topic:r,error:h,encodeOpts:f,rpcOpts:fe.wc_sessionAuthenticate.autoReject,appLink:d})}}),R(this,"addSessionRequestToSessionRequestQueue",t=>{this.sessionRequestQueue.queue.push(t)}),R(this,"cleanupAfterResponse",t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=pt.idle,this.processSessionRequestQueue()},T.toMiliseconds(this.requestQueueDelay))}),R(this,"cleanupPendingSentRequestsForTopic",({topic:t,error:s})=>{const r=this.client.core.history.pending;r.length>0&&r.filter(n=>n.topic===t&&n.request.method==="wc_sessionRequest").forEach(n=>{const o=n.request.id,a=X("session_request",o);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners`);this.events.emit(X("session_request",n.request.id),{error:s})})}),R(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===pt.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=pt.active,this.emitSessionRequest(t)}catch(s){this.client.logger.error(s)}}),R(this,"emitSessionRequest",t=>{this.client.events.emit("session_request",t)}),R(this,"onPairingCreated",t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const s=this.client.proposal.getAll().find(r=>r.pairingTopic===t.topic);s&&this.onSessionProposeRequest({topic:t.topic,payload:jt("wc_sessionPropose",Ce(se({},s),{requiredNamespaces:s.requiredNamespaces,optionalNamespaces:s.optionalNamespaces,relays:s.relays,proposer:s.proposer,sessionProperties:s.sessionProperties,scopedProperties:s.scopedProperties}),s.id)})}),R(this,"isValidConnect",async t=>{if(!je(t)){const{message:h}=D("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(h)}const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:o,scopedProperties:a,relays:c}=t;if(_e(s)||await this.isValidPairingTopic(s),!lv(c)){const{message:h}=D("MISSING_OR_INVALID",`connect() relays: ${c}`);throw new Error(h)}if(!_e(r)&&Ut(r)!==0&&(["fatal","error","silent"].includes(this.client.logger.level)||this.client.logger.warn("requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces"),this.validateNamespaces(r,"requiredNamespaces")),!_e(n)&&Ut(n)!==0&&this.validateNamespaces(n,"optionalNamespaces"),_e(o)||this.validateSessionProps(o,"sessionProperties"),!_e(a)){this.validateSessionProps(a,"scopedProperties");const h=Object.keys(r||{}).concat(Object.keys(n||{}));if(!Object.keys(a).every(l=>h.includes(l)))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(h)}`)}}),R(this,"validateNamespaces",(t,s)=>{const r=hv(t,"connect()",s);if(r)throw new Error(r.message)}),R(this,"isValidApprove",async t=>{if(!je(t))throw new Error(D("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:s,namespaces:r,relayProtocol:n,sessionProperties:o,scopedProperties:a}=t;this.checkRecentlyDeleted(s),await this.isValidProposalId(s);const c=this.client.proposal.get(s),h=Kr(r,"approve()");if(h)throw new Error(h.message);const l=sc(c.requiredNamespaces,r,"approve()");if(l)throw new Error(l.message);if(!le(n,!0)){const{message:u}=D("MISSING_OR_INVALID",`approve() relayProtocol: ${n}`);throw new Error(u)}if(_e(o)||this.validateSessionProps(o,"sessionProperties"),!_e(a)){this.validateSessionProps(a,"scopedProperties");const u=new Set(Object.keys(r));if(!Object.keys(a).every(d=>u.has(d)))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(u).join(", ")}`)}}),R(this,"isValidReject",async t=>{if(!je(t)){const{message:n}=D("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(n)}const{id:s,reason:r}=t;if(this.checkRecentlyDeleted(s),await this.isValidProposalId(s),!dv(r)){const{message:n}=D("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(r)}`);throw new Error(n)}}),R(this,"isValidSessionSettleRequest",t=>{if(!je(t)){const{message:h}=D("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(h)}const{relay:s,controller:r,namespaces:n,expiry:o}=t;if(!ql(s)){const{message:h}=D("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(h)}const a=sv(r,"onSessionSettleRequest()");if(a)throw new Error(a.message);const c=Kr(n,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(Bt(o)){const{message:h}=D("EXPIRED","onSessionSettleRequest()");throw new Error(h)}}),R(this,"isValidUpdate",async t=>{if(!je(t)){const{message:c}=D("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:s,namespaces:r}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s);const n=this.client.session.get(s),o=Kr(r,"update()");if(o)throw new Error(o.message);const a=sc(n.requiredNamespaces,r,"update()");if(a)throw new Error(a.message)}),R(this,"isValidExtend",async t=>{if(!je(t)){const{message:r}=D("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(r)}const{topic:s}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s)}),R(this,"isValidRequest",async t=>{if(!je(t)){const{message:c}=D("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:s,request:r,chainId:n,expiry:o}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s);const{namespaces:a}=this.client.session.get(s);if(!ic(a,n)){const{message:c}=D("MISSING_OR_INVALID",`request() chainId: ${n}`);throw new Error(c)}if(!pv(r)){const{message:c}=D("MISSING_OR_INVALID",`request() ${JSON.stringify(r)}`);throw new Error(c)}if(!yv(a,n,r.method)){const{message:c}=D("MISSING_OR_INVALID",`request() method: ${r.method}`);throw new Error(c)}if(o&&!vv(o,Qr)){const{message:c}=D("MISSING_OR_INVALID",`request() expiry: ${o}. Expiry must be a number (in seconds) between ${Qr.min} and ${Qr.max}`);throw new Error(c)}}),R(this,"isValidRespond",async t=>{var s;if(!je(t)){const{message:o}=D("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(o)}const{topic:r,response:n}=t;try{await this.isValidSessionTopic(r)}catch(o){throw(s=t?.response)!=null&&s.id&&this.cleanupAfterResponse(t),o}if(!fv(n)){const{message:o}=D("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(n)}`);throw new Error(o)}}),R(this,"isValidPing",async t=>{if(!je(t)){const{message:r}=D("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(r)}const{topic:s}=t;await this.isValidSessionOrPairingTopic(s)}),R(this,"isValidEmit",async t=>{if(!je(t)){const{message:a}=D("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(a)}const{topic:s,event:r,chainId:n}=t;await this.isValidSessionTopic(s);const{namespaces:o}=this.client.session.get(s);if(!ic(o,n)){const{message:a}=D("MISSING_OR_INVALID",`emit() chainId: ${n}`);throw new Error(a)}if(!gv(r)){const{message:a}=D("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(r)}`);throw new Error(a)}if(!mv(o,n,r.name)){const{message:a}=D("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(r)}`);throw new Error(a)}}),R(this,"isValidDisconnect",async t=>{if(!je(t)){const{message:r}=D("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(r)}const{topic:s}=t;await this.isValidSessionOrPairingTopic(s)}),R(this,"isValidAuthenticate",t=>{const{chains:s,uri:r,domain:n,nonce:o}=t;if(!Array.isArray(s)||s.length===0)throw new Error("chains is required and must be a non-empty array");if(!le(r,!1))throw new Error("uri is required parameter");if(!le(n,!1))throw new Error("domain is required parameter");if(!le(o,!1))throw new Error("nonce is required parameter");if([...new Set(s.map(c=>Ri(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:a}=Ri(s[0]);if(a!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),R(this,"getVerifyContext",async t=>{const{attestationId:s,hash:r,encryptedId:n,metadata:o,transportType:a}=t,c={verified:{verifyUrl:o.verifyUrl||as,validation:"UNKNOWN",origin:o.url||""}};try{if(a===oe.link_mode){const l=this.getAppLinkIfEnabled(o,a);return c.verified.validation=l&&new URL(l).origin===new URL(o.url).origin?"VALID":"INVALID",c}const h=await this.client.core.verify.resolve({attestationId:s,hash:r,encryptedId:n,verifyUrl:o.verifyUrl});h&&(c.verified.origin=h.origin,c.verified.isScam=h.isScam,c.verified.validation=h.origin===new URL(o.url).origin?"VALID":"INVALID")}catch(h){this.client.logger.warn(h)}return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),c}),R(this,"validateSessionProps",(t,s)=>{Object.values(t).forEach((r,n)=>{if(r==null){const{message:o}=D("MISSING_OR_INVALID",`${s} must contain an existing value for each key. Received: ${r} for key ${Object.keys(t)[n]}`);throw new Error(o)}})}),R(this,"getPendingAuthRequest",t=>{const s=this.client.auth.requests.get(t);return typeof s=="object"?s:void 0}),R(this,"addToRecentlyDeleted",(t,s)=>{if(this.recentlyDeletedMap.set(t,s),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let r=0;const n=this.recentlyDeletedLimit/2;for(const o of this.recentlyDeletedMap.keys()){if(r++>=n)break;this.recentlyDeletedMap.delete(o)}}}),R(this,"checkRecentlyDeleted",t=>{const s=this.recentlyDeletedMap.get(t);if(s){const{message:r}=D("MISSING_OR_INVALID",`Record was recently deleted - ${s}: ${t}`);throw new Error(r)}}),R(this,"isLinkModeEnabled",(t,s)=>{var r,n,o,a,c,h,l,u,d;return!t||s!==oe.link_mode?!1:((n=(r=this.client.metadata)==null?void 0:r.redirect)==null?void 0:n.linkMode)===!0&&((a=(o=this.client.metadata)==null?void 0:o.redirect)==null?void 0:a.universal)!==void 0&&((h=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:h.universal)!==""&&((l=t?.redirect)==null?void 0:l.universal)!==void 0&&((u=t?.redirect)==null?void 0:u.universal)!==""&&((d=t?.redirect)==null?void 0:d.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(t.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"}),R(this,"getAppLinkIfEnabled",(t,s)=>{var r;return this.isLinkModeEnabled(t,s)?(r=t?.redirect)==null?void 0:r.universal:void 0}),R(this,"handleLinkModeMessage",({url:t})=>{if(!t||!t.includes("wc_ev")||!t.includes("topic"))return;const s=wa(t,"topic")||"",r=decodeURIComponent(wa(t,"wc_ev")||""),n=this.client.session.keys.includes(s);n&&this.client.session.update(s,{transportType:oe.link_mode}),this.client.core.dispatchEnvelope({topic:s,message:r,sessionExists:n})}),R(this,"registerLinkModeListeners",async()=>{var t;if(Xn()||Lt()&&(t=this.client.metadata.redirect)!=null&&t.linkMode){const s=global==null?void 0:global.Linking;if(typeof s<"u"){s.addEventListener("url",this.handleLinkModeMessage,this.client.name);const r=await s.getInitialURL();r&&setTimeout(()=>{this.handleLinkModeMessage({url:r})},50)}}}),R(this,"shouldSetTVF",(t,s)=>{if(!s||t!=="wc_sessionRequest")return!1;const{request:r}=s;return Object.keys(jc).includes(r.method)}),R(this,"getTVFParams",(t,s,r)=>{var n,o;try{const a=s.request.method,c=this.extractTxHashesFromResult(a,r);return Ce(se({correlationId:t,rpcMethods:[a],chainId:s.chainId},this.isValidContractData(s.request.params)&&{contractAddresses:[(o=(n=s.request.params)==null?void 0:n[0])==null?void 0:o.to]}),{txHashes:c})}catch(a){this.client.logger.warn("Error getting TVF params",a)}return{}}),R(this,"isValidContractData",t=>{var s;if(!t)return!1;try{const r=t?.data||((s=t?.[0])==null?void 0:s.data);if(!r.startsWith("0x"))return!1;const n=r.slice(2);return/^[0-9a-fA-F]*$/.test(n)?n.length%2===0:!1}catch{}return!1}),R(this,"extractTxHashesFromResult",(t,s)=>{try{const r=jc[t];if(typeof s=="string")return[s];const n=s[r.key];if(ct(n))return t==="solana_signAllTransactions"?n.map(o=>Lm(o)):n;if(typeof n=="string")return[n]}catch(r){this.client.logger.warn("Error extracting tx hashes from result",r)}return[]})}async processPendingMessageEvents(){try{const e=this.client.session.keys,t=this.client.core.relayer.messages.getWithoutAck(e);for(const[s,r]of Object.entries(t))for(const n of r)try{await this.onProviderMessageEvent({topic:s,message:n,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${s}, message: ${n}`)}}catch(e){this.client.logger.warn("processPendingMessageEvents failed",e)}}isInitialized(){if(!this.initialized){const{message:e}=D("NOT_INITIALIZED",this.name);throw new Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(me.message,e=>{this.onProviderMessageEvent(e)})}async onRelayMessage(e){const{topic:t,message:s,attestation:r,transportType:n}=e,{publicKey:o}=this.client.auth.authKeys.keys.includes(Vs)?this.client.auth.authKeys.get(Vs):{publicKey:void 0};try{const a=await this.client.core.crypto.decode(t,s,{receiverPublicKey:o,encoding:n===oe.link_mode?Dt:at});Hn(a)?(this.client.core.history.set(t,a),await this.onRelayEventRequest({topic:t,payload:a,attestation:r,transportType:n,encryptedId:mt(s)})):or(a)?(await this.client.core.history.resolve(a),await this.onRelayEventResponse({topic:t,payload:a,transportType:n}),this.client.core.history.delete(t,a.id)):await this.onRelayEventUnknownPayload({topic:t,payload:a,transportType:n}),await this.client.core.relayer.messages.ack(t,s)}catch(a){this.client.logger.error(a)}}registerExpirerEvents(){this.client.core.expirer.on(Ye.expired,async e=>{const{topic:t,id:s}=sl(e.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,D("EXPIRED"),!0);if(s&&this.client.auth.requests.keys.includes(s))return await this.deletePendingAuthRequest(s,D("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}))})}registerPairingEvents(){this.client.core.pairing.events.on(Wt.create,e=>this.onPairingCreated(e)),this.client.core.pairing.events.on(Wt.delete,e=>{this.addToRecentlyDeleted(e.topic,"pairing")})}isValidPairingTopic(e){if(!le(e,!1)){const{message:t}=D("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=D("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if(Bt(this.client.core.pairing.pairings.get(e).expiry)){const{message:t}=D("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}}async isValidSessionTopic(e){if(!le(e,!1)){const{message:t}=D("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw new Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){const{message:t}=D("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw new Error(t)}if(Bt(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});const{message:t}=D("EXPIRED",`session topic: ${e}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(e)){const{message:t}=D("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),new Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else if(this.client.core.pairing.pairings.keys.includes(e))this.isValidPairingTopic(e);else if(le(e,!1)){const{message:t}=D("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw new Error(t)}else{const{message:t}=D("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw new Error(t)}}async isValidProposalId(e){if(!uv(e)){const{message:t}=D("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw new Error(t)}if(!this.client.proposal.keys.includes(e)){const{message:t}=D("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw new Error(t)}if(Bt(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);const{message:t}=D("EXPIRED",`proposal id: ${e}`);throw new Error(t)}}}class ZI extends ai{constructor(e,t){super(e,t,DI,ao),this.core=e,this.logger=t}}let QI=class extends ai{constructor(e,t){super(e,t,jI,ao),this.core=e,this.logger=t}};class XI extends ai{constructor(e,t){super(e,t,qI,ao,s=>s.id),this.core=e,this.logger=t}}class e$ extends ai{constructor(e,t){super(e,t,FI,wr,()=>Vs),this.core=e,this.logger=t}}class t$ extends ai{constructor(e,t){super(e,t,zI,wr),this.core=e,this.logger=t}}class i$ extends ai{constructor(e,t){super(e,t,HI,wr,s=>s.id),this.core=e,this.logger=t}}var s$=Object.defineProperty,r$=(i,e,t)=>e in i?s$(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Xr=(i,e,t)=>r$(i,typeof e!="symbol"?e+"":e,t);class n${constructor(e,t){this.core=e,this.logger=t,Xr(this,"authKeys"),Xr(this,"pairingTopics"),Xr(this,"requests"),this.authKeys=new e$(this.core,this.logger),this.pairingTopics=new t$(this.core,this.logger),this.requests=new i$(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var o$=Object.defineProperty,a$=(i,e,t)=>e in i?o$(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,W=(i,e,t)=>a$(i,typeof e!="symbol"?e+"":e,t);let c$=class ru extends Vv{constructor(e){super(e),W(this,"protocol",tu),W(this,"version",iu),W(this,"name",Zr.name),W(this,"metadata"),W(this,"core"),W(this,"logger"),W(this,"events",new Xe.EventEmitter),W(this,"engine"),W(this,"session"),W(this,"proposal"),W(this,"pendingRequest"),W(this,"auth"),W(this,"signConfig"),W(this,"on",(s,r)=>this.events.on(s,r)),W(this,"once",(s,r)=>this.events.once(s,r)),W(this,"off",(s,r)=>this.events.off(s,r)),W(this,"removeListener",(s,r)=>this.events.removeListener(s,r)),W(this,"removeAllListeners",s=>this.events.removeAllListeners(s)),W(this,"connect",async s=>{try{return await this.engine.connect(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"pair",async s=>{try{return await this.engine.pair(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"approve",async s=>{try{return await this.engine.approve(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"reject",async s=>{try{return await this.engine.reject(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"update",async s=>{try{return await this.engine.update(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"extend",async s=>{try{return await this.engine.extend(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"request",async s=>{try{return await this.engine.request(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"respond",async s=>{try{return await this.engine.respond(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"ping",async s=>{try{return await this.engine.ping(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"emit",async s=>{try{return await this.engine.emit(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"disconnect",async s=>{try{return await this.engine.disconnect(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"find",s=>{try{return this.engine.find(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}}),W(this,"authenticate",async(s,r)=>{try{return await this.engine.authenticate(s,r)}catch(n){throw this.logger.error(n.message),n}}),W(this,"formatAuthMessage",s=>{try{return this.engine.formatAuthMessage(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"approveSessionAuthenticate",async s=>{try{return await this.engine.approveSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),W(this,"rejectSessionAuthenticate",async s=>{try{return await this.engine.rejectSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),this.name=e?.name||Zr.name,this.metadata=Xy(e?.metadata),this.signConfig=e?.signConfig;const t=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:Mn(sr({level:e?.logger||Zr.logger}));this.core=e?.core||new BI(e),this.logger=Ne(t,this.name),this.session=new QI(this.core,this.logger),this.proposal=new ZI(this.core,this.logger),this.pendingRequest=new XI(this.core,this.logger),this.engine=new YI(this),this.auth=new n$(this.core,this.logger)}static async init(e){const t=new ru(e);return await t.initialize(),t}get context(){return Ve(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},T.toMiliseconds(T.ONE_SECOND))}catch(e){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(e.message),e}}};const qc="error",h$="wss://relay.walletconnect.org",l$="wc",u$="universal_provider",Ds=`${l$}@2:${u$}:`,nu="https://rpc.walletconnect.org/v1/",xi="generic",d$=`${nu}bundler`,tt={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function p$(){}function co(i){return i==null||typeof i!="object"&&typeof i!="function"}function ho(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)}function f$(i){if(co(i))return i;if(Array.isArray(i)||ho(i)||i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer)return i.slice(0);const e=Object.getPrototypeOf(i),t=e.constructor;if(i instanceof Date||i instanceof Map||i instanceof Set)return new t(i);if(i instanceof RegExp){const s=new t(i);return s.lastIndex=i.lastIndex,s}if(i instanceof DataView)return new t(i.buffer.slice(0));if(i instanceof Error){const s=new t(i.message);return s.stack=i.stack,s.name=i.name,s.cause=i.cause,s}if(typeof File<"u"&&i instanceof File)return new t([i],i.name,{type:i.type,lastModified:i.lastModified});if(typeof i=="object"){const s=Object.create(e);return Object.assign(s,i)}return i}function Uc(i){return typeof i=="object"&&i!==null}function ou(i){return Object.getOwnPropertySymbols(i).filter(e=>Object.prototype.propertyIsEnumerable.call(i,e))}function au(i){return i==null?i===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(i)}const g$="[object RegExp]",cu="[object String]",hu="[object Number]",lu="[object Boolean]",uu="[object Arguments]",y$="[object Symbol]",m$="[object Date]",w$="[object Map]",b$="[object Set]",v$="[object Array]",E$="[object ArrayBuffer]",I$="[object Object]",$$="[object DataView]",_$="[object Uint8Array]",P$="[object Uint8ClampedArray]",S$="[object Uint16Array]",x$="[object Uint32Array]",O$="[object Int8Array]",A$="[object Int16Array]",C$="[object Int32Array]",R$="[object Float32Array]",N$="[object Float64Array]";function T$(i,e){return Ci(i,void 0,i,new Map,e)}function Ci(i,e,t,s=new Map,r=void 0){const n=r?.(i,e,t,s);if(n!=null)return n;if(co(i))return i;if(s.has(i))return s.get(i);if(Array.isArray(i)){const o=new Array(i.length);s.set(i,o);for(let a=0;a<i.length;a++)o[a]=Ci(i[a],a,t,s,r);return Object.hasOwn(i,"index")&&(o.index=i.index),Object.hasOwn(i,"input")&&(o.input=i.input),o}if(i instanceof Date)return new Date(i.getTime());if(i instanceof RegExp){const o=new RegExp(i.source,i.flags);return o.lastIndex=i.lastIndex,o}if(i instanceof Map){const o=new Map;s.set(i,o);for(const[a,c]of i)o.set(a,Ci(c,a,t,s,r));return o}if(i instanceof Set){const o=new Set;s.set(i,o);for(const a of i)o.add(Ci(a,void 0,t,s,r));return o}if(typeof Buffer<"u"&&Buffer.isBuffer(i))return i.subarray();if(ho(i)){const o=new(Object.getPrototypeOf(i)).constructor(i.length);s.set(i,o);for(let a=0;a<i.length;a++)o[a]=Ci(i[a],a,t,s,r);return o}if(i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer)return i.slice(0);if(i instanceof DataView){const o=new DataView(i.buffer.slice(0),i.byteOffset,i.byteLength);return s.set(i,o),Gt(o,i,t,s,r),o}if(typeof File<"u"&&i instanceof File){const o=new File([i],i.name,{type:i.type});return s.set(i,o),Gt(o,i,t,s,r),o}if(i instanceof Blob){const o=new Blob([i],{type:i.type});return s.set(i,o),Gt(o,i,t,s,r),o}if(i instanceof Error){const o=new i.constructor;return s.set(i,o),o.message=i.message,o.name=i.name,o.stack=i.stack,o.cause=i.cause,Gt(o,i,t,s,r),o}if(typeof i=="object"&&B$(i)){const o=Object.create(Object.getPrototypeOf(i));return s.set(i,o),Gt(o,i,t,s,r),o}return i}function Gt(i,e,t=i,s,r){const n=[...Object.keys(e),...ou(e)];for(let o=0;o<n.length;o++){const a=n[o],c=Object.getOwnPropertyDescriptor(i,a);(c==null||c.writable)&&(i[a]=Ci(e[a],a,t,s,r))}}function B$(i){switch(au(i)){case uu:case v$:case E$:case $$:case lu:case m$:case R$:case N$:case O$:case A$:case C$:case w$:case hu:case I$:case g$:case b$:case cu:case y$:case _$:case P$:case S$:case x$:return!0;default:return!1}}function D$(i,e){return T$(i,(t,s,r,n)=>{if(typeof i=="object")switch(Object.prototype.toString.call(i)){case hu:case cu:case lu:{const o=new i.constructor(i?.valueOf());return Gt(o,i),o}case uu:{const o={};return Gt(o,i),o.length=i.length,o[Symbol.iterator]=i[Symbol.iterator],o}default:return}})}function Lc(i){return D$(i)}function Mc(i){return i!==null&&typeof i=="object"&&au(i)==="[object Arguments]"}function j$(i){return ho(i)}function k$(i){if(typeof i!="object"||i==null)return!1;if(Object.getPrototypeOf(i)===null)return!0;if(Object.prototype.toString.call(i)!=="[object Object]"){const t=i[Symbol.toStringTag];return t==null||!Object.getOwnPropertyDescriptor(i,Symbol.toStringTag)?.writable?!1:i.toString()===`[object ${t}]`}let e=i;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(i)===e}function q$(i,...e){const t=e.slice(0,-1),s=e[e.length-1];let r=i;for(let n=0;n<t.length;n++){const o=t[n];r=kn(r,o,s,new Map)}return r}function kn(i,e,t,s){if(co(i)&&(i=Object(i)),e==null||typeof e!="object")return i;if(s.has(e))return f$(s.get(e));if(s.set(e,i),Array.isArray(e)){e=e.slice();for(let n=0;n<e.length;n++)e[n]=e[n]??void 0}const r=[...Object.keys(e),...ou(e)];for(let n=0;n<r.length;n++){const o=r[n];let a=e[o],c=i[o];if(Mc(a)&&(a={...a}),Mc(c)&&(c={...c}),typeof Buffer<"u"&&Buffer.isBuffer(a)&&(a=Lc(a)),Array.isArray(a))if(typeof c=="object"&&c!=null){const l=[],u=Reflect.ownKeys(c);for(let d=0;d<u.length;d++){const f=u[d];l[f]=c[f]}c=l}else c=[];const h=t(c,a,o,i,e,s);h!=null?i[o]=h:Array.isArray(a)||Uc(c)&&Uc(a)?i[o]=kn(c,a,t,s):c==null&&k$(a)?i[o]=kn({},a,t,s):c==null&&j$(a)?i[o]=Lc(a):(c===void 0||a!==void 0)&&(i[o]=a)}return i}function U$(i,...e){return q$(i,...e,p$)}var L$=Object.defineProperty,M$=Object.defineProperties,F$=Object.getOwnPropertyDescriptors,Fc=Object.getOwnPropertySymbols,z$=Object.prototype.hasOwnProperty,H$=Object.prototype.propertyIsEnumerable,zc=(i,e,t)=>e in i?L$(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,js=(i,e)=>{for(var t in e||(e={}))z$.call(e,t)&&zc(i,t,e[t]);if(Fc)for(var t of Fc(e))H$.call(e,t)&&zc(i,t,e[t]);return i},K$=(i,e)=>M$(i,F$(e));function Ke(i,e,t){var s;const r=Ri(i);return((s=e.rpcMap)==null?void 0:s[r.reference])||`${nu}?chainId=${r.namespace}:${r.reference}&projectId=${t}`}function ci(i){return i.includes(":")?i.split(":")[1]:i}function du(i){return i.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function V$(i,e){const t=Object.keys(e.namespaces).filter(r=>r.includes(i));if(!t.length)return[];const s=[];return t.forEach(r=>{const n=e.namespaces[r].accounts;s.push(...n)}),s}function ks(i={},e={}){const t=Hc(i),s=Hc(e);return U$(t,s)}function Hc(i){var e,t,s,r,n;const o={};if(!Ut(i))return o;for(const[a,c]of Object.entries(i)){const h=yr(a)?[a]:c.chains,l=c.methods||[],u=c.events||[],d=c.rpcMap||{},f=Ai(a);o[f]=K$(js(js({},o[f]),c),{chains:wt(h,(e=o[f])==null?void 0:e.chains),methods:wt(l,(t=o[f])==null?void 0:t.methods),events:wt(u,(s=o[f])==null?void 0:s.events)}),(Ut(d)||Ut(((r=o[f])==null?void 0:r.rpcMap)||{}))&&(o[f].rpcMap=js(js({},d),(n=o[f])==null?void 0:n.rpcMap))}return o}function Kc(i){return i.includes(":")?i.split(":")[2]:i}function Vc(i){const e={};for(const[t,s]of Object.entries(i)){const r=s.methods||[],n=s.events||[],o=s.accounts||[],a=yr(t)?[t]:s.chains?s.chains:du(s.accounts);e[t]={chains:a,methods:r,events:n,accounts:o}}return e}function en(i){return typeof i=="number"?i:i.includes("0x")?parseInt(i,16):(i=i.includes(":")?i.split(":")[1]:i,isNaN(Number(i))?i:Number(i))}const pu={},Q=i=>pu[i],tn=(i,e)=>{pu[i]=e};var W$=Object.defineProperty,G$=(i,e,t)=>e in i?W$(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,yi=(i,e,t)=>G$(i,typeof e!="symbol"?e+"":e,t);class J${constructor(e){yi(this,"name","polkadot"),yi(this,"client"),yi(this,"httpProviders"),yi(this,"events"),yi(this,"namespace"),yi(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ci(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new et(new ht(s,Q("disableProviderPing")))}}var Y$=Object.defineProperty,Z$=Object.defineProperties,Q$=Object.getOwnPropertyDescriptors,Wc=Object.getOwnPropertySymbols,X$=Object.prototype.hasOwnProperty,e2=Object.prototype.propertyIsEnumerable,qn=(i,e,t)=>e in i?Y$(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Gc=(i,e)=>{for(var t in e||(e={}))X$.call(e,t)&&qn(i,t,e[t]);if(Wc)for(var t of Wc(e))e2.call(e,t)&&qn(i,t,e[t]);return i},Jc=(i,e)=>Z$(i,Q$(e)),mi=(i,e,t)=>qn(i,typeof e!="symbol"?e+"":e,t);class t2{constructor(e){mi(this,"name","eip155"),mi(this,"client"),mi(this,"chainId"),mi(this,"namespace"),mi(this,"httpProviders"),mi(this,"events"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(parseInt(e),t),this.chainId=parseInt(e),this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,t){const s=t||Ke(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new et(new ht(s,Q("disableProviderPing")))}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=parseInt(ci(t));e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}getHttpProvider(){const e=this.chainId,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}async handleSwitchChain(e){var t,s;let r=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0";r=r.startsWith("0x")?r:`0x${r}`;const n=parseInt(r,16);if(this.isChainApproved(n))this.setDefaultChain(`${n}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:r}]},chainId:(s=this.namespace.chains)==null?void 0:s[0]}),this.setDefaultChain(`${n}`);else throw new Error(`Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var t,s,r,n,o;const a=(s=(t=e.request)==null?void 0:t.params)==null?void 0:s[0],c=((n=(r=e.request)==null?void 0:r.params)==null?void 0:n[1])||[],h=`${a}${c.join(",")}`;if(!a)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const l=this.client.session.get(e.topic),u=((o=l?.sessionProperties)==null?void 0:o.capabilities)||{};if(u!=null&&u[h])return u?.[h];const d=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:Jc(Gc({},l.sessionProperties||{}),{capabilities:Jc(Gc({},u||{}),{[h]:d})})})}catch{}return d}async getCallStatus(e){var t,s;const r=this.client.session.get(e.topic),n=(t=r.sessionProperties)==null?void 0:t.bundler_name;if(n){const a=this.getBundlerUrl(e.chainId,n);try{return await this.getUserOperationReceipt(a,e)}catch{}}const o=(s=r.sessionProperties)==null?void 0:s.bundler_url;if(o)try{return await this.getUserOperationReceipt(o,e)}catch{}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,t){var s;const r=new URL(e),n=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(jt("eth_getUserOperationReceipt",[(s=t.request.params)==null?void 0:s[0]]))});if(!n.ok)throw new Error(`Failed to fetch user operation receipt - ${n.status}`);return await n.json()}getBundlerUrl(e,t){return`${d$}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`}}var i2=Object.defineProperty,s2=(i,e,t)=>e in i?i2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,wi=(i,e,t)=>s2(i,typeof e!="symbol"?e+"":e,t);class r2{constructor(e){wi(this,"name","solana"),wi(this,"client"),wi(this,"httpProviders"),wi(this,"events"),wi(this,"namespace"),wi(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ci(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new et(new ht(s,Q("disableProviderPing")))}}var n2=Object.defineProperty,o2=(i,e,t)=>e in i?n2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,bi=(i,e,t)=>o2(i,typeof e!="symbol"?e+"":e,t);class a2{constructor(e){bi(this,"name","cosmos"),bi(this,"client"),bi(this,"httpProviders"),bi(this,"events"),bi(this,"namespace"),bi(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ci(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new et(new ht(s,Q("disableProviderPing")))}}var c2=Object.defineProperty,h2=(i,e,t)=>e in i?c2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,vi=(i,e,t)=>h2(i,typeof e!="symbol"?e+"":e,t);class l2{constructor(e){vi(this,"name","algorand"),vi(this,"client"),vi(this,"httpProviders"),vi(this,"events"),vi(this,"namespace"),vi(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(!this.httpProviders[e]){const s=t||Ke(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.chainId=e,this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;e[t]=this.createHttpProvider(t,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new et(new ht(s,Q("disableProviderPing")))}}var u2=Object.defineProperty,d2=(i,e,t)=>e in i?u2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ei=(i,e,t)=>d2(i,typeof e!="symbol"?e+"":e,t);class p2{constructor(e){Ei(this,"name","cip34"),Ei(this,"client"),Ei(this,"httpProviders"),Ei(this,"events"),Ei(this,"namespace"),Ei(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const s=this.getCardanoRPCUrl(t),r=ci(t);e[r]=this.createHttpProvider(r,s)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}getCardanoRPCUrl(e){const t=this.namespace.rpcMap;if(t)return t[e]}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||this.getCardanoRPCUrl(e);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new et(new ht(s,Q("disableProviderPing")))}}var f2=Object.defineProperty,g2=(i,e,t)=>e in i?f2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ii=(i,e,t)=>g2(i,typeof e!="symbol"?e+"":e,t);class y2{constructor(e){Ii(this,"name","elrond"),Ii(this,"client"),Ii(this,"httpProviders"),Ii(this,"events"),Ii(this,"namespace"),Ii(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ci(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new et(new ht(s,Q("disableProviderPing")))}}var m2=Object.defineProperty,w2=(i,e,t)=>e in i?m2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,$i=(i,e,t)=>w2(i,typeof e!="symbol"?e+"":e,t);class b2{constructor(e){$i(this,"name","multiversx"),$i(this,"client"),$i(this,"httpProviders"),$i(this,"events"),$i(this,"namespace"),$i(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ci(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new et(new ht(s,Q("disableProviderPing")))}}var v2=Object.defineProperty,E2=(i,e,t)=>e in i?v2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,_i=(i,e,t)=>E2(i,typeof e!="symbol"?e+"":e,t);class I2{constructor(e){_i(this,"name","near"),_i(this,"client"),_i(this,"httpProviders"),_i(this,"events"),_i(this,"namespace"),_i(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||Ke(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;e[t]=this.createHttpProvider(t,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace);return typeof s>"u"?void 0:new et(new ht(s,Q("disableProviderPing")))}}var $2=Object.defineProperty,_2=(i,e,t)=>e in i?$2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Pi=(i,e,t)=>_2(i,typeof e!="symbol"?e+"":e,t);class P2{constructor(e){Pi(this,"name","tezos"),Pi(this,"client"),Pi(this,"httpProviders"),Pi(this,"events"),Pi(this,"namespace"),Pi(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||Ke(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace);return typeof s>"u"?void 0:new et(new ht(s))}}var S2=Object.defineProperty,x2=(i,e,t)=>e in i?S2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Si=(i,e,t)=>x2(i,typeof e!="symbol"?e+"":e,t);class O2{constructor(e){Si(this,"name",xi),Si(this,"client"),Si(this,"httpProviders"),Si(this,"events"),Si(this,"namespace"),Si(this,"chainId"),this.namespace=e.namespace,this.events=Q("events"),this.client=Q("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(tt.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){var e,t;const s={};return(t=(e=this.namespace)==null?void 0:e.accounts)==null||t.forEach(r=>{const n=Ri(r);s[`${n.namespace}:${n.reference}`]=this.createHttpProvider(r)}),s}getHttpProvider(e){const t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||Ke(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new et(new ht(s,Q("disableProviderPing")))}}var A2=Object.defineProperty,C2=Object.defineProperties,R2=Object.getOwnPropertyDescriptors,Yc=Object.getOwnPropertySymbols,N2=Object.prototype.hasOwnProperty,T2=Object.prototype.propertyIsEnumerable,Un=(i,e,t)=>e in i?A2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,qs=(i,e)=>{for(var t in e||(e={}))N2.call(e,t)&&Un(i,t,e[t]);if(Yc)for(var t of Yc(e))T2.call(e,t)&&Un(i,t,e[t]);return i},sn=(i,e)=>C2(i,R2(e)),Je=(i,e,t)=>Un(i,typeof e!="symbol"?e+"":e,t);let B2=class fu{constructor(e){Je(this,"client"),Je(this,"namespaces"),Je(this,"optionalNamespaces"),Je(this,"sessionProperties"),Je(this,"scopedProperties"),Je(this,"events",new Fn),Je(this,"rpcProviders",{}),Je(this,"session"),Je(this,"providerOpts"),Je(this,"logger"),Je(this,"uri"),Je(this,"disableProviderPing",!1),this.providerOpts=e,this.logger=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:Mn(sr({level:e?.logger||qc})),this.disableProviderPing=e?.disableProviderPing||!1}static async init(e){const t=new fu(e);return await t.initialize(),t}async request(e,t,s){const[r,n]=this.validateChain(t);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(r).request({request:qs({},e),chainId:`${r}:${n}`,topic:this.session.topic,expiry:s})}sendAsync(e,t,s,r){const n=new Date().getTime();this.request(e,s,r).then(o=>t(null,rr(n,o))).catch(o=>t(o,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:te("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),await this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,t){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:s,response:r}=await this.client.authenticate(e,t);s&&(this.uri=s,this.events.emit("display_uri",s));const n=await r();if(this.session=n.session,this.session){const o=Vc(this.session.namespaces);this.namespaces=ks(this.namespaces,o),await this.persist("namespaces",this.namespaces),this.onConnect()}return n}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}removeListener(e,t){this.events.removeListener(e,t)}off(e,t){this.events.off(e,t)}get isWalletConnect(){return!0}async pair(e){const{uri:t,approval:s}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});t&&(this.uri=t,this.events.emit("display_uri",t));const r=await s();this.session=r;const n=Vc(r.namespaces);return this.namespaces=ks(this.namespaces,n),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,t){try{if(!this.session)return;const[s,r]=this.validateChain(e),n=this.getProvider(s);n.name===xi?n.setDefaultChain(`${s}:${r}`,t):n.setDefaultChain(r,t)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(e={}){this.logger.info("Cleaning up inactive pairings...");const t=this.client.pairing.getAll();if(ct(t)){for(const s of t)e.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${t.length}`)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,t;if(this.client=this.providerOpts.client||await c$.init({core:this.providerOpts.core,logger:this.providerOpts.logger||qc,relayUrl:this.providerOpts.relayUrl||h$,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(s){throw this.logger.error("Failed to get session",s),new Error(`The provided session: ${(t=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:t.topic} doesn't exist in the Sign client`)}else{const s=this.client.session.getAll();this.session=s[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(t=>Ai(t)))];tn("client",this.client),tn("events",this.events),tn("disableProviderPing",this.disableProviderPing),e.forEach(t=>{if(!this.session)return;const s=V$(t,this.session),r=du(s),n=ks(this.namespaces,this.optionalNamespaces),o=sn(qs({},n[t]),{accounts:s,chains:r});switch(t){case"eip155":this.rpcProviders[t]=new t2({namespace:o});break;case"algorand":this.rpcProviders[t]=new l2({namespace:o});break;case"solana":this.rpcProviders[t]=new r2({namespace:o});break;case"cosmos":this.rpcProviders[t]=new a2({namespace:o});break;case"polkadot":this.rpcProviders[t]=new J$({namespace:o});break;case"cip34":this.rpcProviders[t]=new p2({namespace:o});break;case"elrond":this.rpcProviders[t]=new y2({namespace:o});break;case"multiversx":this.rpcProviders[t]=new b2({namespace:o});break;case"near":this.rpcProviders[t]=new I2({namespace:o});break;case"tezos":this.rpcProviders[t]=new P2({namespace:o});break;default:this.rpcProviders[xi]?this.rpcProviders[xi].updateNamespace(o):this.rpcProviders[xi]=new O2({namespace:o})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var t;const{topic:s}=e;s===((t=this.session)==null?void 0:t.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var t;const{params:s,topic:r}=e;if(r!==((t=this.session)==null?void 0:t.topic))return;const{event:n}=s;if(n.name==="accountsChanged"){const o=n.data;o&&ct(o)&&this.events.emit("accountsChanged",o.map(Kc))}else if(n.name==="chainChanged"){const o=s.chainId,a=s.event.data,c=Ai(o),h=en(o)!==en(a)?`${c}:${en(a)}`:o;this.onChainChanged(h)}else this.events.emit(n.name,n.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:t})=>{var s,r;if(e!==((s=this.session)==null?void 0:s.topic))return;const{namespaces:n}=t,o=(r=this.client)==null?void 0:r.session.get(e);this.session=sn(qs({},o),{namespaces:n}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:t})}),this.client.on("session_delete",async e=>{var t;e.topic===((t=this.session)==null?void 0:t.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",sn(qs({},te("USER_DISCONNECTED")),{data:e.topic})))}),this.on(tt.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(e,!0)})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[xi]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var t;this.getProvider(e).updateNamespace((t=this.session)==null?void 0:t.namespaces[e])})}setNamespaces(e){const{namespaces:t={},optionalNamespaces:s={},sessionProperties:r,scopedProperties:n}=e;this.optionalNamespaces=ks(t,s),this.sessionProperties=r,this.scopedProperties=n}validateChain(e){const[t,s]=e?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[t,s];if(t&&!Object.keys(this.namespaces||{}).map(o=>Ai(o)).includes(t))throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);if(t&&s)return[t,s];const r=Ai(Object.keys(this.namespaces)[0]),n=this.rpcProviders[r].getDefaultChain();return[r,n]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged(e,t=!1){if(!this.namespaces)return;const[s,r]=this.validateChain(e);if(!r)return;this.updateNamespaceChain(s,r),this.events.emit("chainChanged",r);const n=this.getProvider(s).getDefaultChain();t||this.getProvider(s).setDefaultChain(r),this.emitAccountsChangedOnChainChange({namespace:s,previousChainId:n,newChainId:e}),await this.persist("namespaces",this.namespaces)}emitAccountsChangedOnChainChange({namespace:e,previousChainId:t,newChainId:s}){var r,n;try{if(t===s)return;const o=(n=(r=this.session)==null?void 0:r.namespaces[e])==null?void 0:n.accounts;if(!o)return;const a=o.filter(c=>c.includes(`${s}:`)).map(Kc);if(!ct(a))return;this.events.emit("accountsChanged",a)}catch(o){this.logger.warn("Failed to emit accountsChanged on chain change",o)}}updateNamespaceChain(e,t){if(!this.namespaces)return;const s=this.namespaces[e]?e:`${e}:${t}`,r={chains:[],methods:[],events:[],defaultChain:t};this.namespaces[s]?this.namespaces[s]&&(this.namespaces[s].defaultChain=t):this.namespaces[s]=r}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,t){var s;const r=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.setItem(`${Ds}/${e}${r}`,t)}async getFromStore(e){var t;const s=((t=this.session)==null?void 0:t.topic)||"";return await this.client.core.storage.getItem(`${Ds}/${e}${s}`)}async deleteFromStore(e){var t;const s=((t=this.session)==null?void 0:t.topic)||"";await this.client.core.storage.removeItem(`${Ds}/${e}${s}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const t=await this.client.core.storage.getKeys();for(const s of t)s.startsWith(Ds)&&await this.client.core.storage.removeItem(s)}catch(t){this.logger.warn("Failed to cleanup storage",t)}}};const D2=B2,j2="wc",k2="ethereum_provider",q2=`${j2}@2:${k2}:`,U2="https://rpc.walletconnect.org/v1/",er=["eth_sendTransaction","personal_sign"],gu=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_sendCalls","wallet_getCapabilities","wallet_getCallsStatus","wallet_showCallsStatus"],tr=["chainChanged","accountsChanged"],yu=["chainChanged","accountsChanged","message","disconnect","connect"],L2=async()=>{const{createAppKit:i}=await eh(()=>import("./core-CZ-n-4YL.js").then(e=>e.J),__vite__mapDeps([3,1,2]));return i};var M2=Object.defineProperty,F2=Object.defineProperties,z2=Object.getOwnPropertyDescriptors,Zc=Object.getOwnPropertySymbols,H2=Object.prototype.hasOwnProperty,K2=Object.prototype.propertyIsEnumerable,Ln=(i,e,t)=>e in i?M2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ht=(i,e)=>{for(var t in e||(e={}))H2.call(e,t)&&Ln(i,t,e[t]);if(Zc)for(var t of Zc(e))K2.call(e,t)&&Ln(i,t,e[t]);return i},ts=(i,e)=>F2(i,z2(e)),Le=(i,e,t)=>Ln(i,typeof e!="symbol"?e+"":e,t);function ir(i){return Number(i[0].split(":")[1])}function Us(i){return`0x${i.toString(16)}`}function V2(i){const{chains:e,optionalChains:t,methods:s,optionalMethods:r,events:n,optionalEvents:o,rpcMap:a}=i;if(!ct(e))throw new Error("Invalid chains");const c={chains:e,methods:s||er,events:n||tr,rpcMap:Ht({},e.length?{[ir(e)]:a[ir(e)]}:{})},h=n?.filter(f=>!tr.includes(f)),l=s?.filter(f=>!er.includes(f));if(!t&&!o&&!r&&!(h!=null&&h.length)&&!(l!=null&&l.length))return{required:e.length?c:void 0};const u=h?.length&&l?.length||!t,d={chains:[...new Set(u?c.chains.concat(t||[]):t)],methods:[...new Set(c.methods.concat(r!=null&&r.length?r:gu))],events:[...new Set(c.events.concat(o!=null&&o.length?o:yu))],rpcMap:a};return{required:e.length?c:void 0,optional:t.length?d:void 0}}class br{constructor(){Le(this,"events",new Xe.EventEmitter),Le(this,"namespace","eip155"),Le(this,"accounts",[]),Le(this,"signer"),Le(this,"chainId",1),Le(this,"modal"),Le(this,"rpc"),Le(this,"STORAGE_KEY",q2),Le(this,"on",(e,t)=>(this.events.on(e,t),this)),Le(this,"once",(e,t)=>(this.events.once(e,t),this)),Le(this,"removeListener",(e,t)=>(this.events.removeListener(e,t),this)),Le(this,"off",(e,t)=>(this.events.off(e,t),this)),Le(this,"parseAccount",e=>this.isCompatibleChainId(e)?this.parseAccountId(e).address:e),this.signer={},this.rpc={}}static async init(e){const t=new br;return await t.initialize(e),t}async request(e,t){return await this.signer.request(e,this.formatChainId(this.chainId),t)}sendAsync(e,t,s){this.signer.sendAsync(e,t,this.formatChainId(this.chainId),s)}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(e){var t;if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(e);const{required:s,optional:r}=V2(this.rpc);try{const n=await new Promise(async(a,c)=>{var h,l;this.rpc.showQrModal&&((h=this.modal)==null||h.open(),(l=this.modal)==null||l.subscribeState(d=>{!d.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),c(new Error("Connection request reset. Please try again.")))}));const u=e!=null&&e.scopedProperties?{[this.namespace]:e.scopedProperties}:void 0;await this.signer.connect(ts(Ht({namespaces:Ht({},s&&{[this.namespace]:s})},r&&{optionalNamespaces:{[this.namespace]:r}}),{pairingTopic:e?.pairingTopic,scopedProperties:u})).then(d=>{a(d)}).catch(d=>{var f;(f=this.modal)==null||f.showErrorMessage("Unable to connect"),c(new Error(d.message))})});if(!n)return;const o=pa(n.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:o),this.setAccounts(o),this.events.emit("connect",{chainId:Us(this.chainId)})}catch(n){throw this.signer.logger.error(n),n}finally{(t=this.modal)==null||t.close()}}async authenticate(e,t){var s;if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts({chains:e?.chains});try{const r=await new Promise(async(o,a)=>{var c,h;this.rpc.showQrModal&&((c=this.modal)==null||c.open(),(h=this.modal)==null||h.subscribeState(l=>{!l.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),a(new Error("Connection request reset. Please try again.")))})),await this.signer.authenticate(ts(Ht({},e),{chains:this.rpc.chains}),t).then(l=>{o(l)}).catch(l=>{var u;(u=this.modal)==null||u.showErrorMessage("Unable to connect"),a(new Error(l.message))})}),n=r.session;if(n){const o=pa(n.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:o),this.setAccounts(o),this.events.emit("connect",{chainId:Us(this.chainId)})}return r}catch(r){throw this.signer.logger.error(r),r}finally{(s=this.modal)==null||s.close()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",e=>{const{params:t}=e,{event:s}=t;s.name==="accountsChanged"?(this.accounts=this.parseAccounts(s.data),this.events.emit("accountsChanged",this.accounts)):s.name==="chainChanged"?this.setChainId(this.formatChainId(s.data)):this.events.emit(s.name,s.data),this.events.emit("session_event",e)}),this.signer.on("accountsChanged",e=>{this.accounts=this.parseAccounts(e),this.events.emit("accountsChanged",this.accounts)}),this.signer.on("chainChanged",e=>{const t=parseInt(e);this.chainId=t,this.events.emit("chainChanged",Us(this.chainId)),this.persist()}),this.signer.on("session_update",e=>{this.events.emit("session_update",e)}),this.signer.on("session_delete",e=>{this.reset(),this.events.emit("session_delete",e),this.events.emit("disconnect",ts(Ht({},te("USER_DISCONNECTED")),{data:e.topic,name:"USER_DISCONNECTED"}))}),this.signer.on("display_uri",e=>{this.events.emit("display_uri",e)})}switchEthereumChain(e){this.request({method:"wallet_switchEthereumChain",params:[{chainId:e.toString(16)}]})}isCompatibleChainId(e){return typeof e=="string"?e.startsWith(`${this.namespace}:`):!1}formatChainId(e){return`${this.namespace}:${e}`}parseChainId(e){return Number(e.split(":")[1])}setChainIds(e){const t=e.filter(s=>this.isCompatibleChainId(s)).map(s=>this.parseChainId(s));t.length&&(this.chainId=t[0],this.events.emit("chainChanged",Us(this.chainId)),this.persist())}setChainId(e){if(this.isCompatibleChainId(e)){const t=this.parseChainId(e);this.chainId=t,this.switchEthereumChain(t)}}parseAccountId(e){const[t,s,r]=e.split(":");return{chainId:`${t}:${s}`,address:r}}setAccounts(e){this.accounts=e.filter(t=>this.parseChainId(this.parseAccountId(t).chainId)===this.chainId).map(t=>this.parseAccountId(t).address),this.events.emit("accountsChanged",this.accounts)}getRpcConfig(e){var t,s;const r=(t=e?.chains)!=null?t:[],n=(s=e?.optionalChains)!=null?s:[],o=r.concat(n);if(!o.length)throw new Error("No chains specified in either `chains` or `optionalChains`");const a=r.length?e?.methods||er:[],c=r.length?e?.events||tr:[],h=e?.optionalMethods||[],l=e?.optionalEvents||[],u=e?.rpcMap||this.buildRpcMap(o,e.projectId),d=e?.qrModalOptions||void 0;return{chains:r?.map(f=>this.formatChainId(f)),optionalChains:n.map(f=>this.formatChainId(f)),methods:a,events:c,optionalMethods:h,optionalEvents:l,rpcMap:u,showQrModal:!!(e!=null&&e.showQrModal),qrModalOptions:d,projectId:e.projectId,metadata:e.metadata}}buildRpcMap(e,t){const s={};return e.forEach(r=>{s[r]=this.getRpcUrl(r,t)}),s}async initialize(e){if(this.rpc=this.getRpcConfig(e),this.chainId=this.rpc.chains.length?ir(this.rpc.chains):ir(this.rpc.optionalChains),this.signer=await D2.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:e.disableProviderPing,relayUrl:e.relayUrl,storage:e.storage,storageOptions:e.storageOptions,customStoragePrefix:e.customStoragePrefix,telemetryEnabled:e.telemetryEnabled,logger:e.logger}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let t;try{const s=await L2(),{convertWCMToAppKitOptions:r}=await Promise.resolve().then(function(){return s_}),n=r(ts(Ht({},this.rpc.qrModalOptions),{chains:[...new Set([...this.rpc.chains,...this.rpc.optionalChains])],metadata:this.rpc.metadata,projectId:this.rpc.projectId}));if(!n.networks.length)throw new Error("No networks found for WalletConnect");t=s(ts(Ht({},n),{universalProvider:this.signer,manualWCControl:!0}))}catch{throw new Error("To use QR modal, please install @reown/appkit package")}if(t)try{this.modal=t}catch(s){throw this.signer.logger.error(s),new Error("Could not generate WalletConnectModal Instance")}}}loadConnectOpts(e){if(!e)return;const{chains:t,optionalChains:s,rpcMap:r}=e;t&&ct(t)&&(this.rpc.chains=t.map(n=>this.formatChainId(n)),t.forEach(n=>{this.rpc.rpcMap[n]=r?.[n]||this.getRpcUrl(n)})),s&&ct(s)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=s?.map(n=>this.formatChainId(n)),s.forEach(n=>{this.rpc.rpcMap[n]=r?.[n]||this.getRpcUrl(n)}))}getRpcUrl(e,t){var s;return((s=this.rpc.rpcMap)==null?void 0:s[e])||`${U2}?chainId=eip155:${e}&projectId=${t||this.rpc.projectId}`}async loadPersistedSession(){if(this.session)try{const e=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),t=this.session.namespaces[`${this.namespace}:${e}`]?this.session.namespaces[`${this.namespace}:${e}`]:this.session.namespaces[this.namespace];this.setChainIds(e?[this.formatChainId(e)]:t?.accounts),this.setAccounts(t?.accounts)}catch(e){this.signer.logger.error("Failed to load persisted session, clearing state..."),this.signer.logger.error(e),await this.disconnect().catch(t=>this.signer.logger.warn(t))}}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(e){return typeof e=="string"||e instanceof String?[this.parseAccount(e)]:e.map(t=>this.parseAccount(t))}}const W2=br;var G2=Object.defineProperty,J2=Object.defineProperties,Y2=Object.getOwnPropertyDescriptors,Qc=Object.getOwnPropertySymbols,Z2=Object.prototype.hasOwnProperty,Q2=Object.prototype.propertyIsEnumerable,Xc=(i,e,t)=>e in i?G2(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,mu=(i,e)=>{for(var t in e||(e={}))Z2.call(e,t)&&Xc(i,t,e[t]);if(Qc)for(var t of Qc(e))Q2.call(e,t)&&Xc(i,t,e[t]);return i},X2=(i,e)=>J2(i,Y2(e));function e_(i){if(i)return{"--w3m-font-family":i["--wcm-font-family"],"--w3m-accent":i["--wcm-accent-color"],"--w3m-color-mix":i["--wcm-background-color"],"--w3m-z-index":i["--wcm-z-index"]?Number(i["--wcm-z-index"]):void 0,"--w3m-qr-color":i["--wcm-accent-color"],"--w3m-font-size-master":i["--wcm-text-medium-regular-size"],"--w3m-border-radius-master":i["--wcm-container-border-radius"],"--w3m-color-mix-strength":0}}const t_=i=>{const[e,t]=i.split(":");return wu({id:t,caipNetworkId:i,chainNamespace:e,name:"",nativeCurrency:{name:"",symbol:"",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}})};function i_(i){var e,t,s,r,n,o,a;const c=(e=i.chains)==null?void 0:e.map(t_).filter(Boolean);if(c.length===0)throw new Error("At least one chain must be specified");const h=c.find(u=>{var d;return u.id===((d=i.defaultChain)==null?void 0:d.id)}),l={projectId:i.projectId,networks:c,themeMode:i.themeMode,themeVariables:e_(i.themeVariables),chainImages:i.chainImages,connectorImages:i.walletImages,defaultNetwork:h,metadata:X2(mu({},i.metadata),{name:((t=i.metadata)==null?void 0:t.name)||"WalletConnect",description:((s=i.metadata)==null?void 0:s.description)||"Connect to WalletConnect-compatible wallets",url:((r=i.metadata)==null?void 0:r.url)||"https://walletconnect.org",icons:((n=i.metadata)==null?void 0:n.icons)||["https://walletconnect.org/walletconnect-logo.png"]}),showWallets:!0,featuredWalletIds:i.explorerRecommendedWalletIds==="NONE"?[]:Array.isArray(i.explorerRecommendedWalletIds)?i.explorerRecommendedWalletIds:[],excludeWalletIds:i.explorerExcludedWalletIds==="ALL"?[]:Array.isArray(i.explorerExcludedWalletIds)?i.explorerExcludedWalletIds:[],enableEIP6963:!1,enableInjected:!1,enableCoinbase:!0,enableWalletConnect:!0,features:{email:!1,socials:!1}};if((o=i.mobileWallets)!=null&&o.length||(a=i.desktopWallets)!=null&&a.length){const u=[...(i.mobileWallets||[]).map(p=>({id:p.id,name:p.name,links:p.links})),...(i.desktopWallets||[]).map(p=>({id:p.id,name:p.name,links:{native:p.links.native,universal:p.links.universal}}))],d=[...l.featuredWalletIds||[],...l.excludeWalletIds||[]],f=u.filter(p=>!d.includes(p.id));f.length&&(l.customWallets=f)}return l}function wu(i){return mu({formatters:void 0,fees:void 0,serializers:void 0},i)}var s_=Object.freeze({__proto__:null,convertWCMToAppKitOptions:i_,defineChain:wu});const M_=Object.freeze(Object.defineProperty({__proto__:null,EthereumProvider:W2,OPTIONAL_EVENTS:yu,OPTIONAL_METHODS:gu,REQUIRED_EVENTS:tr,REQUIRED_METHODS:er,default:br},Symbol.toStringTag,{value:"Module"}));export{Jt as A,nr as B,ed as C,yt as D,Ze as E,gt as F,ht as G,Ap as H,ni as I,M_ as J,da as P,Qh as Q,Mo as a,bp as b,u_ as c,l_ as d,ar as e,f_ as f,p_ as g,Qe as h,qe as i,Gu as j,rs as k,Gp as l,Dd as m,Td as n,jt as o,oi as p,et as q,d_ as r,dn as s,bh as t,Zv as u,Hn as v,Cp as w,or as x,rr as y,Uy as z};
